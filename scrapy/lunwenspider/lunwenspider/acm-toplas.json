[
{"abstract": "We propose a type system for lock-freedom in the \u03c0-calculus, which guarantees that certain communications will eventually succeed. Distinguishing features of our type system are: it can verify lock-freedom of concurrent programs that have sophisticated recursive communication structures; it can be fully automated; it is hybrid, in that it combines a type system for lock-freedom with local reasoning about deadlock-freedom, termination, and confluence analyses. Moreover, the type system is parameterized by deadlock-freedom/termination/confluence analyses, so that any methods (e.g. type systems and model checking) can be used for those analyses. A lock-freedom analysis tool has been implemented based on the proposed type system, and tested for nontrivial programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Naoki Kobayashi|Davide Sangiorgi|Naoki Kobayashi|Davide Sangiorgi|", "references": "", "organization": "Tohoku University, Miyagi, Japan|Universit\u00e0 di Bologna, Bologna, Italy|Tohoku University, Miyagi, Japan|Universit\u00e0 di Bologna, Bologna, Italy|", "title": ["A hybrid type system for lock-freedom of mobile processes"]},
{"abstract": "It is difficult to write programs that behave correctly in the presence of run-time errors. Proper behavior in the face of exceptional situations is important to the reliability of long-running programs. Existing programming language features often provide poor support for executing clean-up code and for restoring invariants.\nWe present a data-flow analysis for finding a certain class of exception-handling defects: those related to a failure to release resources or to clean up properly along all paths. Many real-world programs violate such resource usage rules because of incorrect exception handling. Our flow-sensitive analysis keeps track of outstanding obligations along program paths and does a precise modeling of control flow in the presence of exceptions. Using it, we have found over 1,300 exception handling defects in over 5 million lines of Java code.\nBased on those defects we propose a programming language feature, the compensation stack, that keeps track of obligations at run time and ensures that they are discharged. We present a type system for compensation stacks that tracks collections of obligations. Finally, we present case studies to demonstrate that this feature is natural, efficient, and can improve reliability.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Westley Weimer|George C. Necula|Westley Weimer|George C. Necula|", "references": "", "organization": "University of California, Berkeley, CA|University of California, Berkeley, CA|University of California, Berkeley, CA|University of California, Berkeley, CA|", "title": ["Exceptional situations and program reliability"]},
{"abstract": "SequenceL is a concise, high-level language with a simple semantics that provides for the automatic derivation of many iterative and parallel control structures. The semantics repeatedly applies a \u201cNormalize-Transpose-Distribute\u201d operation to functions and operators until base cases are discovered. Base cases include the grounding of variables and the application of built-in operators to operands of appropriate types. This article introduces the results of a 24-month effort to reduce the language to a very small set of primitives. Included are comparisons with other languages, the formal syntax and semantics, and the traces of several example problems run with a prototype interpreter developed in 2006.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Daniel E. Cooke|J. Nelson Rushton|Brad Nemanich|Robert G. Watson|Per Andersen|Daniel E. Cooke|J. Nelson Rushton|Brad Nemanich|Robert G. Watson|Per Andersen|", "references": "", "organization": "Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|Texas Tech University, Lubbock, TX|", "title": ["Normalize, transpose, and distribute: An automatic approach for handling nonscalars"]},
{"abstract": "Dynamic slicing is a well-known technique for program analysis, debugging and understanding. Given a program \n and input I, it finds all program statements which directly/indirectly affect the values of some variables' occurrences when \n is executed with I. In this article, we develop a dynamic slicing method for Java programs. Our technique proceeds by backwards traversal of the bytecode trace produced by an input I in a given program \n. Since such traces can be huge, we use results from data compression to compactly represent bytecode traces. The major space savings in our method come from the optimized representation of (a) data addresses used as operands by memory reference bytecodes, and (b) instruction addresses used as operands by control transfer bytecodes. We show how dynamic slicing algorithms can directly traverse our compact bytecode traces without resorting to costly decompression. We also extend our dynamic slicing algorithm to perform \u201crelevant slicing\u201d. The resultant slices can be used to explain omission errors that is, why some events did not happen during program execution. Detailed experimental results on space/time overheads of tracing and slicing are reported in the article. The slices computed at the bytecode level are translated back by our tool to the source code level with the help of information available in Java class files. Our \n dynamic slicing tool has been integrated with the Eclipse platform and is available for usage in research and development.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tao Wang|Abhik Roychoudhury|Tao Wang|Abhik Roychoudhury|", "references": "", "organization": "National University of Singapore, Singapore|National University of Singapore, Singapore|National University of Singapore, Singapore|National University of Singapore, Singapore|", "title": ["Dynamic slicing on Java bytecode traces"]},
{"abstract": "We show that reverse-mode AD (Automatic Differentiation)\u2014a generalized gradient-calculation operator\u2014can be incorporated as a first-class function in an augmented lambda calculus, and therefore into a functional-programming language. Closure is achieved, in that the new operator can be applied to any expression in the augmented language, yielding an expression in that language. This requires the resolution of two major technical issues: (a) how to transform nested lambda expressions, including those with free-variable references, and (b) how to support self application of the AD machinery. AD transformations preserve certain complexity properties, among them that the reverse phase of the reverse-mode AD transformation of a function have the same temporal complexity as the original untransformed function. First-class unrestricted AD operators increase the expressive power available to the numeric programmer, and may have significant practical implications for the construction of numeric software that is robust, modular, concise, correct, and efficient.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Barak A. Pearlmutter|Jeffrey Mark Siskind|Barak A. Pearlmutter|Jeffrey Mark Siskind|", "references": "", "organization": "National University of Ireland Maynooth, Co. Kildare, Ireland|Purdue University, West Lafayette, IN|National University of Ireland Maynooth, Co. Kildare, Ireland|Purdue University, West Lafayette, IN|", "title": ["Reverse-mode AD in a functional framework: Lambda the ultimate backpropagator"]},
{"abstract": "Today, software is traded worldwide on global markets, with apps being downloaded to smartphones within minutes or seconds. This poses, more than ever, the challenge of ensuring safety of software in the face of (1) unknown or untrusted software providers together with (2) resource-limited software consumers. The concept of Proof-Carrying Code (PCC), years ago suggested by Necula, provides one framework for securing the execution of untrusted code. PCC techniques attach safety proofs, constructed by software producers, to code. Based on the assumption that \n proofs is usually much simpler than \n proofs, software consumers should thus be able to quickly check the safety of software. However, PCC techniques often suffer from the size of \n (i.e., the attached proofs), making PCC techniques inefficient in practice.\nIn this article, we introduce a new framework for the safe execution of untrusted code called \n (PfP). The basic assumption underlying the PfP technique is the fact that the \n of programs significantly influences the complexity of checking a specific safety property. Instead of attaching proofs to program code, the PfP technique transforms the program into an efficiently checkable form, thus guaranteeing quick safety checks for software consumers. For this transformation, the technique also uses a producer-side automatic proof of safety. More specifically, safety proving for the software producer proceeds via the construction of an abstract reachability graph (ARG) unfolding the control-flow automaton (CFA) up to the degree necessary for simple checking. To this end, we combine different sorts of software analysis: expensive analyses incrementally determining the degree of unfolding, and cheap analyses responsible for safety checking. Out of the abstract reachability graph we generate the new program. In its CFA structure, it is isomorphic to the graph and hence another, this time consumer-side, cheap analysis can quickly determine its safety.\nLike PCC, Programs from Proofs is a general framework instantiable with different sorts of (expensive and cheap) analysis. Here, we present the general framework and exemplify it by some concrete examples. We have implemented different instantiations on top of the configurable program analysis tool CPA\n and report on experiments, in particular on comparisons with PCC techniques.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Marie-Christine Jakobs|Heike Wehrheim|Marie-Christine Jakobs|Heike Wehrheim|", "references": "", "organization": "Paderborn University (Germany)|Paderborn University (Germany)|Paderborn University (Germany)|Paderborn University (Germany)|", "title": ["Programs from Proofs: A Framework for the Safe Execution of Untrusted Software"]},
{"abstract": "Current critical systems often use a lot of floating-point computations, and thus the testing or static analysis of programs containing floating-point operators has become a priority. However, correctly defining the semantics of common implementations of floating-point is tricky, because semantics may change according to many factors beyond source-code level, such as choices made by compilers. We here give concrete examples of problems that can appear and solutions for implementing in analysis software.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "David Monniaux|David Monniaux|", "references": "", "organization": "CNRS/\u00c9cole normale sup\u00e9rieure, Paris, France|CNRS/\u00c9cole normale sup\u00e9rieure, Paris, France|", "title": ["The pitfalls of verifying floating-point computations"]},
{"abstract": "Pattern-based verification checks the correctness of program executions that follow a given \n, a regular expression over the alphabet of program transitions of the form \n \u2026 \n. For multithreaded programs, the alphabet of the pattern is given by the reads and writes to the shared storage. We study the complexity of pattern-based verification for multithreaded programs with shared counters and finite variables. While unrestricted verification is undecidable for abstracted multithreaded programs with recursive procedures and PSPACE-complete for abstracted multithreaded while-programs (even without counters), we show that pattern-based verification is NP-complete for both classes, even in the presence of counters. We then conduct a multiparameter analysis to study the complexity of the problem on its three natural parameters (number of threads+counters+variables, maximal size of a thread, size of the pattern) and on two parameters related to thread structure (maximal number of procedures per thread and longest simple path of procedure calls). We present an algorithm that for a fixed number of threads, counters, variables, and pattern size solves the verification problem in \n time, where \n is the maximal size of a thread, \n is the maximal number of procedures per thread, and \n is the longest simple path of procedure calls.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Javier Esparza|Pierre Ganty|Tom\u00e1\u0161 Poch|Javier Esparza|Pierre Ganty|Tom\u00e1\u0161 Poch|", "references": "", "organization": "Fakult\u00e4t f\u00fcr Informatik, Technische Universit\u00e4t M\u00fcnchen, Germany|IMDEA Software Institute, Madrid, Spain|Charles University Prague, Faculty of Mathematics and Physics, Czech Republic|Fakult\u00e4t f\u00fcr Informatik, Technische Universit\u00e4t M\u00fcnchen, Germany|IMDEA Software Institute, Madrid, Spain|Charles University Prague, Faculty of Mathematics and Physics, Czech Republic|", "title": ["Pattern-Based Verification for Multithreaded Programs"]},
{"abstract": "We study algorithmic questions wrt algebraic path properties in concurrent systems, where the transitions of the system are labeled from a complete, closed semiring. The algebraic path properties can model dataflow analysis problems, the shortest path problem, and many other natural problems that arise in program analysis. We consider that each component of the concurrent system is a graph with constant treewidth, a property satisfied by the controlflow graphs of most programs. We allow for multiple possible queries, which arise naturally in demand driven dataflow analysis. The study of multiple queries allows us to consider the tradeoff between the resource usage of the \n preprocessing and for \n query. The traditional approach constructs the product graph of all components and applies the best-known graph algorithm on the product. In this approach, even the answer to a single query requires the transitive closure (i.e., the results of all possible queries), which provides no room for tradeoff between preprocessing and query time.\nOur main contributions are algorithms that significantly improve the worst-case running time of the traditional approach, and provide various tradeoffs depending on the number of queries. For example, in a concurrent system of two components, the traditional approach requires hexic time in the worst case for answering one query as well as computing the transitive closure, whereas we show that with one-time preprocessing in almost cubic time, each subsequent query can be answered in at most linear time, and even the transitive closure can be computed in almost quartic time. Furthermore, we establish conditional optimality results showing that the worst-case running time of our algorithms cannot be improved without achieving major breakthroughs in graph algorithms (i.e., improving the worst-case bound for the shortest path problem in general graphs). Preliminary experimental results show that our algorithms perform favorably on several benchmarks.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Krishnendu Chatterjee|Rasmus Ibsen-Jensen|Amir Kafshdar Goharshady|Andreas Pavlogiannis|Krishnendu Chatterjee|Rasmus Ibsen-Jensen|Amir Kafshdar Goharshady|Andreas Pavlogiannis|", "references": "", "organization": "IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|IST Austria, Klosterneuburg, Austria|", "title": ["Algorithms for Algebraic Path Properties in Concurrent Systems of Constant Treewidth Components"]},
{"abstract": "On modern computer systems, the memory performance of an application depends on its locality. For a single execution, locality-correlated measures like average miss rate or working-set size have long been analyzed using \n\u2014the number of distinct locations accessed between consecutive accesses to a given location. This article addresses the analysis problem at the program level, where the size of data and the locality of execution may change significantly depending on the input.\nThe article presents two techniques that predict how the locality of a program changes with its input. The first is approximate reuse-distance measurement, which is asymptotically faster than exact methods while providing a guaranteed precision. The second is statistical prediction of locality in all executions of a program based on the analysis of a few executions. The prediction process has three steps: dividing data accesses into groups, finding the access patterns in each group, and building parameterized models. The resulting prediction may be used on-line with the help of distance-based sampling. When evaluated on fifteen benchmark applications, the new techniques predicted program locality with good accuracy, even for test executions that are orders of magnitude larger than the training executions.\nThe two techniques are among the first to enable quantitative analysis of whole-program locality in general sequential code. These findings form the basis for a unified understanding of program locality and its many facets. Concluding sections of the article present a taxonomy of related literature along five dimensions of locality and discuss the role of reuse distance in performance modeling, program optimization, cache and virtual memory management, and network traffic analysis.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Yutao Zhong|Xipeng Shen|Chen Ding|Yutao Zhong|Xipeng Shen|Chen Ding|", "references": "", "organization": "George Mason University, Fairfax, VA|The College of William and Mary, Williamsburg, VA|University of Rochester, Rochester, NY|George Mason University, Fairfax, VA|The College of William and Mary, Williamsburg, VA|University of Rochester, Rochester, NY|", "title": ["Program locality analysis using reuse distance"]},
{"abstract": "In the context of \n, we investigate classes that can be extended with \n composition. A trait is a collection of methods without state; it can be viewed as an \n. Traits can be composed in any order, but only make sense when imported by a class that provides state variables and additional methods to disambiguate conflicting names arising between the imported traits. We introduce FeatherTrait Java (FTJ), a conservative extension of the simple lightweight class-based calculus Featherweight Java (FJ) with \n. In FTJ, classes can be built using traits as basic behavioral bricks; method conflicts between imported traits must be resolved \n by the user either by (i) aliasing or excluding method names in traits, or by (ii) overriding explicitly the conflicting methods in the class or in the trait itself. We present an operational semantics with a lookup algorithm, and a sound type system that guarantees that evaluating a well-typed expression never yields a \n run-time error nor gets the interpreter stuck. We give examples of the increased expressive power of the trait-based inheritance model. The resulting calculus appears to be a good starting point for a rigorous mathematical analysis of typed class-based languages featuring trait-based inheritance.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Luigi Liquori|Arnaud Spiwack|Luigi Liquori|Arnaud Spiwack|", "references": "", "organization": "INRIA, France|ENS Cachan, France|INRIA, France|ENS Cachan, France|", "title": ["FeatherTrait: A modest extension of Featherweight Java"]},
{"abstract": "By studying the behavior of several programs that crash due to memory errors, we observed that locating the errors can be challenging because significant propagation of corrupt memory values can occur prior to the point of the crash. In this article, we present an automated approach for locating memory errors in the presence of memory corruption propagation. Our approach leverages the information revealed by a program crash: when a crash occurs, this reveals a subset of the memory corruption that exists in the execution. By suppressing (nullifying) the effect of this known corruption during execution, the crash is avoided and any remaining (hidden) corruption may then be exposed by subsequent crashes. The newly exposed corruption can then be suppressed in turn. By iterating this process until no further crashes occur, the first point of memory corruption\u2014and the likely root cause of the program failure\u2014can be identified. However, this iterative approach may terminate prematurely, since programs may not crash even when memory corruption is present during execution. To address this, we show how crashes can be exposed in an execution by manipulating the relative ordering of particular variables within memory. By revealing crashes through this variable re-ordering, the effectiveness and applicability of the execution suppression approach can be improved. We describe a set of experiments illustrating the effectiveness of our approach in consistently and precisely identifying the first points of memory corruption in executions that fail due to memory errors. We also discuss a baseline software implementation of execution suppression that incurs an average overhead of 7.2x, and describe how to reduce this overhead to 1.8x through hardware support.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Dennis Jeffrey|Vijay Nagarajan|Rajiv Gupta|Dennis Jeffrey|Vijay Nagarajan|Rajiv Gupta|", "references": "", "organization": "The University of California, Riverside, CA|The University of California, Riverside, CA|The University of California, Riverside, CA|The University of California, Riverside, CA|The University of California, Riverside, CA|The University of California, Riverside, CA|", "title": ["Execution suppression: An automated iterative technique for locating memory errors"]},
{"abstract": "We put a preexisting definitional abstract machine for dynamic delimited continuations in defunctionalized form, and we present the consequences of this adjustment. We first prove the correctness of the adjusted abstract machine. Because it is in defunctionalized form, we can refunctionalize it into a higher-order evaluation function. This evaluation function, which is compositional, is in continuation+state-passing style and threads a trail of delimited continuations and a meta-continuation. Since this style accounts for dynamic delimited continuations, we refer to it as \u201cdynamic continuation-passing style\u201d and we present the corresponding dynamic CPS transformation. We show that the notion of computation induced by dynamic CPS takes the form of a continuation monad with a recursive answer type. This continuation monad suggests a new simulation of dynamic delimited continuations in terms of static ones. Finally, we present new applications of dynamic delimited continuations, including a meta-circular evaluator. The significance of the present work is that the computational artifacts surrounding dynamic CPS are not independent designs: they are mechanical consequences of having put the definitional abstract machine in defunctionalized form.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Dariusz Biernacki|Olivier Danvy|Kevin Millikin|Dariusz Biernacki|Olivier Danvy|Kevin Millikin|", "references": "", "organization": "University of Wroc\u0142aw, Wroc\u0142aw, Poland|Aarhus University, Aarhus N, Denmark|Google, Aarhus N, Denmark|University of Wroc\u0142aw, Wroc\u0142aw, Poland|Aarhus University, Aarhus N, Denmark|Google, Aarhus N, Denmark|", "title": ["A Dynamic Continuation-Passing Style for Dynamic Delimited Continuations"]},
{"abstract": "Current parallelizing compilers can tackle applications exercising regular access patterns on arrays or affine indices, where data dependencies can be expressed in a linear form. Unfortunately, there are cases that independence between statements of code cannot be guaranteed and thus the compiler conservatively produces sequential code. Programs that involve extensive pointer use, irregular access patterns, and loops with unknown number of iterations are examples of such cases. This limits the extraction of parallelism in cases where dependencies are rarely or never triggered at runtime. Speculative parallelism refers to methods employed during program execution that aim to produce a valid parallel execution schedule for programs immune to static parallelization. The motivation for this article is to review recent developments in the area of compiler-driven software speculation for thread-level parallelism and how they came about. The article is divided into two parts. In the first part the fundamentals of speculative parallelization for thread-level parallelism are explained along with a design choice categorization for implementing such systems. Design choices include the ways speculative data is handled, how data dependence violations are detected and resolved, how the correct data are made visible to other threads, or how speculative threads are scheduled. The second part is structured around those design choices providing the advances and trends in the literature with reference to key developments in the area. Although the focus of the article is in software speculative parallelization, a section is dedicated for providing the interested reader with pointers and references for exploring similar topics such as hardware thread-level speculation, transactional memory, and automatic parallelization.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Paraskevas Yiapanis|Gavin Brown|Mikel Luj\u00e1n|Paraskevas Yiapanis|Gavin Brown|Mikel Luj\u00e1n|", "references": "David I. August, Daniel A. Connors, Scott A. Mahlke, John W. Sias, Kevin M. Crozier, Ben-Chung Cheng, Patrick R. Eaton, Qudus B. Olaniran, and Wen mei W. Hwu. 1998. Integrated predicated and speculative execution in the IMPACT EPIC architecture. In Proceedings of the International Symposium on Computer Architecture (ISCA), 227--237.  |David F. Bacon, Susan L. Graham, and Oliver J. Sharp. 1994. Compiler transformations for high-performance computing. Computing Surveys 26, 4 (1994), 345--420.  |Hans-J. Boehm. 1996. Simple garbage-collector-safety. In Proceedings of the Conference on Programming Language Design and Implementation (PLDI), 89--98.  |Matthew Bridges, Neil Vachharajani, Yun Zhang, Thomas Jablin, and David August. 2007. Revisiting the sequential programming model for multi-core. In Proceedings of the International Symposium on Microarchitecture (MICRO), 69--84.  |Matthew Bridges. 2008. The VELOCITY Compiler: Extracting Efficient Multicore Eexecution from Legacy Sequential Codes. Technical Report. Princeton University.|Derek Bruening, Srikrishna Devabhaktuni, and Saman Amarasinghe. 2000. Softspec: Software-based speculative parallelism. In Workshop on Feedback-Directed and Dynamic Optimization (FDDO).|Luis Ceze, James Tuck, Josep Torrellas, and Calin Cascaval. 2006. Bulk disambiguation of speculative threads in multiprocessors. In Proceedings of the 33rd Annual International Symposium on Computer Architecture (ISCA), 227--238.  |Ding Kai Chen, Josep Torrellas, and Pen Chung Yew. 1994. An efficient algorithm for the run-time parallelization of DOACROSS loops. In Proceedings of the International Conference on Supercomputing (ICS), 518--527. |Michael K. Chen and Kunle Olukotun. 2003. The Jrpm system for dynamically parallelizing Java programs. In Proceedings of the 30th Annual International Symposium on Computer Architecture (ISCA), 434--446.  |Marcelo Cintra and Diego Llanos. 2005. Design space exploration of a software speculative parallelization scheme. IEEE Transactions on Parallel and Distributed Systems 16, 6 (2005), 562--576.  |Marcelo Cintra and Diego R. Llanos. 2003. Toward efficient and robust software speculative parallelization on multiprocessors. In Proceedings of the 9th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP).  |Marcelo Cintra, Jos\u00e9 F. Mart\u00ednez, and Josep Torrellas. 2000. Architectural support for scalable speculative parallelization in shared-memory multiprocessors. In Proceedings of the 27th Annual International Symposium on Computer Architecture (ISCA), 13--24.  |Ron Cytron. 1986. DOACROSS: Beyond vectorization for multiprocessors. In Proceedings of the International Conference on Parallel Processing (ICPP), 836--844.|Francis Dang, Hao Yu, and Lawrence Rauchwerger. 2002. The R-LRPD test: Speculative parallelization of partially parallel loops. In Proceedings of the 16th International Parallel and Distributed Processing Symposium (IPDPS), 20--29. |Jeffrey Dean and Sanjay Ghemawat. 2004. MapReduce: Simplified data processing on large clusters. In Proceedings of Conference on Symposium on Opearting Systems Design and Implementation (OSDI). |Chen Ding, Xipeng Shen, Kirk Kelsey, Chris Tice, Ruke Huang, and Chengliang Zhang. 2007. Software behavior oriented parallelization. In Proceedings of the Conference on Programming Language Design and Implementation (PLDI), 223--234.  |Mar\u00eda Jes\u00fas Garzar\u00e1n, Milos Prvulovic, Jos\u00e9 Mar\u00eda Llaber\u00eda, V\u00edctor Vi\u00f1als, Lawrence Rauchwerger, and Josep Torrellas. 2005. Tradeoffs in buffering speculative memory state for thread-level speculation in multiprocessors. ACM Transactions in Architecture and Code Optimization 2, 3 (September 2005), 247--279.  |Sridhar Gopal, T. Vijaykumar, James Smith, and Gurindar Sohi. 1998. Speculative versioning cache. In Proceedings of the 4th International Symposium on High-Performance Computer Architecture (HPCA), 195--215. |Manish Gupta and Rahul Nim. 1998. Techniques for speculative run-time parallelization of loops. In Proceedings of the ACM/IEEE Conference on Supercomputing (SC), 1--12. |Apache Hadoop. 2005. Apache Hadoop. http://hadoop.apache.org/. (2005). Accessed February 2, 2015.|Lance Hammond, Mark Willey, and Kunle Olukotun. 1998. Data speculation support for a chip multiprocessor. In Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS). ACM, 58--69.  |Tim Harris, James Larus, and Ravi Rajwar. 2010. Transactional Memory (2nd ed.). Morgan and Claypool Publishers. |Tim Harris, Mark Plesko, Avraham Shinnar, and David Tarditi. 2006. Optimizing memory transactions. In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), 14--25.  |Maurice Herlihy and J. Eliot B. Moss. 1993. Transactional memory: Architectural support for lock-free data structures. In Proceedings of the 20th Annual International Symposium on Computer Architecture (ISCA), 289--300.  |Jason Howard, Saurabh Dighe, Yatin Hoskote, Sriram Vangal, David Finan, Gregory Ruhl, David Jenkins, Howard Wilson, Nitin Borkar, Gerhard Schrom, Fabrice Pailet, Shailendra Jain, Tiju Jacob, Satish Yada, Sraven Marella, Praveen Salihundam, Vasantha Erraguntla, Michael Konow, Michael Riepen, Guido Droege, Joerg Lindemann, Matthias Gries, Thomas Apel, Kersten Henriss, Tor Lund-Larsen, Sebastian Steibl, Shekhar Borkar, Vivek De, Rob Van Der Wijngaart, and Timothy Mattson. 2010. A 48-Core IA-32 message-passing processor with DVFS in 45nm CMOS. In Proceedings of the International Solid-State Circuits Conference Digest of Technical Papers (ISSCC), 108--109.|Shiwen Hu, Ravi Bhargava, and Lizy Kurian John. 2003. The role of return value prediction in exploiting speculative method-level parallelism. Journal of Instruction-Level Parallelsim 5 (2003), 1--21.|Nikolas Ioannou, Jeremy Singer, Salman Khan, Paraskevas Yiapanis, Adam Pocock, Polychronis Xekalakis, Gavin Brown, Mikel Luj\u00e1n, Ian Watson, and Marcelo Cintra. 2010. Toward a more accurate understanding of the limits of the TLS execution paradigm. In Proceedings of the IEEE International Symposium on Workload Characterization.  |Nick P. Johnson, Hanjun Kim, Prakash Prabhu, Ayal Zaks, and David I. August. 2012. Speculative separation for privatization and peductions. In Proceedings of the Conference on Programming Language Design and Implementation (PLDI), 359--370.  |Troy A. Johnson, Rudolf Eigenmann, and T. N. Vijaykumar. 2004. Min-cut program decomposition for thread-level speculation. In Proceedings of the International Conference on Programming Language Design and Implementation (PLDI), 59--70.  |Ken Kennedy and John R. Allen. 2002. Optimizing Compilers for Modern Architectures: A Dependence-Based Approach. Morgan Kaufmann Publishers Inc., San Francisco, CA. |Hanjun Kim, Arun Raman, Feng Liu, Jae W. Lee, and David I. August. 2010. Scalable speculative parallelization on commodity clusters. In Proceedings of the 43rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), 3--14.  |Wei Liu, James Tuck, Luis Ceze, Wonsun Ahn, Karin Strauss, Jose Renau, and Josep Torrellas. 2006. POSH: A TLS compiler that exploits program structure. In Proceedings of the International Symposium on Principles and Practice of Parallel Programming (PPoPP), 158--167.  |Mikel Luj\u00e1n, Phyllis Gustafson, Michael Paleczny, and Christopher A. Vick. 2007. Speculative parallelization\u2014Eliminating the overhead of failure. In Proceedings of the 3rd International Conference on High Performance Computing and Communications (HPCC), 460--471. |Clifford Lynch. 2008. Big data: How do your data grow? Nature 455, 7209 (2008), 28--29.|Pedro Marcuello and Antonio Gonz\u00e1lez. 1999. Exploiting speculative thread-level parallelism on a SMT processor. In Proceedings of the International Conference on High-Performance Computing and Networking, 754--763. |Pedro Marcuello and Antonio Gonz\u00e1lez. 2002. Thread-spawning schemes for speculative multithreading. In Proceedings of the 8th International Symposium on High-Performance Computer Architecture (HPCA), 55--67. |Jan Kasper Martinsen and Hakan Grahn. 2011. A methodology for evaluating JavaScript execution behavior in interactive web applications. In Computer Systems and Applications (AICCSA). 241--248.  |Jan Martinsen, Hakan Grahn, and Anders Isberg. 2013. Using speculation to enhance javaScript performance in Web applications. IEEE Internet Computing 17, 2 (2013), 10--19.  |Mojtaba Mehrara, Jeff Hao, Po-Chun Hsu, and Scott Mahlke. 2009. Parallelizing sequential applications on commodity hardware using a low-cost software transactional memory. In Proceedings of the ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI), 166--176.  |Samuel P. Midkiff. 2012. Automatic Parallelization: An Overview of Fundamental Compiler Techniques. Morgan & Claypool Publishers. |Erik M. Nystrom, Hong-Seok Kim, and Wen-Mei W. Hwu. 2004. Bottom-up and top-down context-sensitive summary-based pointer analysis. In Proceedings of 11th Static Analysis Symposium (SAS), 165--180.|Cosmin Oancea, Alan Mycroft, and Tim Harris. 2009. A lightweight in-place implementation for software thread-level speculation. In Proceedings of the 21st Annual Symposium on Parallelism in Algorithms and Architectures (SPAA), 223--232.  |Jeffrey Oplinger, David Heine, Shih Liao, Basem A. Nayfeh, Monica S. Lam, and Kunle Olukotun. 1997. Software and Hardware for Exploiting Speculative Parallelism with a Multiprocessor. Technical Report CSL-TR-97-715. Stanford University. |Guilherme Ottoni, Ram Rangan, Adam Stoler, and David I. August. 2005a. Automatic thread extraction with decoupled software pipelining. In Proceedings of the 38th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), 105--118.  |Guilherme Ottoni, Ram Rangan, Adam Stoler, and David I. August. 2005b. Automatic thread extraction with decoupled Software Pipelining. In Proceedings of International Symposium on Microarchitecture (MICRO), 105--118.  |Christopher J. F. Pickett and Clark Verbrugge. 2006. Software thread level speculation for the Java language and virtual machine environment. In Proceedings of the International Conference on Languages and Compilers for Parallel Computing (LCPC), 304--318.  |Manohar K. Prabhu and Kunle Olukotun. 2005. Exposing speculative thread parallelism in SPEC2000. In Proceedings of the Symposium on Principles and Practice of Parallel Programming (PPoPP), 142--152.  |Arun Raman, Hanjun Kim, Thomas R. Mason, Thomas B. Jablin, and David I. August. 2010. Speculative parallelization using software multi-threaded transactions. In Proceedings of Architectural Support for Programming Languages and Operating Systems, 65--76.  |Easwaran Raman, Guilherme Ottoni, Arun Raman, Matthew J. Bridges, and David I. August. 2008. Parallel-stage decoupled software pipelining. In Proceedings of the 6th Annual IEEE/ACM International Symposium on Code Generation and Optimization, 114--123.  |Ram Rangan, Neil Vachharajani, Guilherme Ottoni, and David I. August. 2008. Performance scalability of decoupled software pipelining. ACM Transactions on Architecture and Code Optimization 5, 2, Article 8 (2008), 8:1--8:25 pages.  |Ram Rangan, Neil Vachharajani, Manish Vachharajani, and David I. August. 2004. Decoupled software pipelining with the synchronization array. In Proceedings of the International Conference on Parallel Architectures and Compilation Techniques (PACT), 177--188.  |Paruj Ratanaworabhan, Benjamin Livshits, and Benjamin G. Zorn. 2010. JSMeter: Comparing the behavior of JavaScript benchmarks with real Web applications. In Proceedings of the 2010 USENIX Conference on Web Application Development (WebApps). |Lawrence Rauchwerger. 1998. Run-time parallelization: Its time has come. Parallel Computing 24, 3--4 (1998), 527--556.  |Lawrence Rauchwerger and David Padua. 1994a. Speculative Run-Time Parallelization of Loops. Technical Report CSRD-827. Center for Supercomputing Research and Development, University of Illinois.|Lawrence Rauchwerger and David Padua. 1994b. The privatizing DOALL test: A run-time technique for DOALL loop identification and array privatization. In Proceedings of the 8th International Conference on Supercomputing (ICS), 33--43.  |Lawrence Rauchwerger and David Padua. 1995. The LRPD test: Speculative run-time parallelization of loops with privatization and reduction parallelization. In Proceedings of the International Conference on Programming Language Design and Implementation (PLDI), 218--232.  |Jose Renau, Karin Strauss, Luis Ceze, Wei Liu, Smruti Sarangi, James Tuck, and Josep Torrellas. 2005a. Thread-level speculation on a CMP can be energy efficient. In Proceedings of the International Conference on Supercomputing, 219--228.  |Jose Renau, James Tuck, Wei Liu, Luis Ceze, Karin Strauss, and Josep Torrellas. 2005b. Tasking with out-of-order spawn in TLS chip multiprocessors: Microarchitecture and compilation. In Proceedings of the Internatonal Conference on Supercomputing, 179--188.  |Gregor Richards, Sylvain Lebresne, Brian Burg, and Jan Vitek. 2010. An analysis of the dynamic behavior of JavaScript programs. In Proceedings of the International Conference on Programming Language Design and Implementation (PLDI), 1--12.  |Peter Rundberg and Per Stenstr\u00f6m. 2001. An all-software thread-level data dependence speculation system for multiprocessors. Journal of Instruction-Level Parallelism 3 (2001), 1--28.|Bratin Saha, Ali-Reza Adl-Tabatabai, Richard L. Hudson, Chi Cao Minh, and Benjamin Hertzberg. 2006. McRT-STM: A high performance software transactional memory system for a multi-core runtime. In Proceedings of the 11th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), 187--197.  |Joel H. Salz and Ravi Mirchandaney. 1991. The preprocessed doacross loop. In Proceedings of ICPP, 174--178.|Joel H. Salz, Ravi Mirchandaney, and Kay Crowley. 1989. The doconsider loop. In Proceedings of ICS. 29--40.  |Joel H. Salz, Ravi Mirchandaney, and Kay Crowley. 1991. Run-time parallelization and scheduling of loops. IEEE Transactions on Computers 40, 5 (1991), 603--612.  |Michael F. Spear. 2010. Lightweight, robust adaptivity for software transactional memory. In Proceedings of the 22nd ACM Symposium on Parallelism in Algorithms and Architectures (SPAA), 273--283.  |Michael F. Spear, Virendra J. Marathe, William N. Scherer, and Michael L. Scott. 2006. Conflict detection and validation strategies for software transactional memory. In Proceedings of the International Conference on Distributed Computing (DISC), 179--193.  |Gregory Steffan. 2003. Hardware Support for Thread-Level Speculation. Doctoral dissertation. Carnegie Mellon University Pittsburgh, PA. |Gregory Steffan, Christopher Colohan, Antonia Zhai, and Todd C. Mowry. 2005. The STAMPede approach to thread-level speculation. ACM Transactions on Computer Systems 23, 3 (2005), 253--300.  |Gregory Steffan, Christopher B. Colohan, Antonia Zhai, and Todd C. Mowry. 2000. A scalable approach to thread-level speculation. In Proceedings of the International Symposium on Computer Architecture (ISCA), 1--12.  |Peiyi Tang and Pen-Chung Yew. 1986. Processor self-scheduling for multiple nested parallel loops. In Proceedings of the International Conference of Parallel Processing, 528--535.|William Thies, Vikram Chandrasekhar, and Saman Amarasinghe. 2007. A practical approach to exploiting coarse-grained pipeline parallelism in C programs. In Proceedings of the International Symposium on Microarchitecture (MICRO), 356--369.  |Chen Tian, Min Feng, and Rajiv Gupta. 2010. Supporting speculative parallelization in the presence of dynamic data structures. In Proceedings of the International Conference on Programming Language Design and Implementation (PLDI), 62--73.  |Chen Tian, Min Feng, Vijay Nagarajan, and Rajiv Gupta. 2008. Copy or discard execution model for speculative parallelization on multicores. In Proceedings of the 41st Annual International Symposium on Microarchitecture (MICRO), 330--341.  |Neil Vachharajani, Ram Rangan, Easwaran Raman, Matthew J. Bridges, Guilherme Ottoni, and David I. August. 2007. Speculative decoupled software pipelining. In Proceedings of the International Conference on Parallel Architecture and Compilation Techniques (PACT), 49--59.  |Amy Wang, Matthew Gaudet, Peng Wu, Jose Amaral, Martin Ohmacht, Christopher Barton, Raul Silvera, and Maged Michael. 2012. Evaluation of blue gene/q hardware support for transactional memories. In Proceedings of the International Conference on Parallel Architecture and Compilation Techniques (PACT), 127--136.  |Paraskevas Yiapanis. 2013. High Performance Optimizations in Runtime Speculative Parallelization for Multicore Architectures. Ph.D. dissertation. School of Computer Science, University of Manchester.|Paraskevas Yiapanis, Demian Rosas-Ham, Gavin Brown, and Mikel Luj\u00e1n. 2013. Optimizing software runtime systems for speculative parallelization. ACM Transactions on Architecture and Code Optimization 9, 4, Article 39 (2013), 39:1--39:27.  |Chenggang Zhang, Guodong Han, and Cho-Li Wang. 2013. GPU-TLS: An efficient runtime for speculative loop parallelization on GPUs. In Proceedings of the International Symposium on Cluster, Cloud, and Grid Computing (CCGRID). 120--127.|Hongtao Zhong, Mojtaba Mehrara, Steven A. Lieberman, and Scott A. Mahlke. 2008. Uncovering hidden loop level parallelism in sequential applications. In Proceedings of the International Conference on High-Performance Computer Architecture (HPCA), 290--301.|Chuan-Qi Zhu and Pen-Chung Yew. 1987. A scheme to enforce data dependence on large multiprocessor systems. IEEE Transactions on Software Engineering 13, 6 (1987), 726--739.  |", "organization": "University of Manchester, Oxford Road|University of Manchester, Oxford Road|University of Manchester, Oxford Road|University of Manchester, Oxford Road|University of Manchester, Oxford Road|University of Manchester, Oxford Road|", "title": ["Compiler-Driven Software Speculation for Thread-Level Parallelism"]},
{"abstract": "Synchronization constructs lie at the heart of any reliable concurrent program. Many such constructs are standard (e.g., locks, queues, stacks, and hash-tables). However, many concurrent applications require custom synchronization constructs with special-purpose behavior. These constructs present a significant challenge for verification. Like standard constructs, they rely on subtle racy behavior, but unlike standard constructs, they may not have well-understood abstract interfaces. As they are custom built, such constructs are also far more likely to be unreliable.\nThis article examines the formal specification and verification of custom synchronization constructs. Our target is a library of channels used in automated parallelization to enforce sequential behavior between program statements. Our high-level specification captures the conditions necessary for correct execution; these conditions reflect program dependencies necessary to ensure sequential behavior. We connect the high-level specification with the low-level library implementation to prove that a client\u2019s requirements are satisfied. Significantly, we can reason about program and library correctness without breaking abstraction boundaries.\nTo achieve this, we use a program logic called iCAP (impredicative Concurrent Abstract Predicates) based on separation logic. iCAP supports both high-level abstraction and low-level reasoning about races. We use this to show that our high-level channel specification abstracts three different, increasingly complex low-level implementations of the library. iCAP\u2019s support for higher-order reasoning lets us prove that sequential dependencies are respected, while iCAP\u2019s next-generation semantic model lets us avoid ugly problems with cyclic dependencies.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mike Dodds|Suresh Jagannathan|Matthew J. Parkinson|Kasper Svendsen|Lars Birkedal|Mike Dodds|Suresh Jagannathan|Matthew J. Parkinson|Kasper Svendsen|Lars Birkedal|", "references": "", "organization": "University of York, York, UK|Purdue University, Indiana, USA|Microsoft Research, Cambridge, UK|Aarhus University, Aarhus, Denmark|Aarhus University, Aarhus, Denmark|University of York, York, UK|Purdue University, Indiana, USA|Microsoft Research, Cambridge, UK|Aarhus University, Aarhus, Denmark|Aarhus University, Aarhus, Denmark|", "title": ["Verifying Custom Synchronization Constructs Using Higher-Order Separation Logic"]},
{"abstract": "We consider a type algebra equipped with recursive, product, function, intersection, union, and complement types, together with type variables. We consider the subtyping relation defined by Castagna and Xu [2011] over such type expressions and show how this relation can be decided in EXPTIME, answering an open question. The novelty, originality and strength of our solution reside in introducing a logical modeling for the semantic subtyping framework. We model semantic subtyping in a tree logic and use a satisfiability-testing algorithm in order to decide subtyping. We report on practical experiments made with a full implementation of the system. This provides a powerful polymorphic type system aiming at maintaining full static type-safety of functional programs that manipulate trees, even with higher-order functions, which is particularly useful in the context of XML.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Nils Gesbert|Pierre Genev\u00e8s|Nabil Laya\u00efda|Nils Gesbert|Pierre Genev\u00e8s|Nabil Laya\u00efda|", "references": "", "organization": "Grenoble INP -- Ensimag|CNRS|Inria|Grenoble INP -- Ensimag|CNRS|Inria|", "title": ["A Logical Approach to Deciding Semantic Subtyping"]},
{"abstract": "Tracing just-in-time compilation is a popular compilation technique for the efficient implementation of dynamic languages, which is commonly used for JavaScript, Python, and PHP. It relies on two key ideas. First, it monitors program execution in order to detect so-called hot paths, that is, the most frequently executed program paths. Then, hot paths are optimized by exploiting some information on program stores that is available and therefore gathered at runtime. The result is a residual program where the optimized hot paths are guarded by sufficient conditions ensuring some form of equivalence with the original program. The residual program is persistently mutated during its execution, for example, to add new optimized hot paths or to merge existing paths. Tracing compilation is thus fundamentally different from traditional static compilation. Nevertheless, despite the practical success of tracing compilation, very little is known about its theoretical foundations. We provide a formal model of tracing compilation of programs using abstract interpretation. The monitoring phase (viz., hot path detection) corresponds to an abstraction of the trace semantics of the program that captures the most frequent occurrences of sequences of program points together with an abstraction of their corresponding stores, for example, a type environment. The optimization phase (viz., residual program generation) corresponds to a transform of the original program that preserves its trace semantics up to a given observation as modeled by some abstraction. We provide a generic framework to express dynamic optimizations along hot paths and to prove them correct. We instantiate it to prove the correctness of dynamic type specialization and constant variable folding. We show that our framework is more general than the model of tracing compilation introduced by Guo and Palsberg [2011], which is based on operational bisimulations. In our model, we can naturally express hot path reentrance and common optimizations like dead-store elimination, which are either excluded or unsound in Guo and Palsberg\u2019s framework.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Stefano Dissegna|Francesco Logozzo|Francesco Ranzato|Stefano Dissegna|Francesco Logozzo|Francesco Ranzato|", "references": "", "organization": "University of Padova, Padova, Italy|Facebook Inc., WA, USA|University of Padova, Padova, Italy|University of Padova, Padova, Italy|Facebook Inc., WA, USA|University of Padova, Padova, Italy|", "title": ["An Abstract Interpretation-Based Model of Tracing Just-in-Time Compilation"]},
{"abstract": "Reasoning about multithreaded object-oriented programs is difficult, due to the nonlocal nature of object aliasing and data races. We propose a programming regime (or \n) that rules out data races, and enables local reasoning in the presence of object aliasing and concurrency. Our programming model builds on the multithreading and synchronization primitives as they are present in current mainstream programming languages. Java or C# programs developed according to our model can be annotated by means of stylized comments to make the use of the model explicit. We show that such annotated programs can be formally verified to comply with the programming model. If the annotated program verifies, the underlying Java or C# program is guaranteed to be free from data races, and it is sound to reason locally about program behavior. Verification is modular: a program is valid if all methods are valid, and validity of a method does not depend on program elements that are not visible to the method. We have implemented a verifier for programs developed according to our model in a custom build of the Spec# programming system, and we have validated our approach on a case study.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bart Jacobs|Frank Piessens|Jan Smans|K. Rustan M. Leino|Wolfram Schulte|Bart Jacobs|Frank Piessens|Jan Smans|K. Rustan M. Leino|Wolfram Schulte|", "references": "", "organization": "Katholieke Universiteit Leuven|Katholieke Universiteit Leuven|Katholieke Universiteit Leuven|Microsoft Research|Microsoft Research|Katholieke Universiteit Leuven|Katholieke Universiteit Leuven|Katholieke Universiteit Leuven|Microsoft Research|Microsoft Research|", "title": ["A programming model for concurrent object-oriented programs"]},
{"abstract": "The web browser is the \u201cnew desktop.\u201d Not only do many users spend most of their time using the browser, the browser has also become host to rich and dynamic applications that were previously tailored to each individual operating system. The lingua franca of web scripting, JavaScript, was pivotal in this development.\nImagine that all desktop applications allocated memory from a single heap managed by the operating system. To reclaim memory upon application shutdown, all processes would then be garbage collected\u2014not just the one being quit. While operating systems improved upon this approach long ago, this was how browsers managed memory until recently.\nThis article explores \n memory management, an approach tailored specifically to web browsers. The idea is to partition the JavaScript heap into compartments and allocate objects to compartments based on their origin. All objects in the same compartment reference each other direct, whereas cross-origin references go through wrapper objects.\nWe carefully evaluate our techniques using Mozilla\u2019s Firefox browser\u2014which now ships with our enhancements\u2014and demonstrate the benefits of collecting each compartment independently. This simultaneously improves runtime performance (up to 36%) and reduces garbage collection pause times (up to 75%) as well as the memory footprint of the browser. In addition, enforcing the same-origin security policy becomes simple and efficient with compartments.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gregor Wagner|Per Larsen|Stefan Brunthaler|Michael Franz|Gregor Wagner|Per Larsen|Stefan Brunthaler|Michael Franz|", "references": "", "organization": "Mozilla Corporation, Berlin, Germany|University of California, Irvine, Irvine, CA|University of California, Irvine, Irvine, CA|University of California, Irvine, Irvine, CA|Mozilla Corporation, Berlin, Germany|University of California, Irvine, Irvine, CA|University of California, Irvine, Irvine, CA|University of California, Irvine, Irvine, CA|", "title": ["Thinking Inside the Box: Compartmentalized Garbage Collection"]},
{"abstract": "Efficient memory allocation is crucial for data-intensive applications, as a smaller memory footprint ensures better cache performance and allows one to run a larger problem size given a fixed amount of main memory. In this article, we describe a new automatic storage optimization technique to minimize the dimensionality and storage requirements of arrays used in sequences of loop nests with a predetermined schedule. We formulate the problem of intra-array storage optimization as one of finding the right storage partitioning hyperplanes: each storage partition corresponds to a single storage location. Our heuristic is driven by a dual-objective function that minimizes both the dimensionality of the mapping and the extents along those dimensions. The technique is dimension optimal for most codes encountered in practice. The storage requirements of the mappings obtained also are asymptotically better than those obtained by any existing schedule-dependent technique. Storage reduction factors and other results that we report from an implementation of our technique demonstrate its effectiveness on several real-world examples drawn from the domains of image processing, stencil computations, high-performance computing, and the class of tiled codes in general.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Somashekaracharya G. Bhaskaracharya|Uday Bondhugula|Albert Cohen|Somashekaracharya G. Bhaskaracharya|Uday Bondhugula|Albert Cohen|", "references": "", "organization": "Indian Institute of Science, Bangalore, India|Indian Institute of Science, Bangalore, India|INRIA, Paris, France|Indian Institute of Science, Bangalore, India|Indian Institute of Science, Bangalore, India|INRIA, Paris, France|", "title": ["Automatic Storage Optimization for Arrays"]},
{"abstract": "This article presents a model and implementation techniques for speeding up constraint propagation. Three fundamental approaches to improving constraint propagation based on propagators as implementations of constraints are explored: keeping track of which propagators are at fixpoint, choosing which propagator to apply next, and how to combine several propagators for the same constraint.\nWe show how idempotence reasoning and events help track fixpoints more accurately. We improve these methods by using them dynamically (taking into account current variable domains to improve accuracy). We define priority-based approaches to choosing a next propagator and show that dynamic priorities can improve propagation. We illustrate that the use of multiple propagators for the same constraint can be advantageous with priorities, and introduce staged propagators that combine the effects of multiple propagators with priorities for greater efficiency.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Christian Schulte|Peter J. Stuckey|Christian Schulte|Peter J. Stuckey|", "references": "", "organization": "KTH - Royal Institute of Technology, Kista, Sweden|NICTA Victoria Laboratory, University of Melbourne, Australia|KTH - Royal Institute of Technology, Kista, Sweden|NICTA Victoria Laboratory, University of Melbourne, Australia|", "title": ["Efficient constraint propagation engines"]},
{"abstract": "As probabilistic computations play an increasing role in solving various problems, researchers have designed probabilistic languages which treat probability distributions as primitive datatypes. Most probabilistic languages, however, focus only on discrete distributions and have limited expressive power. This article presents a probabilistic language, called \u03bb\n, whose expressive power is beyond discrete distributions. Rich expressiveness of \u03bb\n is due to its use of \n, that is, mappings from the unit interval (0.0,1.0] to probability domains, in specifying probability distributions. As such, \u03bb\n enables programmers to formally express and reason about sampling methods developed in simulation theory. The use of \u03bb\n is demonstrated with three applications in robotics: robot localization, people tracking, and robotic mapping. All experiments have been carried out with real robots.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sungwoo Park|Frank Pfenning|Sebastian Thrun|Sungwoo Park|Frank Pfenning|Sebastian Thrun|", "references": "", "organization": "Pohang University of Science and Technology|Carnegie Mellon University|Stanford University|Pohang University of Science and Technology|Carnegie Mellon University|Stanford University|", "title": ["A probabilistic language based on sampling functions"]},
{"abstract": "This article advocates the revival of coroutines as a convenient general control abstraction. After proposing a new classification of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise definition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and one-shot delimited continuations. We also show that full asymmetric coroutines and one-shot delimited continuations have many similarities, and therefore present comparable benefits. Nevertheless, coroutines are easier implemented and understood, especially in the realm of procedural languages.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Ana L\u00facia De Moura|Roberto Ierusalimschy|Ana L\u00facia De Moura|Roberto Ierusalimschy|", "references": "", "organization": "Catholic University of Rio de Janeiro (PUC--Rio), Rio de Janeiro, RJ|Catholic University of Rio de Janeiro (PUC--Rio), Rio de Janeiro, RJ|Catholic University of Rio de Janeiro (PUC--Rio), Rio de Janeiro, RJ|Catholic University of Rio de Janeiro (PUC--Rio), Rio de Janeiro, RJ|", "title": ["Revisiting coroutines"]},
{"abstract": "We present a method for selectively applying context-sensitivity during interprocedural program analysis. Our method applies context-sensitivity only when and where doing so is likely to improve the precision that matters for resolving given queries. The idea is to use a pre-analysis to estimate the impact of context-sensitivity on the main analysis\u2019s precision, and to use this information to find out when and where the main analysis should turn on or off its context-sensitivity. We formalize this approach and prove that the analysis always benefits from the pre-analysis--guided context-sensitivity. We implemented this selective method for an existing industrial-strength interval analyzer for full C. The method reduced the number of (false) alarms by 24.4% while increasing the analysis cost by 27.8% on average.\nThe use of the selective method is not limited to context-sensitivity. We demonstrate this generality by following the same principle and developing a selective relational analysis and a selective flow-sensitive analysis. Our experiments show that the method cost-effectively improves the precision in the these analyses as well.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Hakjoo Oh|Wonchan Lee|Kihong Heo|Hongseok Yang|Kwangkeun Yi|Hakjoo Oh|Wonchan Lee|Kihong Heo|Hongseok Yang|Kwangkeun Yi|", "references": "", "organization": "Korea University, Seoul, Korea|Stanford University, Stanford, California|Seoul National University, Seoul, Korea|University of Oxford, Oxford, UK|Seoul National University, Seoul, Korea|Korea University, Seoul, Korea|Stanford University, Stanford, California|Seoul National University, Seoul, Korea|University of Oxford, Oxford, UK|Seoul National University, Seoul, Korea|", "title": ["Selective X-Sensitive Analysis Guided by Impact Pre-Analysis"]},
{"abstract": "Bytecode verification is a key point in the security chain of the Java platform. This feature is only optional in many embedded devices since the memory requirements of the verification process are too high. In this article we propose an approach that significantly reduces the use of memory by a serial/parallel decomposition of the verification into multiple specialized passes. The algorithm reduces the type encoding space by operating on different abstractions of the domain of types. The results of our evaluation show that this bytecode verification can be performed directly on small memory systems. The method is formalized in the framework of abstract interpretation.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "C. Bernardeschi|N. De Francesco|G. Lettieri|L. Martini|P. Masci|C. Bernardeschi|N. De Francesco|G. Lettieri|L. Martini|P. Masci|", "references": "", "organization": "Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|", "title": ["Decomposing bytecode verification by abstract interpretation"]},
{"abstract": "We present an architecture and tools for verifying implementations of security protocols. Our implementations can run with both concrete and symbolic implementations of cryptographic algorithms. The concrete implementation is for production and interoperability testing. The symbolic implementation is for debugging and formal verification. We develop our approach for protocols written in F#, a dialect of ML, and verify them by compilation to ProVerif, a resolution-based theorem prover for cryptographic protocols. We establish the correctness of this compilation scheme, and we illustrate our approach with protocols for Web Services security.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|Stephen Tse|Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|Stephen Tse|", "references": "", "organization": "Microsoft Research|Microsoft Research|Microsoft Research|University of Pennsylvania|Microsoft Research|Microsoft Research|Microsoft Research|University of Pennsylvania|", "title": ["Verified interoperable implementations of security protocols"]},
{"abstract": " is an object-oriented (OO) language mechanism for determining the method implementation to be invoked upon a message send. With predicate dispatch, each method implementation includes a predicate guard specifying the conditions under which the method should be invoked, and logical implication of predicates determines the method overriding relation. Predicate dispatch naturally unifies and generalizes several common forms of dynamic dispatch, including traditional OO dispatch, multimethod dispatch, and functional-style pattern matching. Unfortunately, prior languages supporting predicate dispatch have had several deficiencies that limit the practical utility of this language feature.\nWe describe JPred, a backward-compatible extension to Java supporting predicate dispatch. While prior languages with predicate dispatch have been extensions to toy or nonmainstream languages, we show how predicate dispatch can be naturally added to a traditional OO language. While prior languages with predicate dispatch have required the whole program to be available for typechecking and compilation, JPred retains Java's modular typechecking and compilation strategies. While prior languages with predicate dispatch have included special-purpose algorithms for reasoning about predicates, JPred employs general-purpose, off-the-shelf decision procedures. As a result, JPred's type system is more flexible, allowing several useful programming idioms that are spuriously rejected by those other languages. After describing the JPred language informally, we present an extension to Featherweight Java that formalizes the language and its modular type system, which we have proven sound. Finally, we discuss two case studies that illustrate the practical utility of JPred, including its use in the detection of several errors.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Todd Millstein|Christopher Frost|Jason Ryder|Alessandro Warth|Todd Millstein|Christopher Frost|Jason Ryder|Alessandro Warth|", "references": "", "organization": "University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|", "title": ["Expressive and modular predicate dispatch for Java"]},
{"abstract": "Constraint Handling Rules (CHR) is a high-level rule-based programming language which is increasingly used for general-purpose programming. We introduce the CHR machine, a model of computation based on the operational semantics of CHR. Its computational power and time complexity properties are compared to those of the well-understood Turing machine and Random Access Memory machine. This allows us to prove the interesting result that every algorithm can be implemented in CHR with the best known time and space complexity. We also investigate the practical relevance of this result and the constant factors involved. Finally we expand the scope of the discussion to other (declarative) programming languages.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jon Sneyers|Tom Schrijvers|Bart Demoen|Jon Sneyers|Tom Schrijvers|Bart Demoen|", "references": "", "organization": "K.U.Leuven, Heverlee, Belgium|K.U.Leuven, Heverlee, Belgium|K.U.Leuven, Heverlee, Belgium|K.U.Leuven, Heverlee, Belgium|K.U.Leuven, Heverlee, Belgium|K.U.Leuven, Heverlee, Belgium|", "title": ["The computational power and complexity of constraint handling rules"]},
{"abstract": "No abstract available.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Christian Schulte|Peter J. Stuckey|Christian Schulte|Peter J. Stuckey|", "references": "", "organization": "", "title": ["Erratum to: Efficient constraint propagation engines"]},
{"abstract": "In the design phase of software development, the designer must make many fundamental design decisions concerning the architecture of the system. Incorrect decisions are relatively easy and inexpensive to fix if caught during the design process, but the difficulty and cost rise significantly if problems are not found until after coding begins. Unfortunately, it is not always possible to find incorrect design decisions during the design phase. To reduce the cost of expensive corrections, it would be useful to have the ability to defer some design decisions as long as possible, even into the coding stage. Failing that, tool support for automating design changes would give more freedom to revisit and change these decisions when needed. This article shows how a design-pattern-based programming system based on \n can support the deferral of design decisions where possible, and automate changes where necessary. A generative design pattern is a parameterized pattern form that is capable of generating code for different versions of the underlying design pattern. We demonstrate these ideas in the context of a parallel application written with the CO\nP\nS pattern-based parallel programming system. We show that CO\nP\nS can defer the choice of execution architecture (shared-memory or distributed-memory), and can automate several changes to the application structure that would normally be daunting to tackle late in the development cycle. Although we have done this work with a pattern-based parallel programming system, it can be generalized to other domains.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Steve MacDonald|Kai Tan|Jonathan Schaeffer|Duane Szafron|Steve MacDonald|Kai Tan|Jonathan Schaeffer|Duane Szafron|", "references": "", "organization": "University of Waterloo, ON, Canada|University of Alberta, Edmonton, AL, Canada|University of Alberta, Edmonton, AL, Canada|University of Alberta, Edmonton, AL, Canada|University of Waterloo, ON, Canada|University of Alberta, Edmonton, AL, Canada|University of Alberta, Edmonton, AL, Canada|University of Alberta, Edmonton, AL, Canada|", "title": ["Deferring design pattern decisions and automating structural pattern changes using a design-pattern-based programming system"]},
{"abstract": "We investigate proof rules for information hiding, using the formalism of separation logic. In essence, we use the separating conjunction to partition the internal resources of a module from those accessed by the module's clients. The use of a logical connective gives rise to a form of dynamic partitioning, where we track the transfer of ownership of portions of heap storage between program components. It also enables us to enforce separation in the presence of mutable data structures with embedded addresses that may be aliased.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Peter W. O'Hearn|Hongseok Yang|John C. Reynolds|Peter W. O'Hearn|Hongseok Yang|John C. Reynolds|", "references": "", "organization": "Queen Mary, University of London|Queen Mary, University of London|Carnegie Mellon University|Queen Mary, University of London|Queen Mary, University of London|Carnegie Mellon University|", "title": ["Separation and information hiding"]},
{"abstract": "Interoperability is big business, a fact to which .NET, the JVM, and COM can attest. Language designers are well aware of this, and they are designing programming languages that reflect it\u2014for instance, SML.NET, F#, Mondrian, and Scala all treat interoperability as a central design feature. Still, current multi-language research tends not to focus on the semantics of these features, but only on how to implement them efficiently. In this article, we attempt to rectify that by giving a technique for specifying the operational semantics of a multi-language system as a composition of the models of its constituent languages. Our technique abstracts away the low-level details of interoperability like garbage collection and representation coherence, and lets us focus on semantic properties like type-safety, equivalence, and termination behavior. In doing so it allows us to adapt standard theoretical techniques such as subject-reduction, logical relations, and operational equivalence for use on multi-language systems. Generally speaking, our proofs of properties in a multi-language context are mutually referential versions of their single language counterparts.\nWe demonstrate our technique with a series of strategies for embedding a Scheme-like language into an ML-like language. We start by connecting very simple languages with a very simple strategy, and work our way up to languages that interact in sophisticated ways and have sophisticated features such as polymorphism and effects. Along the way, we prove relevant results such as type-soundness and termination for each system we present using adaptations of standard techniques.\nBeyond giving simple expressive models, our studies have uncovered several interesting facts about interoperability. For example, higher-order function contracts naturally emerge as the glue to ensure that interoperating languages respect each other's type systems. Our models also predict that the embedding strategy where foreign values are opaque is as expressive as the embedding strategy where foreign values are translated to corresponding values in the other language, and we were able to experimentally verify this behavior using PLT Scheme's foreign function interface.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jacob Matthews|Robert Bruce Findler|Jacob Matthews|Robert Bruce Findler|", "references": "", "organization": "University of Chicago|University of Chicago|University of Chicago|University of Chicago|", "title": ["Operational semantics for multi-language programs"]},
{"abstract": "We propose a sequent calculus derived from the \u03bb\u2015\u03bc\u03bc\u02dc-calculus of Curien and Herbelin that is expressive enough to directly represent the fine details of program evaluation using typical abstract machines. Not only does the calculus easily encode the usual components of abstract machines such as environments and stacks, but it can also simulate the transition steps of the abstract machine with just a constant overhead. Technically this is achieved by ensuring that reduction in the calculus always happens at a bounded depth from the root of the term. We illustrate these properties by providing \n of the Krivine (call-by-name) and the CEK (call-by-value) abstract machines in the calculus.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Zena M. Ariola|Aaron Bohannon|Amr Sabry|Zena M. Ariola|Aaron Bohannon|Amr Sabry|", "references": "", "organization": "University of Oregon, Eugene, OR|University of Pennsylvania, Philadelphia, PA|Indiana University, Bloomington, IN|University of Oregon, Eugene, OR|University of Pennsylvania, Philadelphia, PA|Indiana University, Bloomington, IN|", "title": ["Sequent calculi and abstract machines"]},
{"abstract": "The origins of bisimulation and bisimilarity are examined, in the three fields where they have been independently discovered: Computer Science, Philosophical Logic (precisely, Modal Logic), Set Theory.\nBisimulation and bisimilarity are coinductive notions, and as such are intimately related to fixed points, in particular greatest fixed points. Therefore also the appearance of coinduction and fixed points is discussed, though in this case only within Computer Science. The paper ends with some historical remarks on the main fixed-point theorems (such as Knaster-Tarski) that underpin the fixed-point theory presented.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Davide Sangiorgi|Davide Sangiorgi|", "references": "", "organization": "University of Bologna, Bologna, Italy|University of Bologna, Bologna, Italy|", "title": ["On the origins of bisimulation and coinduction"]},
{"abstract": "This article describes an approach to program optimization based on transformations, where temporal logic is used to specify side conditions, and strategies are created which expand the repertoire of transformations and provide a suitable level of abstraction. We demonstrate the power of this approach by developing a set of optimizations using our transformation language and showing how the transformations can be converted into a form which makes it easier to apply them, while maintaining trust in the resulting optimizing steps. The approach is illustrated through a transformational case study where we apply several optimizations to a small program.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sara Kalvala|Richard Warburton|David Lacey|Sara Kalvala|Richard Warburton|David Lacey|", "references": "", "organization": "University of Warwick, Coventry, UK|University of Warwick, Coventry, UK|XMOS Semiconductor, Bristol, UK|University of Warwick, Coventry, UK|University of Warwick, Coventry, UK|XMOS Semiconductor, Bristol, UK|", "title": ["Program transformations using temporal logic side conditions"]},
{"abstract": "This article explains how to construct a ranking function for any program that is proved terminating by \n.\nThe \u201cprinciple of size-change termination\u201d for a first-order functional language with well-ordered data is intuitive: A program terminates on all inputs, if every infinite call sequence (following program control flow) would imply an infinite descent in some data values. Size-change analysis is based on information associated with the subject program's call-sites. This information indicates, for each call-site, strict or weak data decreases observed as a computation traverses the call-site. The set \n of call-site sequences for which the size-changes imply infinite descent is \u03c9-regular, as is the set \n of infinite call-site sequences following the program flowchart. If \n \u2286 \n (a decidable problem), every infinite call sequence would imply infinite descent in a well-ordering\u2014an impossibility\u2014so the program must terminate.\nThis analysis accounts for termination arguments applicable to different call-site sequences, without indicating a ranking function for the program's termination. In this article, it is explained how one can be constructed whenever size-change analysis succeeds. The constructed function has an unexpectedly simple form; it is expressed using only min, max, and lexicographic tuples of parameters and constants. In principle, such functions can be tested to determine whether size-change analysis will be successful. As a corollary, if a program verified as terminating performs only multiply recursive operations, the function that it computes is multiply recursive.\nThe ranking function construction is connected with the determinization of the B\u00fcchi automaton for \n. While the result is not practical, it is of value in addressing the scope of size-change reasoning. This reasoning has been applied broadly, in the analysis of functional and logic programs, as well as term rewrite systems.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Chin Soon Lee|Chin Soon Lee|", "references": "", "organization": "Max-Planck-Institut f\u00fcr Informatik, Saarbr\u00fccken, Germany|Max-Planck-Institut f\u00fcr Informatik, Saarbr\u00fccken, Germany|", "title": ["Ranking functions for size-change termination"]},
{"abstract": "We present a new approach to adding state and state-changing commands to a term language. As a formal semantics it can be seen as a generalization of predicate transformer semantics, but beyond that it brings additional opportunities for specifying and verifying programs. It is based on a construct called a \n, which is a term of the form \n \u25b9 \n, where \n stands for a command and \n stands for a term of any type. If \n is boolean, \n \u25b9 \n is closely related to the weakest precondition \n(\n,\n). The new theory draws together functional and imperative programming in a simple way. In particular, imperative procedures and functions are seen to be governed by the same laws as classical functions. We get new techniques for reasoning about programs, including the ability to dispense with logical variables and their attendant complexities. The theory covers both programming and specification languages, and supports unbounded demonic and angelic nondeterminacy in both commands and terms.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Joseph M. Morris|Alexander Bunkenburg|Malcolm Tyrrell|Joseph M. Morris|Alexander Bunkenburg|Malcolm Tyrrell|", "references": "", "organization": "Dublin City University and Lero - the Irish Engineering Research Centre, Dublin, Ireland|University of Glasgow, Glasgow, UK|Dublin City University and Lero - the Irish Engineering Research Centre, Dublin, Ireland|Dublin City University and Lero - the Irish Engineering Research Centre, Dublin, Ireland|University of Glasgow, Glasgow, UK|Dublin City University and Lero - the Irish Engineering Research Centre, Dublin, Ireland|", "title": ["Term transformers: A new approach to state"]},
{"abstract": "We have built a runtime compilation system that takes unmodified sequential binaries and improves their performance on off-the-shelf multiprocessors using dynamic vectorization and loop-level parallelization techniques. Our system, Azure, is purely software based and requires no specific hardware support for speculative thread execution, yet it is able to break even in most cases; that is, the achieved speedup exceeds the cost of runtime monitoring and compilation, often by significant amounts.\nKey to this remarkable performance is an offline preprocessing step that extracts a \n control flow graph (CFG) from the binary program ahead of time. This statically obtained CFG is incomplete in that it may be missing some edges corresponding to computed branches. We describe how such additional control flow edges are discovered and handled at runtime, so that an incomplete static analysis never leads to an incorrect optimization result.\nThe availability of a \n CFG enables us to statically partition a binary executable into single-entry multiple-exit regions and to identify potential parallelization candidates ahead of execution. Program regions that are not candidates for parallelization can thereby be excluded completely from runtime monitoring and dynamic recompilation. Azure's extremely low overhead is a direct consequence of this design.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Efe Yardimci|Michael Franz|Efe Yardimci|Michael Franz|", "references": "", "organization": "University of California, Irvine|University of California, Irvine|University of California, Irvine|University of California, Irvine|", "title": ["Mostly static program partitioning of binary executables"]},
{"abstract": "Proof Carrying Code provides trust in mobile code by requiring certificates that ensure the code adherence to specific conditions. The prominent approach to generate certificates for compiled code is Certifying Compilation, that automatically generates certificates for simple safety properties.\nIn this work, we present Certificate Translation, a novel extension for standard compilers that automatically transforms formal proofs for more expressive and complex properties of the source program to certificates for the compiled code.\nThe article outlines the principles of certificate translation, instantiated for a nonoptimizing compiler and for standard compiler optimizations in the context of an intermediate RTL Language.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gilles Barthe|Benjamin Gr\u00e9goire|C\u00e9sar Kunz|Tamara Rezk|Gilles Barthe|Benjamin Gr\u00e9goire|C\u00e9sar Kunz|Tamara Rezk|", "references": "", "organization": "IMDEA Software|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|IMDEA Software|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|INRIA Sophia Antipolis\u2014M\u00e9diterran\u00e9e|", "title": ["Certificate translation for optimizing compilers"]},
{"abstract": "In object-oriented programs, objects often provide methods whose parameter types or return types are the object types themselves. For example, the parameter types of binary methods are the types of their receiver objects, and the return types of some factory methods are the types of their enclosing objects. However, most object-oriented languages do not support such methods precisely because their type systems do not support explicit recursive types, which lead to a mismatch between subclassing and subtyping. This mismatch means that an expression of a subclass may not always be usable in a context where an expression of a superclass is expected, which is not intuitive in an object-oriented setting. Researchers have proposed various type-sound approaches to support methods with types of their enclosing object types denoted by some variants of ThisType, but they reject reasonable and useful methods due to unpermissive type systems or they use less precise declared inexact types rather than runtime exact types.\nIn this article, we present a thorough approach to support methods with ThisTypes: from a new encoding of objects in a typed lambda calculus that allows subtyping by subclassing to an open-source implementation as an extension of the Java programming language. We first provide real-world examples that motivate the need for ThisTyped methods to precisely describe desired properties of programs. We define a new object encoding that enables subtyping by subclassing even in the presence of negative occurrences of type recursion variables by distinguishing object types from existential object types. Based on this object encoding, we formalize language features to support ThisTyped methods with a core calculus CoreThisJava, and prove its type soundness. Finally, we provide ThisJava, a prototype implementation of the calculus, to show its backward compatibility, and we make it publicly available. We believe that our approach theoretically expands the long pursuit of an object-oriented language with ThisTypes to support more useful methods with more precise types.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sukyoung Ryu|Sukyoung Ryu|", "references": "", "organization": "KAIST, Republic of Korea|KAIST, Republic of Korea|", "title": ["ThisType for Object-Oriented Languages: From Theory to Practice"]},
{"abstract": "Contracts are behavioral descriptions of Web services. We devise a theory of contracts that formalizes the compatibility of a client with a service, and the safe replacement of a service with another service. The use of contracts statically ensures the successful completion of every possible interaction between compatible clients and services.\nThe technical device that underlies the theory is the \n, which is an explicit coercion preventing some possible behaviors of services and, in doing so, make services compatible with different usage scenarios. We show that filters can be seen as proofs of a sound and complete subcontracting deduction system which simultaneously refines and extends Hennessy's classical axiomatization of the must testing preorder. The relation is decidable, and the decision algorithm is obtained via a cut-elimination process that proves the coherence of subcontracting as a logical system.\nDespite the richness of the technical development, the resulting approach is based on simple ideas and basic intuitions. Remarkably, its application is mostly independent of the language used to program the services or the clients. We outline the practical aspects of our theory by studying two different concrete syntaxes for contracts and applying each of them to Web services languages. We also explore implementation issues of filters and discuss the perspectives of future research this work opens.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Giuseppe Castagna|Nils Gesbert|Luca Padovani|Giuseppe Castagna|Nils Gesbert|Luca Padovani|", "references": "", "organization": "CNRS, PPS, Universit\u00e9 Paris Diderot, France|University of Glasgow|ISTI, Universit\u00e0 degli Studi di Urbino|CNRS, PPS, Universit\u00e9 Paris Diderot, France|University of Glasgow|ISTI, Universit\u00e0 degli Studi di Urbino|", "title": ["A theory of contracts for Web services"]},
{"abstract": "We present a modular approach to automatic complexity analysis of integer programs. Based on a novel alternation between finding symbolic time bounds for program parts and using these to infer bounds on the absolute values of program variables, we can restrict each analysis step to a small part of the program while maintaining a high level of precision. The bounds computed by our method are polynomial or exponential expressions that depend on the absolute values of input parameters.\nWe show how to extend our approach to arbitrary cost measures, allowing the use of our technique to find upper bounds for other expended resources, such as network requests or memory consumption. Our contributions are implemented in the open-source tool KoAT, and extensive experiments show the performance and power of our implementation in comparison with other tools.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Marc Brockschmidt|Fabian Emmes|Stephan Falke|Carsten Fuhs|J\u00fcrgen Giesl|Marc Brockschmidt|Fabian Emmes|Stephan Falke|Carsten Fuhs|J\u00fcrgen Giesl|", "references": "", "organization": "Microsoft Research, Cambridge, UK|RWTH Aachen University, Aachen, Germany|Karlsruhe Institute of Technology, Karlsruhe, Germany|Birkbeck, University of London, London, UK|RWTH Aachen University, Aachen, Germany|Microsoft Research, Cambridge, UK|RWTH Aachen University, Aachen, Germany|Karlsruhe Institute of Technology, Karlsruhe, Germany|Birkbeck, University of London, London, UK|RWTH Aachen University, Aachen, Germany|", "title": ["Analyzing Runtime and Size Complexity of Integer Programs"]},
{"abstract": "Affine transformations have proven to be powerful for loop restructuring due to their ability to model a very wide range of transformations. A single multidimensional affine function can represent a long and complex sequence of simpler transformations. Existing affine transformation frameworks such as the Pluto algorithm, which include a cost function for modern multicore architectures for which coarse-grained parallelism and locality are crucial, consider only a subspace of transformations to avoid a combinatorial explosion in finding transformations. The ensuing practical trade-offs lead to the exclusion of certain useful transformations: in particular, transformation compositions involving loop reversals and loop skewing by negative factors. In addition, there is currently no proof that the algorithm successfully finds a tree of permutable loop bands for all affine loop nests. In this article, we propose an approach to address these two issues (1) by modeling a much larger space of practically useful affine transformations in conjunction with the existing cost function of Pluto, and (2) by extending the Pluto algorithm in a way that allows a proof for its soundness and completeness for all affine loop nests. We perform an experimental evaluation of both, the effect on compilation time, and performance of generated codes. The evaluation shows that our new framework, Pluto+, provides no degradation in performance for any benchmark from Polybench. For the Lattice Boltzmann Method (LBM) simulations with periodic boundary conditions, it provides a mean speedup of 1.33 \u00d7 over Pluto. We also show that Pluto+ does not increase compilation time significantly. Experimental results on Polybench show that Pluto+ increases overall polyhedral source-to-source optimization time by only 15%. In cases in which it improves execution time significantly, it increased polyhedral optimization time by only 2.04 \u00d7 .\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Uday Bondhugula|Aravind Acharya|Albert Cohen|Uday Bondhugula|Aravind Acharya|Albert Cohen|", "references": "", "organization": "Indian Institute of Science, Bangalore, India|Indian Institute of Science, Bangalore, India|INRIA and ENS, Paris, France|Indian Institute of Science, Bangalore, India|Indian Institute of Science, Bangalore, India|INRIA and ENS, Paris, France|", "title": ["The Pluto+ Algorithm: A Practical Approach for Parallelization and Locality Optimization of Affine Loop Nests"]},
{"abstract": "Floyd--Hoare logic is a foundation of axiomatic semantics of classical programs, and it provides effective proof techniques for reasoning about correctness of classical programs. To offer similar techniques for quantum program verification and to build a logical foundation of programming methodology for quantum computers, we develop a full-fledged Floyd--Hoare logic for both partial and total correctness of quantum programs. It is proved that this logic is (relatively) complete by exploiting the power of weakest preconditions and weakest liberal preconditions for quantum programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mingsheng Ying|Mingsheng Ying|", "references": "", "organization": "University of Technology, Sydney and Tsinghua University, China|University of Technology, Sydney and Tsinghua University, China|", "title": ["Floyd--hoare logic for quantum programs"]},
{"abstract": "Ownership is a powerful concept to structure the object store and to control aliasing and modifications of objects. This article presents an ownership type system for a Java-like programming language with generic types.\nLike our earlier Universe type system, Generic Universe Types structure the heap hierarchically. In contrast to earlier work, we separate the enforcement of an ownership topology from an encapsulation system. The topological system uses an existential modifier to express that no ownership information is available statically. On top of the topological system, we build an encapsulation system that enforces the owner-as-modifier discipline. This discipline does not restrict aliasing, but requires modifications of an object to be initiated by its owner. This allows owner objects to control state changes of owned objects\u2014for instance, to maintain invariants. Separating the topological system from the encapsulation system allows for a cleaner formalization, separation of concerns, and simpler reuse of the individual systems in different contexts.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Werner Dietl|Sophia Drossopoulou|Peter M\u00fcller|Werner Dietl|Sophia Drossopoulou|Peter M\u00fcller|", "references": "", "organization": "University of Washington|Imperial College London|ETH Zurich|University of Washington|Imperial College London|ETH Zurich|", "title": ["Separating ownership topology and encapsulation with generic universe types"]},
{"abstract": "The most intuitive memory model for shared-memory multi-threaded programming is \n (SC), but it disallows the use of many compiler and hardware optimizations and thus affects performance. Data-race-free (DRF) models, such as the C++11 memory model, guarantee SC execution for data-race-free programs. But these models provide no guarantee at all for racy programs, compromising the safety and debuggability of such programs. To address the safety issue, the Java memory model, which is also based on the DRF model, provides a weak semantics for racy executions. However, this semantics is subtle and complex, making it difficult for programmers to reason about their programs and for compiler writers to ensure the correctness of compiler optimizations.\nWe present the \n memory model, which is simple for programmers to understand and use while still supporting many common optimizations. We introduce a \n that can be signaled to halt execution. If a program executes without throwing this exception, then \n guarantees that the execution is SC. If a program throws an MM exception during an execution, then \n guarantees that the program has a data race. We observe that SC violations can be detected in hardware through a lightweight form of conflict detection. Furthermore, our model safely allows aggressive compiler and hardware optimizations within compiler-designated program regions. We formalize our memory model, prove several properties of this model, describe a compiler and hardware design suitable for \n, and evaluate the performance overhead due to our compiler and hardware requirements.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Daniel Marino|Abhayendra Singh|Todd Millstein|Madanlal Musuvathi|Satish Narayanasamy|Daniel Marino|Abhayendra Singh|Todd Millstein|Madanlal Musuvathi|Satish Narayanasamy|", "references": "S. Adve and K. Gharachorloo. 1996. Shared memory consistency models: A tutorial. Computer 29, 12 (1996), 66--76.  |Sarita V. Adve and Hans-J. Boehm. 2010. Memory models: A case for rethinking parallel languages and hardware. Commun. ACM 53, 8 (Aug. 2010), 90--101. DOI:http://dx.doi.org/10.1145/1787234.1787255  |S. V. Adve and M. D. Hill. 1990. Weak ordering\u2014A new definition. In Proceedings of the 17th Annual International Symposium on Computer Architecture. ACM, 2--14.  |S. V. Adve, M. D. Hill, B. P. Miller, and R. H. B. Netzer. 1991. Detecting data races on weak memory systems. In Proceedings of the 18th Annual International Symposium on Computer Architecture. 234--243.  |Wonsun Ahn, Shanxiang Qi, Jae-Woo Lee, Marios Nicolaides, Xing Fang, Josep Torrellas, David Wong, and Samuel Midkiff. 2009. BulkCompiler: High-performance sequential consistency through cooperative compiler and hardware support. In Proceedings of the 42nd International Symposium on Microarchitecture.  |C. Bienia, S. Kumar, J. P. Singh, and K. Li. 2008. The PARSEC benchmark suite: Characterization and architectural implications. In Proceedings of the 17th International Conference on Parallel Architectures and Compilation Techniques.  |C. Blundell, M. M. K. Martin, and Thomas F. Wenisch. 2009. InvisiFence: Performance-transparent memory ordering in conventional multiprocessors. In Proceedings of the 36th Annual International Symposium on Computer Architecture.  |H. J. Boehm. 2009. Simple thread semantics require race detection. In FIT Session at PLDI.|H. J. Boehm and S. Adve. 2008. Foundations of the C++ concurrency memory model. In Proceedings of the 2008 ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 68--78.  |Michael D. Bond, Katherine E. Coons, and Kathryn S. McKinley. 2010. PACER: Proportional detection of data races. In Proceedings of the 2010 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201910). ACM, New York, NY, 255--268. DOI:http://dx.doi.org/10.1145/1806596.1806626  |C. Boyapati, R. Lee, and M. Rinard. 2002. Ownership types for safe programming: Preventing data races and deadlocks. In Proceedings of OOPSLA.  |Chandrasekhar Boyapati and Martin Rinard. 2001. A parameterized type system for race-free java programs. In Proceedings of OOPSLA. ACM Press, 56--69.  |L. Ceze, J. Devietti, B. Lucia, and S. Qadeer. 2009. The case for system support for concurrency exceptions. In USENIX HotPar. |Luis Ceze, James Tuck, Pablo Montesinos, and Josep Torrellas. 2007. BulkSC: Bulk enforcement of sequential consistency. In Proceedings of the 34th Annual International Symposium on Computer Architecture. 278--289.  |Luis Ceze, James Tuck, Josep Torrellas, and Calin Cascaval. 2006. Bulk disambiguation of speculative threads in multiprocessors. In Proceedings of the 33rd Annual International Symposium on Computer Architecture. IEEE Computer Society, 227--238.  |D. Dice, Y. Lev, M. Moir, and D. Nussbaum. 2009. Early experience with a commercial hardware transactional memory implementation. In Proceedings of ASPLOS.  |T. Elmas, S. Qadeer, and S. Tasiran. 2007. Goldilocks: A race and transaction-aware java runtime. In Proceedings of the 2007 Conference on Programming Language Design and Implementation. ACM, 245--255.  |C. Fidge. 1991. Logical time in distributed computing systems. IEEE Comput. 24, 8 (Aug. 1991), 28--33. DOI:http://dx.doi.org/10.1109/2.84874  |C. Flanagan and S. N. Freund. 2009. FastTrack: Efficient and precise dynamic race detection. In Proceedings of the 2009 Conference on Programming Language Design and Implementation.  |K. Gharachorloo and P. B. Gibbons. 1991. Detecting violations of sequential consistency. In Proceedings of the 2nd Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA\u201990). ACM New York, NY, USA, 316--326.  |K. Gharachorloo, A. Gupta, and J. Hennessy. 1991. Two techniques to enhance the performance of memory consistency models. In Proceedings of the International Conference on Parallel Processing. 355--364.|K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. 1990. Memory consistency and event ordering in scalable shared-memory multiprocessors. In Proceedings of the 18th Annual International Symposium on Computer Architecture. 15--26.  |Lance Hammond, Vicky Wong, Michael K. Chen, Brian D. Carlstrom, John D. Davis, Ben Hertzberg, Manohar K. Prabhu, Honggo Wijaya, Christos Kozyrakis, and Kunle Olukotun. 2004. Transactional memory coherence and consistency. In Proceedings of the 31st Annual International Symposium on Computer Architecture. 102--113. |R. A. Haring, M. Ohmacht, T. W. Fox, M. K. Gschwind, D. L. Satterfield, K. Sugavanam, P. W. Coteus, P. Heidelberger, M. A. Blumrich, R. W. Wisniewski, A. Gara, G. L.-T. Chiu, P. A. Boyle, N. H. Chist, and Changhoan Kim. 2012. The IBM blue gene/Q compute chip. IEEE Micro 32, 2 (2012), 48--60. DOI:http://dx.doi.org/10.1109/MM.2011.108  |Maurice Herlihy and J. Eliot B. Moss. 1993. Transactional memory: Architectural support for lock-free data structures. In Proceedings of the 20th Annual International Symposium on Computer Architecture. ACM, 289--300.  |Intel Corporation. 2012. Intel architecture instruction set extensions programming reference. 319433-012 Edition (Feb. 2012).|A. Kamil, J. Su, and K. Yelick. 2005. Making sequential consistency practical in titanium. In Proceedings of the 2005 ACM/IEEE Conference on Supercomputing. IEEE Computer Society, 15.  |A. Krishnamurthy and K. Yelick. 1996. Analyses and optimizations for shared address space programs. J. Parallel Distrib. Comput. 38, 2 (1996), 130--144.  |L. Lamport. 1978. Time, clocks, and the ordering of events in a distributed system. Commun. ACM 21, 7 (1978), 558--565.  |L. Lamport. 1979. How to make a multiprocessor computer that correctly executes multiprocess programs. IEEE Trans. Comput. 100, 28 (1979), 690--691.  |C. Lattner and V. Adve. 2004. LLVM: A compilation framework for lifelong program analysis & transformation. In Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization. IEEE Computer Society. |Changhui Lin, Vijay Nagarajan, Rajiv Gupta, and Bharghava Rajaram. 2012. Efficient sequential consistency via conflict ordering. In Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems.  |Brandon Lucia, Luis Ceze, Karin Strauss, Shaz Qadeer, and Hans Boehm. 2010. Conflict exceptions: Providing simple parallel language semantics with precise hardware exceptions. In Proceedings of the 37th Annual International Symposium on Computer Architecture.|J. Manson, W. Pugh, and S. Adve. 2005. The java memory model. In Proceedings of POPL. ACM, 378--391.  |D. Marino, M. Musuvathi, and S. Narayanasamy. 2009a. LiteRace: Effective sampling for lightweight data-race detection. (2009).|Daniel Marino, Abhayendra Singh, Todd Millstein, Madanlal Musuvathi, and Satish Narayanasamy. 2009b. DRFx: A Simple and Efficient Memory Model for Concurrent Programming Languages. Technical Report 090021. UCLA Computer Science Department. http://fmdb.cs.ucla.edu/Treports/090021.pdf.|Daniel Marino, Abhayendra Singh, Todd Millstein, Madanlal Musuvathi, and Satish Narayanasamy. 2010. DRFx: A simple and efficient memory model for concurrent programming languages. In PLDI\u201910. ACM, 351--362.  |Daniel Marino, Abhayendra Singh, Todd Millstein, Madanlal Musuvathi, and Satish Narayanasamy. 2011. A case for an SC-preserving compiler. In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation.  |Friedemann Mattern. 1989. Virtual time and global states of distributed systems. In Proceedings Workshop on Parallel and Distributed Algorithms, Cosnard M. et&nbsp;al. (Ed.). North-Holland/Elsevier, 215--226. (Reprinted in: Z. Yang, T. A. Marsland (Eds.), Global States and Time in Distributed Systems, IEEE, 1994, pp. 123--133.).|Abdullah Muzahid, Shanxiang Qi, and Josep Torrellas. 2012. Vulcan: Hardware support for detecting sequential consistency violations dynamically. In Proceedings of the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO\u201912). IEEE Computer Society, Washington, DC, USA, 363--375. DOI:http://dx.doi.org/10.1109/MICRO.2012.41  |A. Muzahid, D. Suarez, S. Qi, and J. Torrellas. 2009. SigRace: Signature-based data race detection. In Proceedings of the 36th Annual International Symposium on Computer Architecture.  |N. Neelakantam, C. Blundell, J. Devietti, M. Martin, and C. Zilles. 2008. FeS2: A Full-system Execution-driven Simulator for x86. In Poster at Thirteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS'08).|M. Prvulovic and J. Torrelas. 2003. ReEnact: Using thread-level speculation mechanisms to debug data races in multithreaded codes. In Proceedings of the 30th Annual International Symposium on Computer Architecture. San Diego, CA.  |Xuehai Qian, Josep Torrellas, Benjamin Sahelices, and Depei Qian. 2013. Volition: Scalable and precise sequential consistency violation detection. In Proceedings of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS\u201913). ACM, New York, NY, 535--548. DOI:http://dx.doi.org/10.1145/2451116.2451174  |P. Ranganathan, V. S. Pai, and S. V. Adve. 1997. Using speculative retirement and larger instruction windows to narrow the performance gap between memory consistency models. In Proceedings of the 9th Annual ACM Symposium on Parallel Algorithms and Architectures. 199--210.  |Koushik Sen. 2008. Race directed random testing of concurrent programs. In Proceedings of the 2008 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201908). ACM, New York, NY, 11--21. DOI:http://dx.doi.org/10.1145/1375581.1375584  |Aritra Sengupta, Swarnendu Biswas, Minjia Zhang, Michael D. Bond, and Milind Kulkarni. 2015. Hybrid static--dynamic analysis for statically bounded region serializability. In Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS\u201915). ACM, New York, NY, 561--575. DOI:http://dx.doi.org/10.1145/2694344.2694379  |D. Shasha and M. Snir. 1988. Efficient and correct execution of parallel programs that share memory. ACM Trans. Program. Lang. Syst. 10, 2 (1988), 282--312.  |Abhayendra Singh, Daniel Marino, Satish Narayanasamy, Todd Millstein, and Madan Musuvathi. 2011a. Efficient processor support for DRFx, a memory model with exceptions. In Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XVI). ACM, 53--66.  |Abhayendra Singh, Daniel Marino, Satish Narayanasamy, Todd Millstein, and Madanlal Musuvathi. 2011b. Efficient Processor Support for DRFx, a Memory Model with Exceptions. Technical Report 110002. UCLA Computer Science Department. Retrieved from http://fmdb.cs.ucla.edu/Treports/110002.pdf.|Abhayendra Singh, S. Narayanasamy, D. Marino, T. Millstein, and M. Musuvathi. 2012. End-to-end sequential consistency. In Proceedings of the 39th Annual International Symposium on Computer Architecture. 524--535. |Z. Sura, X. Fang, C. L. Wong, S. P. Midkiff, J. Lee, and D. Padua. 2005. Compiler techniques for high performance sequentially consistent java programs. In Proceedings of the 10th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming. 2--13.  |Walter Triebel, Joseph Bissell, and Rick Booth. 2001. Programming Itanium\u00f6-based Systems. Intel Press. |Thomas F. Wenisch, A. Ailamaki, B. Falsafi, and A. Moshovos. 2007. Mechanisms for store-wait-free multiprocessors. In Proceedings of the 34th Annual International Symposium on Computer Architecture.  |M. Wolfe. 1989. More iteration space tiling. In Proceedings of the 1989 ACM/IEEE Conference on Supercomputing (Supercomputing\u201989). ACM, New York, NY, 655--664. DOI:http://dx.doi.org/10.1145/76263.76337  |S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta. 1995. The SPLASH-2 programs: Characterization and methodological considerations. In Proceedings of the 22nd Annual International Symposium on Computer Architecture. 24--36.  |", "organization": "Symantec Research Labs|Google Inc., CA|University of California, Los Angeles|Microsoft Research, Redmond|University of Michigan, Ann Arbor|Symantec Research Labs|Google Inc., CA|University of California, Los Angeles|Microsoft Research, Redmond|University of Michigan, Ann Arbor|", "title": ["DRF", ": An Understandable, High Performance, and Flexible Memory Model for Concurrent Languages"]},
{"abstract": "The programming language Mezzo is equipped with a rich type system that controls aliasing and access to mutable memory. We give a comprehensive tutorial overview of the language. Then we present a modular formalization of Mezzo\u2019s core type system, in the form of a concurrent \u03bb-calculus, which we successively extend with references, locks, and adoption and abandon, a novel mechanism that marries Mezzo\u2019s static ownership discipline with dynamic ownership tests. We prove that well-typed programs do not go wrong and are data-race free. Our definitions and proofs are machine checked.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Thibaut Balabonski|Fran\u00e7ois Pottier|Jonathan Protzenko|Thibaut Balabonski|Fran\u00e7ois Pottier|Jonathan Protzenko|", "references": "", "organization": "INRIA|INRIA, Paris Cedex, France|INRIA|INRIA|INRIA, Paris Cedex, France|INRIA|", "title": ["The Design and Formalization of Mezzo, a Permission-Based Programming Language"]},
{"abstract": "Loop tiling is a widely used program optimization that improves data locality and enables coarse-grained parallelism. Parameterized tiled loops, where the tile sizes remain symbolic parameters until runtime, are quite useful for iterative compilers and autotuners that produce highly optimized libraries and codes. Although it is easy to generate such loops for (hyper-) rectangular iteration spaces tiled with (hyper-) rectangular tiles, many important computations do not fall into this restricted domain. In the past, parameterized tiled code generation for the general case of convex iteration spaces being tiled by (hyper-) rectangular tiles has been solved with bounding box approaches or with sophisticated and expensive machinery.\nWe present a novel formulation of the parameterized tiled loop generation problem using a polyhedral set called the \n. By reducing the problem of parameterized tiled code generation to that of generating standard loops and simple postprocessing of these loops, the outset method achieves a code generation efficiency that is comparable to existing code generation techniques, including those for fixed tile sizes. We compare the performance of our technique with several other tiled loop generation methods on kernels from BLAS3 and scientific computations. The simplicity of our solution makes it well suited for use in production compilers\u2014in particular, the IBM XL compiler uses the inset-based technique introduced in this article for register tiling. We also provide a complete coverage of parameterized tiling of perfect loop nests by describing three related techniques: (i) a scheme for separating full and partial tiles; (ii) a scheme for generating tiled loops directly from the abstract syntax tree representation of loops; (iii) a formal characterization of parameterized loop tiling using bilinear forms and a Symbolic Fourier-Motzkin Elimination (SFME)-based parameterized tiled loop generation method.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Lakshminarayanan Renganarayanan|Daegon Kim|Michelle Mills Strout|Sanjay Rajopadhye|Lakshminarayanan Renganarayanan|Daegon Kim|Michelle Mills Strout|Sanjay Rajopadhye|", "references": "", "organization": "IBM T.J. Watson Research Center, Yorktown Heights, NY|CORESPEQ, Inc., Milpitas, CA|Colorado State University, Fort Collins, CO|Colorado State University, Fort Collins, CO|IBM T.J. Watson Research Center, Yorktown Heights, NY|CORESPEQ, Inc., Milpitas, CA|Colorado State University, Fort Collins, CO|Colorado State University, Fort Collins, CO|", "title": ["Parameterized loop tiling"]},
{"abstract": "Asynchronous programming is a ubiquitous systems programming idiom for managing concurrent interactions with the environment. In this style, instead of waiting for time-consuming operations to complete, the programmer makes a non-blocking call to the operation and posts a callback task to a task buffer that is executed later when the time-consuming operation completes. A cooperative scheduler mediates the interaction by picking and executing callback tasks from the task buffer to completion (and these callbacks can post further callbacks to be executed later). Writing correct asynchronous programs is hard because the use of callbacks, while efficient, obscures program control flow.\nWe provide a formal model underlying asynchronous programs and study verification problems for this model. We show that the safety verification problem for finite-data asynchronous programs is expspace-complete. We show that liveness verification for finite-data asynchronous programs is decidable and polynomial-time equivalent to Petri net reachability. Decidability is not obvious, since even if the data is finite-state, asynchronous programs constitute infinite-state transition systems: both the program stack for an executing task and the task buffer of pending calls to tasks can be potentially unbounded.\nOur main technical constructions are polynomial-time, semantics-preserving reductions from asynchronous programs to Petri nets and back. The first reduction allows the use of algorithmic techniques on Petri nets for the verification of asynchronous programs, and the second allows lower bounds on Petri nets to apply also to asynchronous programs.\nWe also study several extensions to the basic models of asynchronous programs that are inspired by additional capabilities provided by implementations of asynchronous libraries and classify the decidability and undecidability of verification questions on these extensions.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Pierre Ganty|Rupak Majumdar|Pierre Ganty|Rupak Majumdar|", "references": "", "organization": "IMDEA Software, Madrid, Spain|MPI-SWS, Kaiserslautern, Germany|IMDEA Software, Madrid, Spain|MPI-SWS, Kaiserslautern, Germany|", "title": ["Algorithmic verification of asynchronous programs"]},
{"abstract": "An important, challenging problem in the verification of imperative programs with shared, mutable state is the frame problem in the presence of data abstraction. That is, one must be able to specify and verify upper bounds on the set of memory locations a method can read and write without exposing that method's implementation.\nSeparation logic is now widely considered the most promising solution to this problem. However, unlike conventional verification approaches, separation logic assertions cannot mention heap-dependent expressions from the host programming language, such as method calls familiar to many developers. Moreover, separation logic-based verifiers are often based on symbolic execution. These symbolic execution-based verifiers typically do not support non-separating conjunction, and some of them rely on the developer to explicitly fold and unfold predicate definitions. Furthermore, several researchers have wondered whether it is possible to use verification condition generation and standard first-order provers instead of symbolic execution to automatically verify conformance with a separation logic specification.\nIn this article, we propose a variant of separation logic called \n that supports heap-dependent expressions inside assertions. Conformance with an implicit dynamic frames specification can be checked by proving the validity of a number of first-order verification conditions. To show that these verification conditions can be discharged automatically by standard first-order provers, we have implemented our approach in a verifier prototype and have used this prototype to verify several challenging examples from related work. Our prototype automatically folds and unfolds predicate definitions, as required, during the proof and can reason about non-separating conjunction which is used in the specifications of some of these examples. Finally, we prove the soundness of the approach.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jan Smans|Bart Jacobs|Frank Piessens|Jan Smans|Bart Jacobs|Frank Piessens|", "references": "", "organization": "K.U. Leuven|K.U. Leuven|K.U. Leuven|K.U. Leuven|K.U. Leuven|K.U. Leuven|", "title": ["Implicit dynamic frames"]},
{"abstract": "Finite-state properties account for an important class of program properties, typically related to the order of operations invoked on objects. Many library implementations therefore include manually written finite-state monitors to detect violations of finite-state properties at runtime. Researchers have recently proposed the explicit specification of finite-state properties and automatic generation of monitors from the specification. However, runtime monitoring only shows the presence of violations, and typically cannot prove their absence. Moreover, inserting a runtime monitor into a program under test can slow down the program by several orders of magnitude.\nIn this work, we therefore present a set of four static whole-program analyses that partially evaluate runtime monitors at compile time, with increasing cost and precision. As we show, ahead-of-time evaluation can often evaluate the monitor completely statically. This may prove that the program cannot violate the property on any execution or may prove that violations do exist. In the remaining cases, the partial evaluation converts the runtime monitor into a residual monitor. This monitor only receives events from program locations that the analyses failed to prove irrelevant. This makes the residual monitor much more efficient than a full monitor, while still capturing all property violations at runtime.\nWe implemented the analyses in Clara, a novel framework for the partial evaluation of AspectJ-based runtime monitors, and validated our approach by applying Clara to finite-state properties over several large-scale Java programs. Clara proved that most of the programs never violate our example properties. Some programs required monitoring, but in those cases Clara could often reduce the monitoring overhead to below 10%. We observed that several programs did violate the stated properties.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Eric Bodden|Patrick Lam|Laurie Hendren|Eric Bodden|Patrick Lam|Laurie Hendren|", "references": "", "organization": "Technische Universit\u00e4t Darmstadt|University of Waterloo|McGill University|Technische Universit\u00e4t Darmstadt|University of Waterloo|McGill University|", "title": ["Partially Evaluating Finite-State Runtime Monitors Ahead of Time"]},
{"abstract": "Performance modeling for scientific applications is important for assessing potential application performance and systems procurement in high-performance computing (HPC). Recent progress on communication tracing opens up novel opportunities for communication modeling due to its lossless yet scalable trace collection. Estimating the impact of scaling on communication efficiency still remains nontrivial due to execution-time variations and exposure to hardware and software artifacts.\nThis work contributes a fundamentally novel modeling scheme. We synthetically generate the application trace for large numbers of nodes via extrapolation from a set of smaller traces. We devise an innovative approach for topology extrapolation of single program, multiple data (SPMD) codes with stencil or mesh communication. Experimental results show that the extrapolated traces precisely reflect the communication behavior and the performance characteristics at the target scale for both strong and weak scaling applications. The extrapolated trace can subsequently be (a) replayed to assess communication requirements before porting an application, (b) transformed to autogenerate communication benchmarks for various target platforms, and (c) analyzed to detect communication inefficiencies and scalability limitations.\nTo the best of our knowledge, rapidly obtaining the communication behavior of parallel applications at arbitrary scale with the availability of timed replay, yet without actual execution of the application, at this scale, is without precedence and has the potential to enable otherwise infeasible system simulation at the exascale level.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Xing Wu|Frank Mueller|Xing Wu|Frank Mueller|", "references": "", "organization": "North Carolina State University, Raleigh, NC|North Carolina State University, Raleigh, NC|North Carolina State University, Raleigh, NC|North Carolina State University, Raleigh, NC|", "title": ["S", "E", ": Trace-based communication extrapolation for SPMD programs"]},
{"abstract": "In this article we provide an interprocedural analysis of linear two-variable equalities. The novel algorithm has a worst-case complexity of \ud835\udcaa(\n \u22c5 \n), where \n is the number of variables and \n is the program size. Thus, it saves a factor of \n in comparison to a related algorithm based on full linear algebra. We also indicate how the practical runtime can be further reduced significantly. The analysis can be applied, for example, for register coalescing, for identifying local variables and thus for interprocedurally observing stack pointer modifications as well as for an analysis of array index expressions, when analyzing low-level code.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Andrea Flexeder|Markus M\u00fcller-olm|Michael Petter|Helmut Seidl|Andrea Flexeder|Markus M\u00fcller-olm|Michael Petter|Helmut Seidl|", "references": "", "organization": "Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|Westf\u00e4lische Wilhelms-Universit\u00e4t M\u00fcnster, Germany|Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|Westf\u00e4lische Wilhelms-Universit\u00e4t M\u00fcnster, Germany|Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|Technische Universit\u00e4t M\u00fcnchen, Garching, Germany|", "title": ["Fast interprocedural linear two-variable equalities"]},
{"abstract": "Concurrency-related errors, such as data races, are frustratingly difficult to track down and eliminate in large object-oriented programs. Traditional approaches to preventing data races rely on protecting instruction sequences with synchronization operations. Such control-centric approaches are inherently brittle, as the burden is on the programmer to ensure that all concurrently accessed memory locations are consistently protected. Data-centric synchronization is an alternative approach that offloads some of the work on the language implementation. Data-centric synchronization groups fields of objects into \n to indicate that these fields must always be updated atomically. Each atomic set has associated \n, that is, code fragments that preserve the consistency of that atomic set. Synchronization operations are added automatically by the compiler. We present an extension to the Java programming language that integrates annotations for data-centric concurrency control. The resulting language, called AJ, relies on a type system that enables separate compilation and supports atomic sets that span multiple objects and that also supports full encapsulation for more efficient code generation. We evaluate our proposal by refactoring classes from standard libraries, as well as a number of multithreaded benchmarks, to use atomic sets. Our results suggest that data-centric synchronization is easy to use and enjoys low annotation overhead, while successfully preventing data races. Moreover, experiments on the SPECjbb benchmark suggest that acceptable performance can be achieved with a modest amount of tuning.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Julian Dolby|Christian Hammer|Daniel Marino|Frank Tip|Mandana Vaziri|Jan Vitek|Julian Dolby|Christian Hammer|Daniel Marino|Frank Tip|Mandana Vaziri|Jan Vitek|", "references": "", "organization": "IBM T.J. Watson Research Center, Yorktown Heights, NY|Saarland University, Saarbr\u00fccken, Germany|Symantec Research Labs, Culver City, CA|IBM T.J. Watson Research Center, Yorktown Heights, NY|IBM T.J. Watson Research Center, Yorktown Heights, NY|Purdue University, West Lafayette, IN|IBM T.J. Watson Research Center, Yorktown Heights, NY|Saarland University, Saarbr\u00fccken, Germany|Symantec Research Labs, Culver City, CA|IBM T.J. Watson Research Center, Yorktown Heights, NY|IBM T.J. Watson Research Center, Yorktown Heights, NY|Purdue University, West Lafayette, IN|", "title": ["A data-centric approach to synchronization"]},
{"abstract": "We present a type system for linear constraints over the reals intended for reasoning about the input-output directionality of variables. Types model the properties of definiteness, range width or approximation, lower and upper bounds of variables in a linear constraint. Several proof procedures are presented for inferring the type of a variable and for checking validity of type assertions. We rely on theory and tools for linear programming problems, linear algebra, parameterized polyhedra and negative constraints. An application of the type system is proposed in the context of the static analysis of constraint logic programs. Type assertions are at the basis of the extension of well-moding from pure logic programming. The proof procedures (both for type assertion validity and for well-moding) are implemented and their computational complexity is discussed. We report experimental results demonstrating the efficiency in practice of the proposed approach.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Salvatore Ruggieri|Fred Mesnard|Salvatore Ruggieri|Fred Mesnard|", "references": "", "organization": "Universit\u00e0 di Pisa, Pisa, Italy|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, Cedex 9, France|Universit\u00e0 di Pisa, Pisa, Italy|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, Cedex 9, France|", "title": ["Typing linear constraints"]},
{"abstract": "Over the last seven years, we have developed static-analysis methods to recover a good approximation to the variables and dynamically allocated memory objects of a stripped executable, and to track the flow of values through them. The article presents the algorithms that we developed, explains how they are used to recover Intermediate Representations (IRs) from executables that are similar to the IRs that would be available if one started from source code, and describes their application in the context of program understanding and automated bug hunting.\nUnlike algorithms for analyzing executables that existed prior to our work, the ones presented in this article provide useful information about memory accesses, even in the absence of debugging information. The ideas described in the article are incorporated in a tool for analyzing Intel x86 executables, called CodeSurfer/x86. CodeSurfer/x86 builds a system dependence graph for the program, and provides a GUI for exploring the graph by (i) navigating its edges, and (ii) invoking operations, such as forward slicing, backward slicing, and chopping, to discover how parts of the program can impact other parts.\nTo assess the usefulness of the IRs recovered by CodeSurfer/x86 in the context of automated bug hunting, we built a tool on top of CodeSurfer/x86, called Device-Driver Analyzer for x86 (DDA/x86), which analyzes device-driver executables for bugs. Without the benefit of either source code or symbol-table/debugging information, DDA/x86 was able to find known bugs (that had been discovered previously by source-code analysis tools), along with useful error traces, while having a low false-positive rate. DDA/x86 is the first known application of program analysis/verification techniques to industrial executables.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gogul Balakrishnan|Thomas Reps|Gogul Balakrishnan|Thomas Reps|", "references": "", "organization": "NEC Laboratories America, Inc., Princeton, NJ|University of Wisconsin and GrammaTech, Inc., Ithaca, NY|NEC Laboratories America, Inc., Princeton, NJ|University of Wisconsin and GrammaTech, Inc., Ithaca, NY|", "title": ["WYSINWYX: What you see is not what you eXecute"]},
{"abstract": "Permissions specify mutable state that can be accessed by a program. Fractions distinguish write access (1) from read access (any smaller fraction). Nesting can model object invariants and ownership. Fractional permissions provides a foundation the meaning of many of access-based annotations: uniqueness, read-only, immutability, method effects, guarded state, etc. The semantics of fractional permissions with nesting is given in terms of \u201cfractional heaps.\u201d We show that the fraction law \u03a0 \u2261 1/2 \u03a0 + 1/2 \u03a0 permits sound reasoning and that nesting can be carried out safely using only local reasoning.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "John Tang Boyland|John Tang Boyland|", "references": "", "organization": "University of Wisconsin-Milwaukee, Milwaukee WI|University of Wisconsin-Milwaukee, Milwaukee WI|", "title": ["Semantics of fractional permissions with nesting"]},
{"abstract": "Software Transactional Memory (STM) is an attractive basis for the development of language features for concurrent programming. However, the semantics of these features can be delicate and problematic. In this article we explore the trade-offs semantic simplicity, the viability of efficient implementation strategies, and the flexibility of language constructs. Specifically, we develop semantics and type systems for the constructs of the Automatic Mutual Exclusion (AME) programming model; our results apply also to other constructs, such as atomic blocks. With this semantics as a point of reference, we study several implementation strategies. We model STM systems that use in-place update, optimistic concurrency, lazy conflict detection, and rollback. These strategies are correct only under nontrivial assumptions that we identify and analyze. One important source of errors is that some efficient implementations create dangerous \u201czombie\u201d computations where a transaction keeps running after experiencing a conflict; the assumptions confine the effects of these computations.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mart\u00edn Abadi|Andrew Birrell|Tim Harris|Michael Isard|Mart\u00edn Abadi|Andrew Birrell|Tim Harris|Michael Isard|", "references": "", "organization": "Microsoft Research, Silicon Valley, University of California, Santa Cruz, and Coll\u00e8ge de France |Microsoft Research, Silicon Valley|Microsoft Research, Cambridge|Microsoft Research, Silicon Valley|Microsoft Research, Silicon Valley, University of California, Santa Cruz, and Coll\u00e8ge de France |Microsoft Research, Silicon Valley|Microsoft Research, Cambridge|Microsoft Research, Silicon Valley|", "title": ["Semantics of transactional memory and automatic mutual exclusion"]},
{"abstract": "This article relates two different paradigms of descriptions of communication behavior, one focusing on global message flows and another on end-point behaviors, using formal calculi based on session types. The global calculus, which originates from a Web service description language (W3C WS-CDL), describes an interaction scenario from a vantage viewpoint; the end-point calculus, an applied typed \n-calculus, precisely identifies a local behavior of each participant. We explore a theory of end-point projection, by which we can map a global description to its end-point counterparts preserving types and dynamics. Three principles of well-structured description and the type structures play a fundamental role in the theory.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Marco Carbone|Kohei Honda|Nobuko Yoshida|Marco Carbone|Kohei Honda|Nobuko Yoshida|", "references": "", "organization": "IT University of Copenhagen|Queen Mary, University of London|Imperial College London|IT University of Copenhagen|Queen Mary, University of London|Imperial College London|", "title": ["Structured Communication-Centered Programming for Web Services"]},
{"abstract": "Developing a theory of bisimulation in higher-order languages can be hard. Particularly challenging can be: (1) the proof of congruence, as well as enhancements of the bisimulation proof method with \u201cup-to context\u201d techniques, and (2) obtaining definitions and results that scale to languages with different features.\nTo meet these challenges, we present \n, a form of bisimulation for higher-order languages, and its basic theory. We consider four representative calculi: pure \u03bb-calculi (call-by-name and call-by-value), call-by-value \u03bb-calculus with higher-order store, and then Higher-Order \u03c0-calculus. In each case: we present the basic properties of environment bisimilarity, including congruence; we show that it coincides with contextual equivalence; we develop some up-to techniques, including up-to context, as examples of possible enhancements of the associated bisimulation method.\nUnlike previous approaches (such as applicative bisimulations, logical relations, Sumii-Pierce-Koutavas-Wand), our method does not require induction/indices on evaluation derivation/steps (which may complicate the proofs of congruence, transitivity, and the combination with up-to techniques), or sophisticated methods such as Howe's for proving congruence. It also scales from the pure \u03bb-calculi to the richer calculi with simple congruence proofs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Davide Sangiorgi|Naoki Kobayashi|Eijiro Sumii|Davide Sangiorgi|Naoki Kobayashi|Eijiro Sumii|", "references": "", "organization": "University of Bologna and INRIA|Tohoku University|Tohoku University|University of Bologna and INRIA|Tohoku University|Tohoku University|", "title": ["Environmental bisimulations for higher-order languages"]},
{"abstract": "Locksmith is a static analysis tool for automatically detecting data races in C programs. In this article, we describe each of Locksmith's component analyses precisely, and present systematic measurements that isolate interesting trade-offs between precision and efficiency in each analysis. Using a benchmark suite comprising stand-alone applications and Linux device drivers totaling more than 200,000 lines of code, we found that a simple no-worklist strategy yielded the most efficient interprocedural dataflow analysis; that our sharing analysis was able to determine that most locations are thread-local, and therefore need not be protected by locks; that modeling C structs and void pointers precisely is key to both precision and efficiency; and that context sensitivity yields a much more precise analysis, though with decreased scalability. Put together, our results illuminate some of the key engineering challenges in building Locksmith and data race detection analyses in particular, and constraint-based program analyses in general.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Polyvios Pratikakis|Jeffrey S. Foster|Michael Hicks|Polyvios Pratikakis|Jeffrey S. Foster|Michael Hicks|", "references": "", "organization": "University of Maryland|University of Maryland|University of Maryland|University of Maryland|University of Maryland|University of Maryland|", "title": ["LOCKSMITH: Practical static race detection for C"]},
{"abstract": "There are many powerful techniques for automated termination analysis of term rewriting. However, up to now they have hardly been used for real programming languages. We present a new approach which permits the application of existing techniques from term rewriting to prove termination of most functions defined in Haskell programs. In particular, we show how termination techniques for ordinary rewriting can be used to handle those features of Haskell which are missing in term rewriting (e.g., lazy evaluation, polymorphic types, and higher-order functions). We implemented our results in the termination prover AProVE and successfully evaluated them on existing Haskell libraries.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "J\u00fcrgen Giesl|Matthias Raffelsieper|Peter Schneider-Kamp|Stephan Swiderski|Ren\u00e9 Thiemann|J\u00fcrgen Giesl|Matthias Raffelsieper|Peter Schneider-Kamp|Stephan Swiderski|Ren\u00e9 Thiemann|", "references": "", "organization": "RWTH Aachen University, Aachen, Germany|TU Eindhoven, The Netherlands|University of Southern Denmark, Odense, M, Denmark|RWTH Aachen University, Aachen, Germany|University of Innsbruck, Innsbruck, Austria|RWTH Aachen University, Aachen, Germany|TU Eindhoven, The Netherlands|University of Southern Denmark, Odense, M, Denmark|RWTH Aachen University, Aachen, Germany|University of Innsbruck, Innsbruck, Austria|", "title": ["Automated termination proofs for haskell by term rewriting"]},
{"abstract": "Concurrent objects are inherently complex to verify. In the late 80s and early 90s, Herlihy and Wing proposed \n as a correctness condition for concurrent objects, which, once proven, allows us to reason about concurrent objects using pre- and postconditions only. A concurrent object is linearizable if all of its operations appear to take effect instantaneously some time between their invocation and return.\nIn this article we define simulation-based proof conditions for linearizability and apply them to two concurrent implementations, a lock-free stack and a set with lock-coupling. Similar to other approaches, we employ a theorem prover (here, KIV) to mechanize our proofs. Contrary to other approaches, we also use the prover to mechanically check that our proof obligations actually guarantee linearizability. This check employs the original ideas of Herlihy and Wing of verifying linearizability via \n.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "John Derrick|Gerhard Schellhorn|Heike Wehrheim|John Derrick|Gerhard Schellhorn|Heike Wehrheim|", "references": "", "organization": "University of Sheffield, Sheffield, UK|Institute for Software and Systems Engineering, Augsburg, Germany|Institut f\u00fcr Informatik, Paderborn, Germany|University of Sheffield, Sheffield, UK|Institute for Software and Systems Engineering, Augsburg, Germany|Institut f\u00fcr Informatik, Paderborn, Germany|", "title": ["Mechanically verified proof obligations for linearizability"]},
{"abstract": "Type constraints express subtype relationships between the types of program expressions, for example, those relationships that are required for type correctness. Type constraints were originally proposed as a convenient framework for solving type checking and type inference problems. This paper shows how type constraints can be used as the basis for practical refactoring tools. In our approach, a set of type constraints is derived from a type-correct program \n. The main insight behind our work is the fact that \n constitutes just one solution to this constraint system, and that alternative solutions may exist that correspond to refactored versions of \n. We show how a number of refactorings for manipulating types and class hierarchies can be expressed naturally using type constraints. Several refactorings in the standard distribution of Eclipse are based on our work.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Frank Tip|Robert M. Fuhrer|Adam Kie\u017cun|Michael D. Ernst|Ittai Balaban|Bjorn De Sutter|Frank Tip|Robert M. Fuhrer|Adam Kie\u017cun|Michael D. Ernst|Ittai Balaban|Bjorn De Sutter|", "references": "", "organization": "IBM T. J. Watson Research Center, Yorktown Heights, NY|IBM T. J. Watson Research Center, Yorktown Heights, NY|Brigham and Women's Hospital/Harvard Medical School, Boston, MA|University of Washington, Seattle WA|World Evolved Services, New York, NY|Ghent University and Vrije Universiteit Brussel, Gent, Belgium|IBM T. J. Watson Research Center, Yorktown Heights, NY|IBM T. J. Watson Research Center, Yorktown Heights, NY|Brigham and Women's Hospital/Harvard Medical School, Boston, MA|University of Washington, Seattle WA|World Evolved Services, New York, NY|Ghent University and Vrije Universiteit Brussel, Gent, Belgium|", "title": ["Refactoring using type constraints"]},
{"abstract": "We present MorphJ: a language for specifying general classes whose members are produced by iterating over members of other classes. We call this technique \u201cclass morphing\u201d or just \u201cmorphing.\u201d Morphing extends the notion of genericity so that not only types of methods and fields, but also the \n of a class can vary according to type variables. This adds a disciplined form of metaprogramming to mainstream languages and allows expressing common programming patterns in a highly generic way that is otherwise not supported by conventional techniques. For instance, morphing lets us write generic proxies (i.e., classes that can be parameterized with another class and export the same public methods as that class); default implementations (e.g., a generic do-nothing type, configurable for any interface); semantic extensions (e.g., specialized behavior for methods that declare a certain annotation); and more. MorphJ's hallmark feature is that, despite its emphasis on generality, it allows modular type-checking: a MorphJ class can be checked independently of its uses. Thus, the possibility of supplying a type parameter that will lead to invalid code is detected early, an invaluable feature for highly general components that will be statically instantiated by other programmers. We demonstrate the benefits of morphing with several examples, including a MorphJ reimplementation of DSTM2, a software transactional memory library which reduces 1,484 lines of Java reflection and bytecode engineering library calls to just 586 lines of MorphJ code.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Shan Shan Huang|Yannis Smaragdakis|Shan Shan Huang|Yannis Smaragdakis|", "references": "", "organization": "LogicBlox, Inc., Atlanta, GA|University of Massachusetts, Amherst, MA|LogicBlox, Inc., Atlanta, GA|University of Massachusetts, Amherst, MA|", "title": ["Morphing: Structurally shaping a class by reflecting on others"]},
{"abstract": "This article concerns mechanisms for maintaining the value of an instrumentation relation (also known as a \n or \n), defined via a logical formula over core relations, in response to changes in the values of the core relations. It presents an algorithm for transforming the instrumentation relation's defining formula into a \n that captures what the instrumentation relation's new value should be. The algorithm runs in time linear in the size of the defining formula.\nThe technique applies to program analysis problems in which the semantics of statements is expressed using logical formulas that describe changes to core relation values. It provides a way to obtain values of the instrumentation relations that reflect the changes in core relation values produced by executing a given statement.\nWe present experimental evidence that our technique is an effective one: for a variety of benchmarks, the relation-maintenance formulas produced automatically using our approach yield the same precision as the best available hand-crafted ones.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Thomas Reps|Mooly Sagiv|Alexey Loginov|Thomas Reps|Mooly Sagiv|Alexey Loginov|", "references": "", "organization": "University of Wisconsin and GrammaTech, Inc.|Tel Aviv University, Israel|GrammaTech, Inc.|University of Wisconsin and GrammaTech, Inc.|Tel Aviv University, Israel|GrammaTech, Inc.|", "title": ["Finite differencing of logical formulas for static analysis"]},
{"abstract": "A certificate is a mathematical object that can be used to establish that a piece of mobile code satisfies some security policy. In general, certificates cannot be generated automatically. There is thus an interest in developing methods to reuse certificates generated for source code to provide strong guarantees of the compiled code correctness. Certificate translation is a method to transform certificates of program correctness along semantically justified program transformations. These methods have been developed in previous work, but they were strongly dependent on particular programming and verification settings. This article provides a more general development in the setting of abstract interpretation, showing the scalability of certificate translation.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gilles Barthe|C\u00e9sar Kunz|Gilles Barthe|C\u00e9sar Kunz|", "references": "", "organization": "IMDEA Software Institute|IMDEA Software Institute and Universidad Polit\u00e9cnica de Madrid|IMDEA Software Institute|IMDEA Software Institute and Universidad Polit\u00e9cnica de Madrid|", "title": ["An Abstract Model of Certificate Translation"]},
{"abstract": "Since its introduction by Joseph A. Fisher in 1979, trace scheduling has influenced much of the work on compile-time ILP (Instruction Level Parallelism) transformations. Initially developed for use in microcode compaction, it quickly became the main technique for machine-level compile-time parallelism exploitation. Although it has been used since the 1980s in many state-of-the-art compilers (e.g., Intel, Fujitsu, HP), a rigorous theory of trace scheduling is still lacking in the existing literature. This is reflected in the ad hoc way compensation code is inserted after a trace compaction, in the total absence of any attempts to measure the size of that compensation code, and so on.\nThe aim of this article is to create a mathematical theory of the foundation of trace scheduling. We give a clear algorithm showing how to insert compensation code after a trace is replaced with its schedule, and then \n that the resulting program is indeed equivalent to the original program. We derive an upper bound on the size of that compensation code, and show that this bound can be actually attained. We also give a very simple proof that the trace scheduling algorithm always terminates.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Utpal Banerjee|Utpal Banerjee|", "references": "", "organization": "University of California, Irvine, CA|University of California, Irvine, CA|", "title": ["Mathematical foundation of trace scheduling"]},
{"abstract": "Compositional theories are crucial when designing large and complex systems from smaller components. In this work we propose such a theory for synchronous concurrent systems. Our approach follows so-called interface theories, which use game-theoretic interpretations of composition and refinement. These are appropriate for systems with distinct inputs and outputs, and explicit conditions on inputs that must be enforced during composition. Our interfaces model systems that execute in an infinite sequence of synchronous rounds. At each round, a contract must be satisfied. The contract is simply a relation specifying the set of valid input/output pairs. Interfaces can be composed by parallel, serial or feedback composition. A refinement relation between interfaces is defined, and shown to have two main properties: (1) it is preserved by composition, and (2) it is equivalent to substitutability, namely, the ability to replace an interface by another one in any context. Shared refinement and abstraction operators, corresponding to greatest lower and least upper bounds with respect to refinement, are also defined. Input-complete interfaces, that impose no restrictions on inputs, and deterministic interfaces, that produce a unique output for any legal input, are discussed as special cases, and an interesting duality between the two classes is exposed. A number of illustrative examples are provided, as well as algorithms to compute compositions, check refinement, and so on, for finite-state interfaces.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Stavros Tripakis|Ben Lickly|Thomas A. Henzinger|Edward A. Lee|Stavros Tripakis|Ben Lickly|Thomas A. Henzinger|Edward A. Lee|", "references": "", "organization": "University of California, Berkeley|University of California, Berkeley|Institute of Science and Technology, Austria|University of California, Berkeley|University of California, Berkeley|University of California, Berkeley|Institute of Science and Technology, Austria|University of California, Berkeley|", "title": ["A Theory of Synchronous Relational Interfaces"]},
{"abstract": "We present practical algorithms for computing exact least solutions of equation systems over the reals with addition, multiplication by positive constants, minimum and maximum. The algorithms are based on strategy iteration. Our algorithms can, for instance, be used for the analysis of recursive stochastic games. In the present article we apply our techniques for computing abstract least fixpoint semantics of affine programs over the relational template polyhedra domain. In particular, we thus obtain practical algorithms for computing abstract least fixpoint semantics over the abstract domains of intervals, zones, and octagons.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Thomas Martin Gawlitza|Helmut Seidl|Thomas Martin Gawlitza|Helmut Seidl|", "references": "", "organization": "VERIMAG, France|Technische Universit\u00e4t M\u00fcnchen, Germany|VERIMAG, France|Technische Universit\u00e4t M\u00fcnchen, Germany|", "title": ["Solving systems of rational equations through strategy iteration"]},
{"abstract": "Behavioral software contracts have become a popular mechanism for specifying and ensuring logical claims about a program's flow of values. While contracts for first-order functions come with a natural interpretation and are well understood, the various incarnations of higher-order contracts adopt, implicitly or explicitly, different views concerning the meaning of contract satisfaction. In this article, we define various notions of contract satisfaction in terms of observational equivalence and compare them with each other and notions in the literature. Specifically, we introduce a small model language with higher-order contracts and use it to formalize different notions of contract satisfaction. Each of them demands that the contract parties satisfy certain observational equivalences.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Christos Dimoulas|Matthias Felleisen|Christos Dimoulas|Matthias Felleisen|", "references": "", "organization": "Northeastern University, Boston, MA|Northeastern University, Boston, MA|Northeastern University, Boston, MA|Northeastern University, Boston, MA|", "title": ["On contract satisfaction in a higher-order world"]},
{"abstract": "In this article, we present a new shape analysis algorithm. The key distinguishing aspect of our algorithm is that it is completely compositional, bottom-up and noniterative. We present our algorithm as an inference system for computing Hoare triples summarizing heap manipulating programs. Our inference rules are compositional: Hoare triples for a compound statement are computed from the Hoare triples of its component statements. These inference rules are used as the basis for bottom-up shape analysis of programs.\nSpecifically, we present a Logic of Iterated Separation Formulae (LISF), which uses the iterated separating conjunct of Reynolds [2002] to represent program states. A key ingredient of our inference rules is a strong bi-abduction operation between two logical formulas. We describe sound strong bi-abduction and satisfiability procedures for LISF.\nWe have built a tool called S\nI\nE that implements these inference rules and have evaluated it on standard shape analysis benchmark programs. Our experiments show that S\nI\nE can generate expressive summaries, which are complete functional specifications in many cases.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bhargav S. Gulavani|Supratik Chakraborty|G. Ramalingam|Aditya V. Nori|Bhargav S. Gulavani|Supratik Chakraborty|G. Ramalingam|Aditya V. Nori|", "references": "", "organization": "IIT Bombay, India|IIT Bombay, India|Microsoft Research India, Bangalore, India|Microsoft Research India, Bangalore, India|IIT Bombay, India|IIT Bombay, India|Microsoft Research India, Bangalore, India|Microsoft Research India, Bangalore, India|", "title": ["Bottom-up shape analysis using LISF"]},
{"abstract": "A large body of data-flow analyses exists for analyzing and optimizing sequential code. Unfortunately, much of it cannot be directly applied on parallel code, for reasons of correctness. This article presents a technique to automatically, aggressively, yet safely apply sequentially-sound data-flow transformations, \n, on shared-memory programs. The technique is founded on the notion of program references being \u201csiloed\u201d on certain control-flow paths. Intuitively, siloed references are free of interference from other threads within the confines of such paths. Data-flow transformations can, in general, be unblocked on siloed references.\nThe solution has been implemented in a widely used compiler. Results on benchmarks from SPLASH-2 show that performance improvements of up to 41% are possible, with an average improvement of 6% across all the tested programs over all thread counts.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Pramod G. Joisha|Robert S. Schreiber|Prithviraj Banerjee|Hans-J. Boehm|Dhruva R. Chakrabarti|Pramod G. Joisha|Robert S. Schreiber|Prithviraj Banerjee|Hans-J. Boehm|Dhruva R. Chakrabarti|", "references": "", "organization": "Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|Hewlett-Packard Laboratories|", "title": ["On a Technique for Transparently Empowering Classical Compiler Optimizations on Multithreaded Code"]},
{"abstract": "The language JavaGI extends Java 1.5 conservatively by a generalized interface mechanism. The generalization subsumes retroactive and type-conditional interface implementations, binary methods, symmetric multiple dispatch, interfaces over families of types, and static interface methods. These features make certain coding patterns redundant, increase the expressiveness of the type system, and permit solutions to extension and integration problems with components in binary form, for which previously several unrelated extensions had been suggested.\nThis article explains JavaGI and motivates its design. Moreover, it formalizes a core calculus for JavaGI and proves type soundness, decidability of typechecking, and determinacy of evaluation. The article also presents the implementation of a JavaGI compiler and an accompanying run-time system. The compiler, based on the Eclipse Compiler for Java, offers mostly modular static typechecking and fully modular code generation. It defers certain well-formedness checks until load time to increase flexibility and to enable full support for dynamic loading. Benchmarks show that the code generated by the compiler offers good performance. Several case studies demonstrate the practical utility of the language and its implementation.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Stefan Wehr|Peter Thiemann|Stefan Wehr|Peter Thiemann|", "references": "", "organization": "factis research GmbH|University of Freiburg|factis research GmbH|University of Freiburg|", "title": ["JavaGI: The Interaction of Type Classes with Interfaces and Inheritance"]},
{"abstract": "While model checking of pushdown systems is by now an established technique in software verification, temporal logics and automata traditionally used in this area are unattractive on two counts. First, logics and automata traditionally used in model checking cannot express requirements such as pre/post-conditions that are basic to analysis of software. Second, unlike in the finite-state world, where the \u03bc-calculus has a symbolic model-checking algorithm and serves as an \u201cassembly language\u201d to which temporal logics can be compiled, there is no common formalism\u2014either fixpoint-based or automata-theoretic\u2014to model-check requirements on pushdown models. In this article, we introduce a new theory of temporal logics and automata that addresses the above issues, and provides a unified foundation for the verification of pushdown systems.\nThe key idea here is to view a program as a generator of structures known as \n as opposed to trees. A fixpoint logic (called N\n-\u03bc) and a class of automata (called \n) interpreted on languages of these structures are now defined, and branching-time model-checking is phrased as language inclusion and membership problems for these languages. We show that N\n-\u03bc and nested tree automata allow the specification of a new frontier of requirements usable in software verification. At the same time, their model checking problem has the same worst-case complexity as their traditional analogs, and can be solved symbolically using a fixpoint computation that generalizes, and includes as a special case, \u201csummary\u201d-based computations traditionally used in interprocedural program analysis. We also show that our logics and automata define a robust class of languages\u2014in particular, just as the \u03bc-calculus is equivalent to alternating parity automata on trees, NT-\u03bc is equivalent to alternating parity automata on nested trees.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Rajeev Alur|Swarat Chaudhuri|P. Madhusudan|Rajeev Alur|Swarat Chaudhuri|P. Madhusudan|", "references": "", "organization": "University of Pennsylvania, Philadelphia, PA|Rice University, Houston, TX|University of Illinois, Champaign, IL|University of Pennsylvania, Philadelphia, PA|Rice University, Houston, TX|University of Illinois, Champaign, IL|", "title": ["Software model checking using languages of nested trees"]},
{"abstract": "We propose a small-step operational semantics to support reasoning about Web applications written in the multitier language HOP. The semantics covers both server side and client side computations, as well as their interactions, and includes creation of Web services, distributed client-server communications, concurrent evaluation of service requests at server side, elaboration of HTML documents, DOM operations, evaluation of script nodes in HTML documents and actions from HTML pages at client side. We also model the browser same origin policy (SOP) in the semantics. We propose a safety property by which programs do not get stuck due to a violation of the SOP and a type system to enforce it.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "G\u00e9rard Boudol|Zhengqin Luo|Tamara Rezk|Manuel Serrano|G\u00e9rard Boudol|Zhengqin Luo|Tamara Rezk|Manuel Serrano|", "references": "", "organization": "INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|INRIA Sophia Antipolis-Mediterran\u00e9e|", "title": ["Reasoning about Web Applications: An Operational Semantics for HOP"]},
{"abstract": "Aspect-oriented programming (AOP) has produced interesting language designs, but also ad hoc semantics that needs clarification. We contribute to this clarification with a calculus that models essential AOP, both simpler and more general than existing formalizations. In AOP, \n may intercept method invocations, and \n executes the suspended call. Proceed is an ad hoc mechanism, only usable inside advice bodies. Many pointcut mechanisms, for example, wildcards, also lack regularity. We model proceed using first-class closures, and shift complexity from pointcuts to ordinary object-oriented code. Two well-known pointcut categories, \n and \n, are commonly considered similar. We formally expose their differences, and resolve the associated soundness problem. Our calculus includes \n, an intuitive and concise alternative to explicit type variables that allows advice to be polymorphic over intercepted methods. We use calculus parameters to cover type safety for a wide design space of other features. Type soundness is verified in Coq.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bruno De Fraine|Erik Ernst|Mario S\u00fcdholt|Bruno De Fraine|Erik Ernst|Mario S\u00fcdholt|", "references": "", "organization": "Vrije Universiteit Brussel, Brussel, Belgium|Aarhus Universitet, Aarus C Denmark|\u00c9cole des Mines de Nantes, Nantes cedex 3 France|Vrije Universiteit Brussel, Brussel, Belgium|Aarhus Universitet, Aarus C Denmark|\u00c9cole des Mines de Nantes, Nantes cedex 3 France|", "title": ["Essential AOP: The a calculus"]},
{"abstract": "In this article we study the decidability of termination of several variants of simple integer loops, without branching in the loop body and with affine constraints as the loop guard (and possibly a precondition). We show that termination of such loops is undecidable in some cases, in particular, when the body of the loop is expressed by a set of linear inequalities where the coefficients are from Z \u222a {\n} with \n an arbitrary irrational; when the loop is a sequence of instructions, that compute either linear expressions or the step function; and when the loop body is a piecewise linear deterministic update with two pieces. The undecidability result is proven by a reduction from counter programs, whose termination is known to be undecidable. For the common case of integer linear-constraint loops with rational coefficients we have not succeeded in proving either decidability or undecidability of termination, but we show that a Petri net can be simulated with such a loop; this implies some interesting lower bounds. For example, termination for a partially specified input is at least EXPSPACE-hard.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Amir M. Ben-Amram|Samir Genaim|Abu Naser Masud|Amir M. Ben-Amram|Samir Genaim|Abu Naser Masud|", "references": "", "organization": "The Academic College of Tel-Aviv Yaffo|Complutense University of Madrid|Technical University of Madrid|The Academic College of Tel-Aviv Yaffo|Complutense University of Madrid|Technical University of Madrid|", "title": ["On the Termination of Integer Loops"]},
{"abstract": "We present the design and implementation of a typechecker for verifying security properties of the source code of cryptographic protocols and access control mechanisms. The underlying type theory is a \u03bb-calculus equipped with refinement types for expressing pre- and post-conditions within first-order logic. We derive formal cryptographic primitives and represent active adversaries within the type theory. Well-typed programs enjoy assertion-based security properties, with respect to a realistic threat model including key compromise. The implementation amounts to an enhanced typechecker for the general-purpose functional language F\n; typechecking generates verification conditions that are passed to an SMT solver. We describe a series of checked examples. This is the first tool to verify authentication properties of cryptographic protocols by typechecking their source code.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jesper Bengtson|Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|Sergio Maffeis|Jesper Bengtson|Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|Sergio Maffeis|", "references": "", "organization": "Uppsala University, Uppsala, Sweden|Microsoft Research, United Kingdom|Microsoft Research, United Kingdom|Microsoft Research, United Kingdom|Imperial College London, London, United Kingdom|Uppsala University, Uppsala, Sweden|Microsoft Research, United Kingdom|Microsoft Research, United Kingdom|Microsoft Research, United Kingdom|Imperial College London, London, United Kingdom|", "title": ["Refinement types for secure implementations"]},
{"abstract": "Writing low-level concurrent software has traditionally required intimate knowledge of the entire toolchain and often has involved coding in assembly. New language standards have extended C and C++ with support for low-level atomic operations and a weak memory model, enabling developers to write portable and efficient multithreaded code.\nIn this article, we present CDSC\n, a tool for exhaustively exploring the behaviors of concurrent code under the C/C++ memory model. We have used CDSC\n to exhaustively unit test concurrent data structure implementations and have discovered errors in a published implementation of a work-stealing queue and a single producer, single consumer queue.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Brian Norris|Brian Demsky|Brian Norris|Brian Demsky|", "references": "", "organization": "University of California, Irvine|University of California, Irvine|University of California, Irvine|University of California, Irvine|", "title": ["A Practical Approach for Model Checking C/C++11 Code"]},
{"abstract": "ML modules provide hierarchical namespace management, as well as fine-grained control over the propagation of type information, but they do not allow modules to be broken up into mutually recursive, separately compilable components. Mixin modules facilitate recursive linking of separately compiled components, but they are not hierarchically composable and typically do not support type abstraction. We synthesize the complementary advantages of these two mechanisms in a novel module system design we call MixML.\nA MixML module is like an ML structure in which some of the components are specified but not defined. In other words, it unifies the ML structure and signature languages into one. MixML seamlessly integrates hierarchical composition, translucent ML-style data abstraction, and mixin-style recursive linking. Moreover, the design of MixML is clean and minimalist; it emphasizes how all the salient, semantically interesting features of the ML module system (and several proposed extensions to it) can be understood simply as stylized uses of a small set of orthogonal underlying constructs, with mixin composition playing a central role.\nWe provide a declarative type system for MixML, including two important extensions: higher-order modules, and modules as first-class values. We also present a sound and complete, three-pass type-checking algorithm for this system. The operational semantics of MixML is defined by an elaboration translation into an internal core language called LTG---namely, a polymorphic lambda calculus with single-assignment references and recursive type generativity---which employs a linear type and kind system to track definedness of term and type imports.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Andreas Rossberg|Derek Dreyer|Andreas Rossberg|Derek Dreyer|", "references": "", "organization": "Google|Max Planck Institute for Software Systems (MPI-SWS)|Google|Max Planck Institute for Software Systems (MPI-SWS)|", "title": ["Mixin\u2019 Up the ML Module System"]},
{"abstract": "An unsound claim can misdirect a field, encouraging the pursuit of unworthy ideas and the abandonment of promising ideas. An inadequate description of a claim can make it difficult to reason about the claim, for example, to determine whether the claim is sound. Many practitioners will acknowledge the threat of unsound claims or inadequate descriptions of claims to their field. We believe that this situation is exacerbated, and even encouraged, by the lack of a systematic approach to exploring, exposing, and addressing the source of unsound claims and poor exposition.\nThis article proposes a framework that identifies three sins of reasoning that lead to unsound claims and two sins of exposition that lead to poorly described claims and evaluations. Sins of exposition obfuscate the objective of determining whether or not a claim is sound, while sins of reasoning lead directly to unsound claims.\nOur framework provides practitioners with a principled way of critiquing the integrity of their own work and the work of others. We hope that this will help individuals conduct better science and encourage a cultural shift in our research community to identify and promulgate sound claims.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Stephen M. Blackburn|Amer Diwan|Matthias Hauswirth|Peter F. Sweeney|Jos\u00e9 Nelson Amaral|Tim Brecht|Lubom\u00edr Bulej|Cliff Click|Lieven Eeckhout|Sebastian Fischmeister|Daniel Frampton|Laurie J. Hendren|Michael Hind|Antony L. Hosking|Richard E. Jones|Tomas Kalibera|Nathan Keynes|Nathaniel Nystrom|Andreas Zeller|Stephen M. Blackburn|Amer Diwan|Matthias Hauswirth|Peter F. Sweeney|Jos\u00e9 Nelson Amaral|Tim Brecht|Lubom\u00edr Bulej|Cliff Click|Lieven Eeckhout|Sebastian Fischmeister|Daniel Frampton|Laurie J. Hendren|Michael Hind|Antony L. Hosking|Richard E. Jones|Tomas Kalibera|Nathan Keynes|Nathaniel Nystrom|Andreas Zeller|", "references": "", "organization": "Australian National University, ACT, Australia|Google|Universit\u00e0 della Svizzera italiana, Lugano, Switzerland|IBM Research, New York, USA|University of Alberta, Alberta, Canada|University of Waterloo, Waterloo, Ontario, Canada|Charles University, Czech Republic|Azul, H2O, Neurensic|Ghent University, Zwijnaarde, Belgium|University of Waterloo, Waterloo, Ontario, Canada|Microsoft, Redmond, WA, USA|McGill University, Montreal, Quebec, Canada|IBM Research, NY, USA|Australian National University, Data61, Purdue University, ACT, Australia|University of Kent, UK|University of Kent, UK|Oracle, Brisbane, Australia|Universit\u00e0 della Svizzera italiana, Lugano, Switzerland|Saarland University, Saarbr\u00fccken Germany|Australian National University, ACT, Australia|Google|Universit\u00e0 della Svizzera italiana, Lugano, Switzerland|IBM Research, New York, USA|University of Alberta, Alberta, Canada|University of Waterloo, Waterloo, Ontario, Canada|Charles University, Czech Republic|Azul, H2O, Neurensic|Ghent University, Zwijnaarde, Belgium|University of Waterloo, Waterloo, Ontario, Canada|Microsoft, Redmond, WA, USA|McGill University, Montreal, Quebec, Canada|IBM Research, NY, USA|Australian National University, Data61, Purdue University, ACT, Australia|University of Kent, UK|University of Kent, UK|Oracle, Brisbane, Australia|Universit\u00e0 della Svizzera italiana, Lugano, Switzerland|Saarland University, Saarbr\u00fccken Germany|", "title": ["The Truth, The Whole Truth, and Nothing But the Truth: A Pragmatic Guide to Assessing Empirical Evaluations"]},
{"abstract": "Manifest contracts track precise program properties by refining types with predicates\u2014for example, {\n:Int\u2223 \n > 0} denotes the positive integers. Contracts and polymorphism make a natural combination: programmers can give strong contracts to abstract types, precisely stating pre- and post conditions while hiding implementation details\u2014 for instance, an abstract type of stacks might specify that the pop operation has input type {\n:\u03b1 Stack \u2223 not (empty \n)}.\nThis article studies a polymorphic calculus with manifest contracts and establishes fundamental properties including type soundness and relational parametricity. Indeed, this is not the first work on polymorphic manifest contracts, but existing calculi are not very satisfactory. Gronski et al. developed the S\n language, which introduces polymorphism through the Type:Type discipline, but they do not study parametricity. Some authors of this article have produced two separate works: Belo et al. [2011] and Greenberg [2013] studied polymorphic manifest contracts and parametricity, but their calculi have metatheoretical problems in the type conversion relations. Indeed, they depend on a few conjectures, which turn out to be false. Our calculus is the first polymorphic manifest calculus with parametricity, depending on no conjectures\u2014it resolves the issues in prior calculi with delayed substitution on casts.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Taro Sekiyama|Atsushi Igarashi|Michael Greenberg|Taro Sekiyama|Atsushi Igarashi|Michael Greenberg|", "references": "", "organization": "Kyoto University|Kyoto University, Kyoto, Japan|Pomona College, CA, USA|Kyoto University|Kyoto University, Kyoto, Japan|Pomona College, CA, USA|", "title": ["Polymorphic Manifest Contracts, Revised and Resolved"]},
{"abstract": "Quantum cryptographic systems have been commercially available, with a striking advantage over classical systems that their security and ability to detect the presence of eavesdropping are provable based on the principles of quantum mechanics. On the other hand, quantum protocol designers may commit more faults than classical protocol designers since human intuition is poorly adapted to the quantum world. To offer formal techniques for modeling and verification of quantum protocols, several quantum extensions of process algebra have been proposed. An important issue in quantum process algebra is to discover a quantum generalization of bisimulation preserved by various process constructs, in particular, parallel composition, where one of the major differences between classical and quantum systems, namely quantum entanglement, is present. Quite a few versions of bisimulation have been defined for quantum processes in the literature, but in the best case they are only proved to be preserved by parallel composition of purely quantum processes where no classical communication is involved.\nMany quantum cryptographic protocols, however, employ the LOCC (Local Operations and Classical Communication) scheme, where classical communication must be explicitly specified. So, a notion of bisimulation preserved by parallel composition in the circumstance of both classical and quantum communication is crucial for process algebra approach to verification of quantum cryptographic protocols. In this article we introduce novel notions of strong bisimulation and weak bisimulation for quantum processes, and prove that they are congruent with respect to various process algebra combinators including parallel composition even when both classical and quantum communication are present. We also establish some basic algebraic laws for these bisimulations. In particular, we show the uniqueness of the solutions to recursive equations of quantum processes, which proves useful in verifying complex quantum protocols. To capture the idea that a quantum process approximately implements its specification, and provide techniques and tools for approximate reasoning, a quantified version of strong bisimulation, which defines for each pair of quantum processes a bisimulation-based distance characterizing the extent to which they are strongly bisimilar, is also introduced.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Yuan Feng|Runyao Duan|Mingsheng Ying|Yuan Feng|Runyao Duan|Mingsheng Ying|", "references": "", "organization": "University of Technology, Sydney, Australia, and Tsinghua University, China|University of Technology, Sydney, Australia, and Tsinghua University, China|University of Technology, Sydney, Australia, and Tsinghua University, China|University of Technology, Sydney, Australia, and Tsinghua University, China|University of Technology, Sydney, Australia, and Tsinghua University, China|University of Technology, Sydney, Australia, and Tsinghua University, China|", "title": ["Bisimulation for Quantum Processes"]},
{"abstract": "Compaction of a managed heap is a costly operation to be avoided as much as possible in commercial runtimes. Instead, partial compaction is often used to defragment parts of the heap and avoid space blowup. Previous study of compaction limitation provided some initial asymptotic bounds but no implications for practical systems. In this work, we extend the theory to obtain better bounds and make them strong enough to become meaningful for modern systems.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Nachshon Cohen|Erez Petrank|Nachshon Cohen|Erez Petrank|", "references": "", "organization": "Technion Institute of Technology, Haifa, Israel|Technion Institute of Technology, Haifa, Israel|Technion Institute of Technology, Haifa, Israel|Technion Institute of Technology, Haifa, Israel|", "title": ["Limitations of Partial Compaction: Towards Practical Bounds"]},
{"abstract": "Well-known techniques exist for proving the soundness of subtyping relations with respect to type safety. However, completeness has not been treated with widely applicable techniques, as far as we\u2019re aware.\nThis article develops techniques for stating and proving that a subtyping relation is complete with respect to type safety and applies the techniques to the study of iso-recursive subtyping. A new proof technique, induction on failing derivations, is provided that may be useful in other domains as well.\nThe common subtyping rules for iso-recursive types\u2014the \u201cAmber rules\u201d\u2014are shown to be incomplete with respect to type safety. That is, there exist iso-recursive types \u03c4\n and \u03c4\n such that \u03c4\n can safely be considered a subtype of \u03c4\n, but \u03c4\n \u2a7d \u03c4\n is not derivable with the Amber rules.\nNew, algorithmic rules are defined for subtyping iso-recursive types, and the rules are proved sound and complete with respect to type safety. The fully implemented subtyping algorithm is optimized to run in \n(\n) time, where \n is the number of \u03bc-terms in the types being considered and \n is the size of the types being considered.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jay Ligatti|Jeremy Blackburn|Michael Nachtigal|Jay Ligatti|Jeremy Blackburn|Michael Nachtigal|", "references": "Roberto M. Amadio and Luca Cardelli. 1993. Subtyping recursive types. ACM Transactions on Programming Languages and Systems (TOPLAS) 15, 4 (1993), 575--631.  |Michael Backes, C\u0103t\u0103lin Hri\u0163cu, and Matteo Maffei. 2011. Union and intersection types for secure protocol implementations. In Proceedings of Theory of Security and Applications (TOSCA\u201911).  |Henk Barendregt, Mario Coppo, and Mariangiola Dezani-Ciancaglini. 1983. A filter lambda model and the completeness of type assignment. Journal of Symbolic Logic 48, 4 (Dec. 1983), 931--940.|Jesper Bengtson, Karthikeyan Bhargavan, C\u00e9dric Fournet, Andrew D. Gordon, and Sergio Maffeis. 2011. Refinement types for secure implementations. ACM Transactions on Programming Languages and Systems (TOPLAS) 33, 2 (2011), 8.  |Michael Brandt and Fritz Henglein. 1998. Coinductive axiomatization of recursive type equality and subtyping. Fundamenta Informaticae 33, 4 (1998), 309--338. |Luca Cardelli. 1986. Amber. In Proceedings of Combinators and Functional Programming Languages: Thirteenth Spring School of the LITP. 21--47. |Dario Colazzo and Giorgio Ghelli. 2005. Subtyping, recursion and parametric polymorphism in kernel fun. Information and Computation 198, 2 (2005), 71--147.  |William R. Cook, Walter L. Hill, and Peter S. Canning. 1989. Inheritance is not subtyping. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201989). 125--135.  |Mariangiola Dezani-Ciancaglini and Silvia Ghilezan. 2014. Preciseness of subtyping on intersection and union types. In Proceedings of Rewriting and Typed Lambda Calculi (RTA-TLCA\u201914), Gilles Dowek (Ed.). Lecture Notes in Computer Science, Vol. 8560. Springer International Publishing, 194--207.|Alain Frisch. 2004. Th\u00e9orie, Conception Et R\u00e9alisation D\u2019un Langage De Programmation Fonctionnel Adapt\u00e9 \u00e0 XML. Ph.D. Dissertation. Universit\u00e9 Paris 7.|Alain Frisch, Giuseppe Castagna, and V\u00e9ronique Benzaken. 2008. Semantic subtyping: Dealing set-theoretically with function, union, intersection, and negation types. Journal of the ACM 55, 4 (Sept. 2008), 19:1--19:64.  |Vladimir Gapeyev, Michael Y. Levin, and Benjamin C. Pierce. 2002. Recursive subtyping revealed. Journal of Functional Programming 12, 6 (2002), 511--548.  |Nadji Gauthier and Fran\u00e7ois Pottier. 2004. Numbering matters: First-order canonical forms for second-order recursive types. ACM SIGPLAN Notices 39, 9 (2004), 150--161.  |Robert Harper. 2013. Practical Foundations for Programming Languages. Retrieved from http://www.cs.cmu.edu/&sim;rwh/plbook/ Version 1.33 of 05.07.2013, Working Draft. |Haruo Hosoya, Benjamin C. Pierce, and David N. Turner. 1998. Datatypes and Subtyping. Manuscript.|Haruo Hosoya, J\u00e9r\u00f4me Vouillon, and Benjamin C. Pierce. 2005. Regular expression types for XML. ACM Transactions on Programming Languages and Systems 27, 1 (Jan. 2005), 46--90.  |Hyeonseung Im, Keiko Nakata, and Sungwoo Park. 2013. Contractive signatures with recursive types, type parameters, and abstract types. In Proceedings of International Colloquium on Automata, Languages and Programming (ICALP\u201913).  |Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. 1995. Efficient recursive subtyping. Mathematical Structures in Computer Science 5, 1 (1995), 113--125.|Christopher League and Zhong Shao. 1998. Formal Semantics of the FLINT Intermediate Language. Technical Report Yale-CS-TR-1171. Yale University.|Jay Ligatti. 2016a. Induction on Failing Derivations. Technical Report PL-Sep13. Univ. of South Florida. http://www.cse.usf.edu/&sim;ligatti/papers/iotFdoJ.pdf.|Jay Ligatti. 2016b. Subtyping-Algorithm Implementation. http://www.cse.usf.edu/&sim;ligatti/projects/completeness/sub.sml. (Feb. 2016).|Barbara H. Liskov and Jeanette M. Wing. 1994. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems (TOPLAS) 16 (1994), 1811--1841.  |David MacQueen, Gordon Plotkin, and Ravi Sethi. 1984. An ideal model for recursive polymorphic types. In Proceedings of the Symposium on Principles of Programming Languages (POPL\u201984). ACM, 165--174.  |Benjamin C. Pierce. 1991. Programming with Intersection Types and Bounded Polymorphism. Ph.D. Dissertation. Carnegie Mellon University. |Benjamin C. Pierce. 2002. Types and Programming Languages. MIT Press. |Cees Pierik and Frank S. De Boer. 2005. On behavioral subtyping and completeness. In Proceedings of the 7th Workshop on Formal Techniques for Java-like Programs.|Gordon D. Plotkin. 2004. A structural approach to operational semantics. Journal of Logic and Algebraic Programming 60--61 (2004), 17--139.|Tatsurou Sekiguchi and Akinori Yonezawa. 1994. A complete type inference system for subtyped recursive types. In Proceedings of Theoretical Aspects of Computer Software (TACS\u201994). 667--686. |Anthony J. H. Simons. 1994. Adding Axioms to Cardelli-Wegner Subtyping. Technical Report CS-94-6. University of Sheffield.|Anthony J. H. Simons. 2002. The theory of classification, part 4: Object types and subtyping. Journal of Object Technology 1, 5 (2002), 27--35.|Christopher A. Stone and Andrew P. Schoonmaker. 2005. Equational theories with recursive types. (2005). http://www.cs.hmc.edu/&sim;stone/papers/stone-schoonmaker-long.pdf.|Ross Tate, Alan Leung, and Sorin Lerner. 2011. Taming wildcards in Java\u2019s type system. In Proceedings of the 2011 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201911).  |Steffen van Bakel, Mariangiola Dezani-Ciancaglini, Ugo de'Liguoro, and Yoko Motohama. 2000. The Minimal Relevant Logic and the Call-by-Value Lambda Calculus. Technical Report TR-ARP-05-2000. The Australian National University.|Joseph C. Vanderwaart, Derek Dreyer, Leaf Petersen, Karl Crary, Robert Harper, and Perry Cheng. 2003. Typed compilation of recursive datatypes. In Proceedings of the ACM SIGPLAN International Workshop on Types in Languages Design and Implementation (TLDI\u201903).  |J\u00e9r\u00f4me Vouillon. 2004. Subtyping union types. In Proceedings of the 18th International Workshop on Computer Science Logic.|J\u00e9r\u00f4me Vouillon. 2006. Polymorphic regular tree types and patterns. In Proceedings of the Symposium on Principles of Programming Languages (POPL\u201906). ACM, 103--114.  |", "organization": "University of South Florida|Telefonica Research|University of South Florida|University of South Florida|Telefonica Research|University of South Florida|", "title": ["On Subtyping-Relation Completeness, with an Application to Iso-Recursive Types"]},
{"abstract": "Big data is revolutionizing how all sectors of our economy do business, including telecommunication, transportation, medical, and finance. Big data comes in two flavors: data at rest and data in motion. Processing data in motion is \n. Stream processing for big data analytics often requires scale that can only be delivered by a distributed system, exploiting parallelism on many hosts and many cores. One such distributed stream processing system is IBM Streams. Early customer experience with IBM Streams uncovered that another core requirement is extensibility, since customers want to build high-performance domain-specific operators for use in their streaming applications. Based on these two core requirements of distribution and extensibility, we designed and implemented the Streams Processing Language (SPL). This article describes SPL with an emphasis on the language design, distributed runtime, and extensibility mechanism. SPL is now the gateway for the IBM Streams platform, used by our customers for stream processing in a broad range of application domains.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Martin Hirzel|Scott Schneider|Bu\u011fra Gedik|Martin Hirzel|Scott Schneider|Bu\u011fra Gedik|", "references": "", "organization": "IBM Thomas J. Watson Research Center, Yorktown Heights, NY|IBM Thomas J. Watson Research Center, Yorktown Heights, NY|Bilkent University, Ankara, Turkey|IBM Thomas J. Watson Research Center, Yorktown Heights, NY|IBM Thomas J. Watson Research Center, Yorktown Heights, NY|Bilkent University, Ankara, Turkey|", "title": ["SPL: An Extensible Language for Distributed Stream Processing"]},
{"abstract": "Program analyses often utilize various forms of \n such as context sensitivity, call-site sensitivity, and object sensitivity. These techniques all allow for more precise program analyses, that are able to compute more precise program invariants, and to verify stronger properties. Despite the fact that sensitivity techniques are now part of the standard toolkit of static analyses designers and implementers, no comprehensive frameworks allow the description of all common forms of sensitivity. As a consequence, the soundness proofs of static analysis tools involving sensitivity often rely on ad hoc formalization, which are not always carried out in an abstract interpretation framework. Moreover, this also means that opportunities to identify similarities between analysis techniques to better improve abstractions or to tune static analysis tools can easily be missed.\nIn this article, we present and formalize a framework for the description of \n. Our framework is based on a powerful abstract domain construction, and utilizes reduced cardinal power to tie basic abstract predicates to the properties analyses are sensitive to. We formalize this abstraction, and the main abstract operations that are needed to turn it into a generic abstract domain construction. We demonstrate that our approach can allow for a more precise description of program states, and that it can also describe a large set of sensitivity techniques, both when sensitivity criteria are static (known before the analysis) or dynamic (inferred as part of the analysis), and sensitive analysis tuning parameters. Last, we show that sensitivity techniques used in state-of-the-art static analysis tools can be described in our framework.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Se-Won Kim|Xavier Rival|Sukyoung Ryu|Se-Won Kim|Xavier Rival|Sukyoung Ryu|", "references": "", "organization": "S-Core|CNRS, ENS, INRIA Paris-Rocquencourt, PSL* University|KAIST, Yuseong-gu, Republic of Korea|S-Core|CNRS, ENS, INRIA Paris-Rocquencourt, PSL* University|KAIST, Yuseong-gu, Republic of Korea|", "title": ["A Theoretical Foundation of Sensitivity in an Abstract Interpretation Framework"]},
{"abstract": "Designers often apply manual or semi-automatic loop and data transformations on array- and loop-intensive programs to improve performance. It is crucial that such transformations preserve the functionality of the program. This article presents an automatic method for constructing equivalence proofs for the class of static affine programs. The equivalence checking is performed on a dependence graph abstraction and uses a new approach based on widening to find the proper induction hypotheses for reasoning about recurrences. Unlike transitive-closure-based approaches, this widening approach can also handle nonuniform recurrences. The implementation is publicly available and is the first of its kind to fully support commutative operations.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sven Verdoolaege|Gerda Janssens|Maurice Bruynooghe|Sven Verdoolaege|Gerda Janssens|Maurice Bruynooghe|", "references": "", "organization": "Katholieke Universiteit Leuven, Belgium|Katholieke Universiteit Leuven, Belgium|Katholieke Universiteit Leuven, Belgium|Katholieke Universiteit Leuven, Belgium|Katholieke Universiteit Leuven, Belgium|Katholieke Universiteit Leuven, Belgium|", "title": ["Equivalence checking of static affine programs using widening to handle recurrences"]},
{"abstract": "Constructing a high-performance garbage collector is hard. Constructing a fully concurrent \u2018on-the-fly\u2019 compacting collector is much more so. We describe our experience of implementing the Sapphire algorithm as the first on-the-fly, parallel, replication copying, garbage collector for the Jikes RVM Java virtual machine (JVM). In part, we explain our innovations such as copying with hardware and software transactions, on-the-fly management of Java\u2019s reference types, and simple, yet correct, lock-free management of volatile fields in a replicating collector. We fully evaluate, for the first time, and using realistic benchmarks, Sapphire\u2019s performance and suitability as a low latency collector. An important contribution of this work is a detailed description of our experience of building an on-the-fly copying collector for a complete JVM with some assurance that it is correct. A key aspect of this is model checking of critical components of this complicated and highly concurrent system.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tomoharu Ugawa|Carl G. Ritson|Richard E. Jones|Tomoharu Ugawa|Carl G. Ritson|Richard E. Jones|", "references": "", "organization": "Kochi University of Technology, Kochi, Japan|University of Kent, Canterbury, UK|University of Kent, Canterbury, UK|Kochi University of Technology, Kochi, Japan|University of Kent, Canterbury, UK|University of Kent, Canterbury, UK|", "title": ["Transactional Sapphire: Lessons in High-Performance, On-the-fly Garbage Collection"]},
{"abstract": "Building a cost-effective static analyzer for real-world programs is still regarded an art. One key contributor to this grim reputation is the difficulty in balancing the cost and the precision of an analyzer. An ideal analyzer should be adaptive to a given analysis task and avoid using techniques that unnecessarily improve precision and increase analysis cost. However, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts.\nIn this article, we present a new learning-based approach for adaptive static analysis. In our approach, the analysis includes a sophisticated parameterized strategy that decides, for each part of a given program, whether to apply a precision-improving technique to that part or not. We present a method for learning a good parameter for such a strategy from an existing codebase via Bayesian optimization. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow- and context-sensitive variants of a realistic C static analyzer. The experimental results demonstrate that using Bayesian optimization is crucial for learning from an existing codebase. Also, they show that among all program queries that require flow- or context-sensitivity, our partially flow- and context-sensitive analysis answers 75% of them, while increasing the analysis cost only by 3.3\u00d7 of the baseline flow- and context-insensitive analysis, rather than 40\u00d7 or more of the fully sensitive version.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Kihong Heo|Hakjoo Oh|Hongseok Yang|Kwangkeun Yi|Kihong Heo|Hakjoo Oh|Hongseok Yang|Kwangkeun Yi|", "references": "", "organization": "Seoul National University|Korea University, Korea|University of Oxford|Seoul National University|Seoul National University|Korea University, Korea|University of Oxford|Seoul National University|", "title": ["Adaptive Static Analysis via Learning with Bayesian Optimization"]},
{"abstract": "We present Armus, a verification tool for dynamically detecting or avoiding barrier deadlocks. The core design of Armus is based on phasers, a generalisation of barriers that supports split-phase synchronisation, dynamic membership, and optional-waits. This allows Armus to handle the key barrier synchronisation patterns found in modern languages and libraries. We implement Armus for X10 and Java, giving the first sound and complete barrier deadlock verification tools in these settings.\nArmus introduces a novel event-based graph model of barrier concurrency constraints that distinguishes task-event and event-task dependencies. Decoupling these two kinds of dependencies facilitates the verification of distributed barriers with dynamic membership, a challenging feature of X10. Further, our base graph representation can be dynamically switched between a task-to-task model, Wait-for Graph (WFG), and an event-to-event model, State Graph (SG), to improve the scalability of the analysis.\nFormally, we show that the verification is sound and complete with respect to the occurrence of deadlock in our core phaser language, and that switching graph representations preserves the soundness and completeness properties. These results are machine checked with the Coq proof assistant. Practically, we evaluate the runtime overhead of our implementations using three benchmark suites in local and distributed scenarios. Regarding deadlock detection, distributed scenarios show negligible overheads and local scenarios show overheads below\u00a01.15\u00d7. Deadlock avoidance is more demanding, and highlights the potential gains from dynamic graph selection. In one benchmark scenario, the runtime overheads vary from 1.8\u00d7 for dynamic selection, 2.6\u00d7 for SG-static selection, and 5.9\u00d7 for WFG-static selection.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tiago Cogumbreiro|Raymond Hu|Francisco Martins|Nobuko Yoshida|Tiago Cogumbreiro|Raymond Hu|Francisco Martins|Nobuko Yoshida|", "references": "Shivali Agarwal, Rajkishore Barik, Vivek Sarkar, and Rudrapatna K. Shyamasundar. 2007. May-happen-in-parallel analysis of X10 programs. In PPoPP. ACM, 183--193.  |Daniel Atkins, Alex Potanin, and Lindsay Groves. 2013. The design and implementation of clocked variables in X10. In ACSC (CRPIT), Vol. 135. ACS, 87--95. http://crpit.com/abstracts/CRPITV135Atkins.html. |David A. Bader and Kamesh Madduri. 2005. Design and implementation of the HPCS graph analysis benchmark on symmetric multiprocessors. In HiPC. Lecture Notes in Computer Science, Vol. 3769. Springer, 465--476.  |J\u00f8rgen Bang-Jensen and Gregory Z. Gutin. 2009. Digraphs: Theory, Algorithms and Applications (2nd ed.). Springer. |Ferenc Belik. 1990. An efficient deadlock avoidance technique. Transactions on Computers 39 (1990), 882--888.  |G\u00e9rard Boudol. 2009. A deadlock-free semantics for shared memory concurrency. In ICTAC. Lecture Notes in Computer Science, Vol. 5684. Springer, 140--154.  |Yan Cai and Wing-Kwong Chan. 2014. Magiclock: Scalable detection of potential deadlocks in large-scale multithreaded programs. Transactions on Software Engineering 40, 3 (2014), 266--281.  |Vincent Cav\u00e9, Jisheng Zhao, Jun Shirako, and Vivek Sarkar. 2011. Habanero-Java: The new adventures of old X10. In PPPJ. ACM, 51--61.  |Soumen Chakrabarti, Manish Gupta, and Jong-Deok Choi. 1996. Global communication analysis and optimization. ACM SIGPLAN Notices (1996), 68--78.  |Philippe Charles, Christian Grothoff, Vijay Saraswat, Christopher Donawa, Allan Kielstra, Kemal Ebcioglu, Christoph von Praun, and Vivek Sarkar. 2005. X10: An object-oriented approach to non-uniform cluster computing. In OOPSLA. ACM, 519--538.  |Sung-Eun Choi and Lawrence Snyder. 1997. Quantifying the effects of communication optimizations. In ICPP. IEEE, 218--222. |Edward G. Coffman, Jr., M. J. Elphick, and Arie Shoshani. 1971. System deadlocks. Computing Surveys 3, 2 (1971), 67--78.  |Tiago Cogumbreiro, Raymond Hu, Francisco Martins, and Nobuko Yoshida. 2015. Dynamic deadlock verification for general barrier synchronisation. In PPoPP. ACM, 150--160.  |Tiago Cogumbreiro, Francisco Martins, and Vasco Thudichum Vasconcelos. 2013. Coordinating phased activities while maintaining progress. In COORDINATION, Lecture Notes in Computer Science, Vol. 7890. Springer, 31--44.|Tiago Cogumbreiro, Jun Shirako, and Vivek Sarkar. 2017. Formalization of Habanero phasers using Coq. Journal of Logical and Algebraic Methods in Programming 90 (2017), 50--60.|Tiago Cogumbreiro, Rishi Surendran, Francisco Martins, Vivek Sarkar, Vasco T. Vasconcelos, and Max Grossman. 2017. Deadlock avoidance in parallel programs with futures: Why parallel tasks should not wait for strangers. Proceedings of the ACM on Programming Languages 1, OOPSLA, Article 103 (2017), 26 pages.  |Don Coppersmith and Shmuel Winograd. 1990. Matrix multiplication via arithmetic progressions. Symbolic Computation 9, 3 (1990), 251--280.  |Silvia Crafa, David Cunningham, Vijay Saraswat, Avraham Shinnar, and Olivier Tardieu. 2014. Semantics of (Resilient) X10. In ECOOP, Lecture Notes in Computer Science, Vol. 8586. Springer, 670--696.  |Steve Deitz. 2006. Parallel Programming in Chapel. Retrieved January 2018 from https://www.cct.lsu.edu/&sim;estrabd/LACSI2006/Programming%20Models/deitz.pdf. Presented at LACSI.|Camil Demetrescu and Giuseppe F. Italiano. 2005. Trade-offs for fully dynamic transitive closure on DAGs: Breaking through the |(|<sup>2</sup>) barrier. Journal of the ACM 52, 2 (2005), 147--156.  |Jyotirmoy V. Deshmukh, E. Allen Emerson, and Sriram Sankaranarayanan. 2011. Symbolic modular deadlock analysis. Automated Software Engineering 18, 3--4 (2011), 325--362.  |Edsger W. Dijkstra. 1965. Cooperating Sequential Processes. Technical Report. Technical University of Eindhoven. https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html EWD-123. |Mahdi Eslamimehr and Jens Palsberg. 2014. Sherlock: Scalable deadlock detection for concurrent programs. In FSE. ACM, 353--365.  |Michael A. Frumkin, Matthew Schultz, Haoqiang Jin, and Jerry Yan. 2003. Performance and scalability of the NAS parallel benchmarks in Java. In IPDPS. IEEE. |Zeinab Ganjei, Ahmed Rezine, Petru Eles, and Zebo Peng. 2017. Safety verification of phaser programs. In FMCAD. IEEE, 68--75. |Andy Georges, Dries Buytaert, and Lieven Eeckhout. 2007. Statistically rigorous Java performance evaluation. In OOPSLA. ACM, 57--76.  |Prodromos Gerakios, Nikolaos Papaspyrou, Konstantinos Sagonas, and Panagiotis Vekris. 2011. Dynamic deadlock avoidance in systems code using statically inferred effects. In PLOS. ACM, 1--5.  |Milos Gligoric, Peter C. Mehlitz, and Darko Marinov. 2012. X10X: Model checking a new programming language with an \u201cold\u201d model checker. In ICST. IEEE, 11--20.  |Rajiv Gupta. 1989. The fuzzy barrier: A mechanism for high speed synchronization of processors. SIGARCH Computer Architecture News 17, 2 (1989), 54--63.  |Tobias Hilbrich, Bronis R. de Supinski, Fabian H\u00e4nsel, Matthias S. M\u00fcller, Martin Schulz, and Wolfgang E. Nagel. 2013. Runtime MPI collective checking with tree-based overlay networks. In EuroMPI. ACM, 129--134.  |Tobias Hilbrich, Bronis R. de Supinski, Wolfgang E. Nagel, Joachim Protze, Christel Baier, and Matthias S. M\u00fcller. 2013. Distributed wait state tracking for runtime MPI deadlock detection. In SC. ACM, 1--12.  |Tobias Hilbrich, Bronis R. de Supinski, Martin Schulz, and Matthias S. M\u00fcller. 2009. A graph based approach for MPI deadlock detection. In ICS. ACM, 296--305.  |Tobias Hilbrich, Matthias S. M\u00fcller, Martin Schulz, and Bronis R. de Supinski. 2011. Order preserving event aggregation in TBONs. In EuroMPI, Lecture Notes in Computer Science, Vol. 6960. Springer, 19--28. |Tobias Hilbrich, Joachim Protze, Martin Schulz, Bronis R. de Supinski, and Matthias S. M\u00fcller. 2012. MPI runtime error detection with MUST: Advances in deadlock detection. In SC. IEEE, 1--11. |Richard C. Holt. 1972. Some deadlock properties of computer systems. Computing Surveys 4, 3 (1972), 179--196.  |Shams Mahmood Imam and Vivek Sarkar. 2014. Cooperative scheduling of parallel tasks with general synchronization patterns. In ECOOP, Lecture Notes in Computer Science, Vol. 8586. Springer, 618--643.|Kamal Jain, MohammadTaghi Hajiaghayi, and Kunal Talwar. 2005. The generalized deadlock resolution problem. In ICALP, Lecture Notes in Computer Science, Vol. 3580. Springer, 853--865.  |Inbum Jung, Jongwoong Hyun, Joonwon Lee, and Joongsoo Ma. 2001. Two-phase barrier: A synchronization primitive for improving the processor utilization. International Journal of Parallel Programming 29, 6 (2001), 607--627.  |Amir Kamil and Katherine Yelick. 2009. Enforcing textual alignment of collectives using dynamic checks. In LCPC. Lecture Notes in Computer Science, Vol. 5898. Springer, 368--382.  |Edgar Knapp. 1987. Deadlock detection in distributed databases. Computing Survey 19, 4 (1987), 303--328.  |Leslie Lamport. 1978. Time, clocks, and the ordering of events in a distributed system. Commuications of the ACM 21, 7 (1978), 558--565.  |Duy-Khanh Le, Wei-Ngan Chin, and Yong-Meng Teo. 2013. Verification of static and dynamic barrier synchronization using bounded permissions. In ICFEM, Lecture Notes in Computer Science, Vol. 8144. Springer, 231--248.|Jonathan K. Lee and Jens Palsberg. 2010. Featherweight X10: A core calculus for async-finish parallelism. In PPoPP. ACM, 25--36.  |Daan Leijen, Wolfram Schulte, and Sebastian Burckhardt. 2009. The design of a task parallel library. In OOPSLA. ACM, 227--242.  |Peng Li, Kunal Agrawal, Jeremy Buhler, and Roger D. Chamberlain. 2010. Deadlock avoidance for streaming computations with filtering. In SPAA. ACM, 243--252.  |Piotr R. Luszczek, David H. Bailey, Jack J. Dongarra, Jeremy Kepner, Robert F. Lucas, Rolf Rabenseifner, and Daisuke Takahashi. 2006. The HPC challenge (HPCC) benchmark suite. In SC. ACM.  |Toshimi Minoura. 1982. Deadlock avoidance revisited. Journal of the ACM 29, 4 (1982), 1023--1048.  |Ian Munro. 1971. Efficient determination of the transitive closure of a directed graph. Information Processing Letters 1, 2 (1971), 56--58.  |Karthik Murthy, Sri Raj Paul, Kuldeep S. Meel, Tiago Cogumbreiro, and John M. Mellor-Crummey. 2016. Design and verification of distributed phasers. In EuroPAR. Lecture Notes in Computer Science, Vol. 9833. Springer, 405--418.  |Armand Navabi, Xiangyu Zhang, and Suresh Jagannathan. 2008. Quasi-static scheduling for safe futures. In PPoPP. ACM, 23--32.  |Yarden Nir-Buchbinder, Rachel Tzoref, and Shmuel Ur. 2008. Deadlocks: From exhibiting to healing. Lecture Notes in Computer Science, Vol. 5289. Springer, 104--118.|Yusuke Nonaka, Kazuo Ushijima, Hibiki Serizawa, Shigeru Murata, and Jingde Cheng. 2001. A run-time deadlock detector for concurrent Java programs. In APSEC. IEEE, 45--52. |Matthew T. O\u2019Keefe and Henry G. Dietz. 1990. Hardware barrier synchronization: Dynamic barrier MIMD (DBM). In ICPP. Pennsylvania State University, 43--46.|Antoniu Pop and Albert Cohen. 2013. OpenStream: Expressiveness and data-flow compilation of OpenMP streaming programs. Transactions on Architecture and Code Optimization 9, 4 (2013), Article 53, 25 pages.  |Hari K. Pyla and Srinidhi Varadarajan. 2010. Avoiding deadlock avoidance. In PACT. ACM, 75--86.  |Spiridon A. Reveliotis, Mark A. Lawley, and Placid M. Ferreira. 1997. Polynomial-complexity deadlock avoidance policies for sequential resource allocation systems. Transactions on Automatic Control 42, 10 (1997), 1344--1357.|Indranil Roy, Glenn R. Luecke, James Coyle, and Marina Kraeva. 2013. A scalable deadlock detection algorithm for UPC collective operations. In PGAS. University of Edinburgh, 2--15. http://www.pgas2013.org.uk/sites/default/files/pgas2013proceedings.pdf.|Malavika Samak and Murali Krishna Ramanathan. 2014. Trace driven dynamic deadlock detection and reproduction. In PPoPP. ACM, 29--42.  |Vijay Saraswat and Radha Jagadeesan. 2005. Concurrent clustered programming. In CONCUR. Lecture Notes in Computer Science, Vol. 3653. Springer, 353--367.  |Rahul Sharma, Michael Bauer, and Alex Aiken. 2015. Verification of producer-consumer synchronization in GPU programs. In PLDI. ACM, 88--98.  |Chia Shih and John A. Stankovic. 1990. Survey of Deadlock Detection in Distributed Concurrent Programming Environments and Its Application to Real-Time Systems. Technical Report. University of Massachusetts. https://web.cs.umass.edu/publication/details.php?id&equals;447 UM-CS-1990-069. |Jun Shirako, David M. Peixotto, Vivek Sarkar, and William N. Scherer. 2008. Phasers: A unified deadlock-free construct for collective and point-to-point synchronization. In ICS. ACM, 277--288.  |Jun Shirako, David M. Peixotto, Vivek Sarkar, and William N. Scherer. 2009. Phaser accumulators: A new reduction construct for dynamic parallelism. In IPDPS. IEEE, 1--12.  |Jun Shirako, David M. Peixotto, Drago\u015f-Dumitru Sb\u00eerlea, and Vivek Sarkar. 2011. Phaser beams: Integrating stream parallelism with task parallelism. Presented at the X10 Workshop.|Lorna A. Smith, J. Mark Bull, and Jan Obdrz\u00e1lek. 2001. A parallel Java Grande benchmark suite. In SC. ACM, 10.  |Robert Tarjan. 1972. Depth-first search and linear graph algorithms. SIAM Journal on Computing 1, 2 (1972), 146--160.|Franklyn Turbak. 1996. First-class synchronization barriers. In ICFP. ACM, 157--168.  |Nalini Vasudevan, Olivier Tardieu, Julian Dolby, and Stephen A. Edwards. 2009. Compile-time analysis and specialization of clocks in concurrent programs. In CC. Lecture Notes in Computer Science, Vol. 5501. Springer, 48--62.  |Anh Vo. 2011. Scalable Formal Dynamic Verification of MPI Programs Through Distributed Causality Tracking. Ph.D. dissertation. University of Utah. Advisor(s) Gopalakrishnan, Ganesh. AAI3454168. |Yin Wang, Terence Kelly, Manjunath Kudlur, St\u00e9phane Lafortune, and Scott Mahlke. 2008. Gadara: Dynamic deadlock avoidance for multithreaded programs. In OSDI. USENIX, 281--294. https://www.usenix.org/conference/osdi-08/gadara-dynamic-deadlock-avoidance-multithreaded-programs. |Haitao Wei, Hong Tan, Xiaoxian Liu, and Junqing Yu. 2012. StreamX10: A stream programming framework on X10. In X10. ACM, 1--6.  |Adam Welc, Suresh Jagannathan, and Antony Hosking. 2005. Safe futures for Java. In OOPSLA. ACM, 439--453.  |Yuan Zhang, Evelyn Duesterwald, and Guang R. Gao. 2008. Concurrency analysis for shared memory programs with textually unaligned barriers. In LCPC. Lecture Notes in Computer Science, Vol. 5234. Springer, 95--109.  |Yingchun Zhu and Laurie J. Hendren. 1998. Communication optimizations for parallel C programs. In PLDI. ACM, 199--211.  |", "organization": "Rice University, USA|Imperial College London, UK|LASIGE, Faculdade de Ci\u00eancias, Universidade de Lisboa, Portugal and University of the Azores, Portugal |Imperial College London, UK|Rice University, USA|Imperial College London, UK|LASIGE, Faculdade de Ci\u00eancias, Universidade de Lisboa, Portugal and University of the Azores, Portugal |Imperial College London, UK|", "title": ["Dynamic Deadlock Verification for General Barrier Synchronisation"]},
{"abstract": "In security-typed programming languages, types statically enforce noninterference between potentially conspiring values, such as the arguments and results of functions. But to adopt static security types, like other advanced type disciplines, programmers face a steep wholesale transition, often forcing them to refactor working code just to satisfy their type checker. To provide a gentler path to security typing that supports safe and stylish but hard-to-verify programming idioms, researchers have designed languages that blend static and dynamic checking of security types. Unfortunately, most of the resulting languages only support static, type-based reasoning about noninterference if a program is entirely statically secured. This limitation substantially weakens the benefits that dynamic enforcement brings to static security typing. Additionally, current proposals are focused on languages with explicit casts and therefore do not fulfill the vision of gradual typing, according to which the boundaries between static and dynamic checking only arise from the (im)precision of type annotations and are transparently mediated by implicit checks.\nIn this article, we present GSL\n, a gradual security-typed higher-order language with references. As a gradual language, GSL\n supports the range of static-to-dynamic security checking exclusively driven by type annotations, without resorting to explicit casts. Additionally, GSL\n lets programmers use types to reason statically about termination-insensitive noninterference in \n programs, even those that enforce security dynamically. We prove that GSL\n satisfies all but one of Siek et al.\u2019s criteria for gradually-typed languages, which ensure that programs can seamlessly transition between simple typing and security typing. A notable exception regards the dynamic gradual guarantee, which some specific programs must violate if they are to satisfy noninterference; it remains an open question whether such a language could fully satisfy the dynamic gradual guarantee. To realize this design, we were led to draw a sharp distinction between syntactic type \n and semantic type \n, each of which constrains the design of the gradual language.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mat\u00edas Toro|Ronald Garcia|\u00c9ric Tanter|Mat\u00edas Toro|Ronald Garcia|\u00c9ric Tanter|", "references": "", "organization": "PLEIAD Laboratory, Computer Science Department (DCC), University of Chile, Beauchef, Santiago, Chile |Software Practices Laboratory, University of British Columbia, Vancouver, Canada|PLEIAD Laboratory, Computer Science Department (DCC), University of Chile, Beauchef, Santiago, Chile |PLEIAD Laboratory, Computer Science Department (DCC), University of Chile, Beauchef, Santiago, Chile |Software Practices Laboratory, University of British Columbia, Vancouver, Canada|PLEIAD Laboratory, Computer Science Department (DCC), University of Chile, Beauchef, Santiago, Chile |", "title": ["Type-Driven Gradual Security with References"]},
{"abstract": "In multiparty session types, interconnection networks identify which roles in a session engage in communication (i.e., two roles are connected if they exchange a message). In session-based interpretations of linear logic the analogue notion corresponds to determining which processes are composed, or cut, using compatible channels typed by linear propositions. In this work, we show that well-formed interactions represented in a session-based interpretation of classical linear logic (CLL) form strictly less-expressive interconnection networks than those of a multiparty session calculus. To achieve this result, we introduce a new compositional synthesis property dubbed partial multiparty compatibility (PMC), enabling us to build a global type denoting the interactions obtained by iterated composition of well-typed CLL threads. We then show that CLL composition induces PMC global types without circular interconnections between three (or more) participants. PMC is then used to define a new CLL composition rule that can form circular interconnections but preserves the deadlock-freedom of CLL.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bernardo Toninho|Nobuko Yoshida|Bernardo Toninho|Nobuko Yoshida|", "references": "Samson Abramsky. 1993. Computational interpretations of linear logic. Theoret. Comput. Sci. 111, 1--2 (1993), 3--57.  |Samson Abramsky, Simon J. Gay, and Rajagopal Nagarajan. 1995. Specification structures and propositions-as-types for concurrency. In Logics for Concurrency. 5--40. |Robert Atkey, Sam Lindley, and J. Garrett Morris. 2016. Conflation confers concurrency. In A List of Successes That Can Change the World\u2014Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday, LNCS, Vol. 9600. Springer, 32--55.|Gianluigi Bellin and Phil Scott. 1994. On the &pi;-calculus and linear logic. Theoret. Comput. Sci. 135, 1 (1994), 11--65.  |Laura Bocchi, Tzu-Chun Chen, Romain Demangeon, Kohei Honda, and Nobuko Yoshida. 2017. Monitoring networks through multiparty session types. Theoretical Computer Science 669 (2017), 33--58.|Laura Bocchi, Julien Lange, and Nobuko Yoshida. 2015. Meeting deadlines together. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201915), Vol. 42. Schloss Dagstuhl, 283--296.|Lu\u00eds Caires and Jorge A. P\u00e9rez. 2016. Multiparty session types within a canonical binary theory, and beyond. In Proceedings of the International Conference on Formal Techniques for Distributed Systems (FORTE\u201916), LNCS, Vol. 9688. Springer, 74--95.  |Lu\u00eds Caires and Frank Pfenning. 2010. Session types as intuitionistic linear propositions. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201910), LNCS, Vol. 6269. Springer, 222--236. |Lu\u00eds Caires, Frank Pfenning, and Bernardo Toninho. 2016. Linear logic propositions as session types. Math. Struct. Comp. Sci. 26, 3 (2016), 367--423.|Sara Capecchi, Ilaria Castellani, and Mariangiola Dezani-Ciancaglini. 2016. Information flow safety in multiparty sessions. Math. Struct. Comput. Sci. 26, 8 (2016), 1352--1394.|Marco Carbone, Sam Lindley, Fabrizio Montesi, Carsten Sch\u00fcrmann, and Philip Wadler. 2016. Coherence generalises duality: A logical explanation of multiparty session types. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201916), Leibniz International Proceedings in Informatics, Vol. 59. Schloss Dagstuhl, 33:1--33:15.|Marco Carbone and Fabrizio Montesi. 2013. Deadlock-freedom-by-design: Multiparty asynchronous global programming. In Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, (POPL\u201913). 263--274.  |Marco Carbone, Fabrizio Montesi, and Carsten Sch\u00fcrmann. 2014. Choreographies, logically. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201914), LNCS, Vol. 8704. Springer, 47--62.|Marco Carbone, Fabrizio Montesi, Carsten Sch\u00fcrmann, and Nobuko Yoshida. 2015. Multiparty session types as coherence proofs. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201915), Leibniz International Proceedings in Informatics, Vol. 42. Schloss Dagstuhl, 412--426.|Ilaria Castellani, Mariangiola Dezani-Ciancaglini, and Paola Giannini. 2017. Concurrent reversible sessions. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201917), LIPIcs, Vol. 85. Schloss Dagstuhl, Leibniz-Zentrum fuer Informatik, 30:1--30:17.|Ilaria Castellani, Mariangiola Dezani-Ciancaglini, and Jorge A. P\u00e9rez. 2016. Self-adaptation and secure information flow in multiparty communications. Formal Asp. Comput. 28, 4 (2016), 669--696.  |Tzu-Chun Chen, Mariangiola Dezani-Ciancaglini, Alceste Scalas, and Nobuko Yoshida. 2017. On the preciseness of subtyping in session types. Logic. Methods Comput. Sci. 13, 2 (2017).|Mario Coppo, Mariangiola Dezani-Ciancaglini, Nobuko Yoshida, and Luca Padovani. 2016. Global progress for dynamically interleaved multiparty sessions. Math. Struct. Comput. Sci. 26, 2 (2016), 238--302.|Ornela Dardha and Jorge A. P\u00e9rez. 2015. Comparing deadlock-free session typed processes. In Electronic Proceedings in Theoretical Computer Science, Vol. 190. 1--15.|Romain Demangeon, Kohei Honda, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida. 2015. Practical interruptible conversations: Distributed dynamic verification with multiparty session types and python. Formal Methods Syst. Des. 46, 3 (2015), 197--225.  |Romain Demangeon and Nobuko Yoshida. 2015. On the expressiveness of multiparty sessions. In Foundations of Software Technology and Theoretical Computer Science (FSTTCS\u201915), Leibniz International Proceedings in Informatics (LIPIcs), Vol. 45. Schloss Dagstuhl, 560--574.|Pierre-Malo Deni\u00e9lou and Nobuko Yoshida. 2013. Multiparty compatibility in communicating automata: Characterisation and synthesis of global session types. In International Colloquium on Automata, Languages, and Programming (ICALP\u201913), LNCS, Vol. 7966. Springer, 174--186.  |Henry DeYoung, Luis Caires, Frank Pfenning, and Bernardo Toninho. 2012. Cut reduction in linear logic as asynchronous session-typed communication. In Computer Science Logic.|Luca Fossati, Raymond Hu, and Nobuko Yoshida. 2014. Multiparty session nets. In Proceedings of the International Symposium on Trustworthy Global Computing (TGC\u201914), LNCS, Matteo Maffei and Emilio Tuosto (Eds.), Vol. 8902. Springer, 112--127.|Simon Fowler. 2016. An erlang implementation of multiparty session actors. In Proceedings of the International Conference on Engineering (ICE\u201916), Vol. 223. 36--50.|S. Gay and M. Hole. 2005. Subtyping for session types in the pi calculus. Acta Inf. 42, 2--3 (2005), 191--225.|Simon J. Gay. 2016. Subtyping supports safe session substitution. In A List of Successes That Can Change the World\u2014Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday. 95--108.|J.-Y. Girard. 1987. Linear logic. Theoret. Comput. Sci. 50, 1 (1987), 1--102.  |Kohei Honda, Vasco T. Vasconcelos, and Makoto Kubo. 1998. Language primitives and type disciplines for structured communication-based programming. In European Symposium on Programming (ESOP'98), LNCS, Vol. 1381. Springer-Verlag, 22--138. |Kohei Honda, Nobuko Yoshida, and Marco Carbone. 2008. Multiparty asynchronous session types. In Proceedings of the Conference on Principles of Programming Languages (POPL\u201908). 273--284.  |Kohei Honda, Nobuko Yoshida, and Marco Carbone. 2016. Multiparty asynchronous session types. J. ACM 63, 1--9 (2016), 1--67.  |Raymond Hu and Nobuko Yoshida. 2016. Hybrid session verification through endpoint API generation. In International Conference on Fundamental Approaches to Software Engineering (FASE\u201916) (LNCS), Vol. 9633. Springer, 401--418.|Raymond Hu and Nobuko Yoshida. 2017. Explicit connection actions in multiparty session types. In Proceedings of the 20th International Conference on Fundamental Approaches to Software Engineering, LNCS, Vol. 10202. Springer, 116--133.  |Hans H\u00fcttel, Ivan Lanese, Vasco T. Vasconcelos, Lu\u00eds Caires, Marco Carbone, Pierre-Malo Deni\u00e9lou, Dimitris Mostrous, Luca Padovani, Ant\u00f3nio Ravara, Emilio Tuosto, Hugo Torres Vieira, and Gianluigi Zavattaro. 2016. Foundations of session types and behavioural contracts. ACM Comput. Surv. 49, 1, Article 3 (Apr. 2016), 36 pages.  |Limin Jia, Hannah Gommerstadt, and Frank Pfenning. 2016. Monitors and blame assignment for higher-order session types. In Proceedings of the Conference on Principles of Programming Languages (POPL\u201916). 582--594.  |Julien Lange and Emilio Tuosto. 2012. Synthesising choreographies from local session types. In Proceedings of the 29th International Conference on Concurrency Theory (CONCUR\u201912), LNCS, Maciej Koutny and Irek Ulidowski (Eds.), Vol. 7454. Springer, 225--239.  |Julien Lange, Emilio Tuosto, and Nobuko Yoshida. 2015. From communicating machines to graphical choreographies. In Proceedings of the Conference on Principles of Programming Languages (POPL\u201915), Sriram K. Rajamani and David Walker (Eds.). ACM Press, 221--232.  |Julien Lange and Nobuko Yoshida. 2016. Characteristic formulae for session types. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201916), LNCS, Vol. 9636. Springer, 833--850.  |Sam Lindley and J. Garrett Morris. 2015. A semantics for propositions as sessions. In Conference name is European Symposium on Programming (ESOP'15) (LNCS), Vol. 9032. Springer, 560--584.|Sam Lindley and J. Garrett Morris. 2016. Talking bananas: Structural recursion for session types. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming (ICFP\u201916). 434--447.  |Hugo A. Lopez, Eduardo R. B. Marques, Francisco Martins, Nicholas Ng, Casar Santos, Vasco Thudichum Vasconcelos, and Nobuko Yoshida. 2015. Protocol-based verification of message-passing parallel programs. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages 8 Applications (OOPSLA\u201915). ACM, 280--298.  |Mungo 2016. Mungo homepage. Retrieved from http://www.dcs.gla.ac.uk/research/mungo/.|Rumyana Neykova, Laura Bocchi, and Nobuko Yoshida. 2017. Timed runtime monitoring for multiparty conversations. Formal Asp. Comput. 29, 5 (2017), 877--910.  |Rumyana Neykova, Raymond Hu, Nobuko Yoshida, and Fahd Abdeljallal. 2018. Session type provider: Compile-time API generation for distributed protocols in F#. (unpublished).  |Rumyana Neykova and Nobuko Yoshida. 2017. Let it recover: Multiparty protocol-induced recovery. In Proceedings of the 26th International Conference on Compiler Construction. ACM, 98--108.  |Rumyana Neykova and Nobuko Yoshida. 2017. Multiparty session actors. Logical Methods Comput. Sci. 13, 1 (2017).|Nicholas Ng, Jose Coutinho, and Nobuko Yoshida. 2015. Protocols by default: Safe MPI code generation based on session types. In International Conference on Compiler Construction (CC\u201915), LNCS, Vol. 9031. Springer, 212--232.|Nicholas Ng and Nobuko Yoshida. 2016. Static deadlock detection for concurrent go by global session graph synthesis. In Proceedings of the 25th International Conference on Compiler Construction. ACM, 174--184.  |Nicholas Ng, Nobuko Yoshida, and Kohei Honda. 2012. Multiparty session C: Safe parallel programming with message optimisation. In Proceedings of the Technology of Object-Oriented Languages and Systems (TOOLS\u201912), LNCS, Vol. 7304. Springer, 202--218.  |Luca Padovani, Vasco Thudichum Vasconcelos, and Hugo Torres Vieira. 2014. Typing liveness in multiparty communicating systems. In International Conference on Coordination Models and Languages (COORDINATION) 2014 (LNCS), Vol. 8459. Springer, 147--162.  |Jorge A. P\u00e9rez, Lu\u00eds Caires, Frank Pfenning, and Bernardo Toninho. 2012. Linear logical relations for session-based concurrency. In European Symposium on Programming (ESOP'12), LNCS, Vol. 7211. Springer, 539--558.  |Kirstin Peters, Uwe Nestmann, and Ursula Goltz. 2013. On distributability in process calculi. In European Symposium on Programming (ESOP'13) (LNCS), Vol. 7792. Springer, 310--329.  |D. Sangiorgi. 1996. Pi-calculus, internal mobility, and agent passing calculi. Theor. Comput. Science 167, 182 (1996), 235--274.  |Alceste Scalas, Ornela Dardha, Raymond Hu, and Nobuko Yoshida. 2017. A linear decomposition of multiparty sessions for safe distributed programming. In Proceedings of the 31st European Conference on Object-Oriented Programming (ECOOP\u201917), Leibniz International Proceedings in Informatics, Vol. 74. Schloss Dagstuhl, Leibniz-Zentrum fuer Informatik, 24:1--24:31.|Scribble. 2008. Scribble Project. Retrieved from www.scribble.org.|K. C. Sivaramakrishnan, Mohammad Qudeisat, Lukasz Ziarek, Karthik Nagaraj, and Patrick Eugster. 2013. Efficient sessions. Sci. Comput. Program. 78, 2 (2013), 147--167.  |Ramsay Taylor, Emilio Tuosto, Neil Walkinshaw, and John Derrick. 2016. Choreography-based analysis of distributed message passing programs. In Proceedings of the IEEE/IFIP Workshop on Programmable Data Plane (PDP\u201916). IEEE Computer Society, 512--519.|Bernardo Toninho, Lu\u00eds Caires, and Frank Pfenning. 2013. Higher-order processes, functions, and sessions: A monadic integration. In European Symposium on Programming (ESOP'13) (LNCS), Vol. 7792. Springer, 350--369.  |Hugo Torres Vieira and Vasco Thudichum Vasconcelos. 2013. Typing progress in communication-centred systems. In International Conference on Coordination Models and Language (COORDINATION) 2013 (LNCS), Vol. 7890. Springer, 236--250.|Philip Wadler. 2014. Propositions as sessions. J. Funct. Program. 24, 2--3 (2014), 384--418.|", "organization": "NOVA-LINCS, Universidade Nova de Lisboa and Imperial College London, Caparica, Portugal|Imperial College London, United Kingdom|NOVA-LINCS, Universidade Nova de Lisboa and Imperial College London, Caparica, Portugal|Imperial College London, United Kingdom|", "title": ["Interconnectability of Session-Based Logical Processes"]},
{"abstract": "Numerical software, common in scientific computing or embedded systems, inevitably uses a finite-precision approximation of the real arithmetic in which most algorithms are designed. In many applications, the roundoff errors introduced by finite-precision arithmetic are not the only source of inaccuracy, and measurement and other input errors further increase the uncertainty of the computed results. Adequate tools are needed to help users select suitable data types and evaluate the provided accuracy, especially for safety-critical applications.\nWe present a source-to-source compiler called Rosa that takes as input a real-valued program with error specifications and synthesizes code over an appropriate floating-point or fixed-point data type. The main challenge of such a compiler is a fully automated, sound, and yet accurate-enough numerical error estimation. We introduce a unified technique for bounding roundoff errors from floating-point and fixed-point arithmetic of various precisions. The technique can handle nonlinear arithmetic, determine closed-form symbolic invariants for unbounded loops, and quantify the effects of discontinuities on numerical errors. We evaluate Rosa on a number of benchmarks from scientific computing and embedded systems and, comparing it to the state of the art in automated error estimation, show that it presents an interesting tradeoff between accuracy and performance.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Eva Darulova|Viktor Kuncak|Eva Darulova|Viktor Kuncak|", "references": "", "organization": "Ecole Polytechnique Federale de Lausanne|Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland|Ecole Polytechnique Federale de Lausanne|Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland|", "title": ["Towards a Compiler for Reals"]},
{"abstract": "While high-level languages come with significant readability and maintainability benefits, their performance remains difficult to predict. For example, programmers may unknowingly use language features inappropriately, which cause their programs to run slower than expected. To address this issue, we introduce \n, a technique that reports performance costs in terms of linguistic constructs. Feature-specific profilers help programmers find expensive uses of specific features of their language. We describe the architecture of a profiler that implements our approach, explain prototypes of the profiler for two languages with different characteristics and implementation strategies, and provide empirical evidence for the approach\u2019s general usefulness as a performance debugging tool.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Leif Andersen|Vincent St-Amour|Jan Vitek|Matthias Felleisen|Leif Andersen|Vincent St-Amour|Jan Vitek|Matthias Felleisen|", "references": "Gene M. Amdahl. 1967. Validity of the single processor approach to achieving large scale computing capabilities. In Proceedings of the Spring Joint Computer Conference.  |Walter Binder, Danilo Ansaloni, Alex Villaz\u00f3n, and Philippe Moret. 2011. Flexible and efficient profiling with aspect-oriented programming. In Concurrency and Computation: Practice and Experience. John Wiley and Son, New York, 1749--1773. Retrieved from  |John Clements, Matthew Flatt, and Matthias Felleisen. 2001. Modeling an algebraic stepper. In Proceedings of the European Symposium on Programming, 320--334. |John Clements, Ayswarya Sundaram, and David Herman. 2008. Implementing continuation marks in JavaScript. In Proceedings of the Scheme and Functional Programming Workshop, 1--10.|R. Kent Dybvig. 2009. Chez Scheme Version 8 User\u2019s Guide. Cadence Research Systems.|R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. 1993. Syntax abstraction in scheme. In LISP and Symbolic Computation.  |Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Paul Steckler, and Matthias Felleisen. 2002. DrScheme: A programming environment for scheme. J. Funct. Program. 12, 2 (2002), 159--182.  |Robert Bruce Findler and Matthias Felleisen. 2002. Contracts for higher-order functions. In Proceedings of the International Conference on Functional Programming. Retrieved from  |Matthew Flatt and Eli Barzilay. 2009. Keyword and optional arguments in PLT scheme. In Proceedings of the Workshop on Scheme and Functional Programming.|Matthew Flatt and PLT. 2010. Reference: Racket. PLT Inc., PLT-TR-2010-1. Retrieved from DOI:http://racket-lang.org/tr1/|Tony Garnock-Jones, Sam Tobin-Hochstadt, and Matthias Felleisen. 2014. The network as a language construct. In Proceedings of the European Symposium on Programming Languages, 473--492.  |Matthias Hauswirth, Peter F. Sweeney, Amer Diwan, and Michael Hind. 2004. Vertical profiling. In Proceedings of the ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications, 251--269.|Carl Hewitt, Peter Bishop, and Richard Steiger. 1973. A universal modular ACTOR formalism for artificial intelligence. In Proceedings of the International Joint Conference on Artificial Intelligence. |Milan Jovic and Matthias Hauswirth. 2011. Listener latency profiling. Sci. Comput. Program. 19, 4 (2011), 1054--1072.  |Jonas Maebe, Dries Buytaert, Lieven Eeckhout, and Koen De Bosschere. 2006. Javana: A system for building customized Java program analysis tools. In Proceedings of the ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications. Retrieved from  |Simon Marlow, Jos\u00e9 Iborra, Bernard Pope, and Andy Gill. 2007. A lightweight interactive debugger for Haskell. In Proceedings of the Haskell Workshop, 13--24.  |Jay McCarthy. 2010. The two-state solution: Native and serializable continuations accord. In Proceedings of the ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications, 567--582.  |Scott Moore, Christos Dimoulas, Dan King, and Stephen Chong. 2014. SHILL: A secure shell scripting language. In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation. Retrieved from https://www.usenix.org/conference/osdi14/technical-sessions/presentation/moore. |Flor\u00e9al Morandat, Brandon Hill, Leo Osvald, and Jan Vitek. 2012. Evaluating the design of the R language. In Proceedings of the European Conference on Object-Oriented Programming. Retrieved from|Todd Mytkowicz, Amer Diwan, Matthias Hauswirth, and Peter F. Sweeney. 2010. Evaluating the accuracy of Java profilers. In Proceedings of the Conference on Programming Languages Design and Implementation, 187--197.  |Nicholas Nethercote and Julian Seward. 2007. Valgrind: A framework for heavyweight dynamic binary instrumentation. In Proceedings of the Conference on Programming Languages Design and Implementation. Retrieved from  |Greg Pettyjohn, John Clements, Joe Marshall, Shriram Krishnamurthi, and Matthias Felleisen. 2005. Continuations from generalized stack inspection. In Proceedings of the International Conference on Functional Programming, 216--227.  |R Development Core Team. 2016. R Language Definition. R Development Core Team, 3.3.1. Retrieved from http://web.mit.edu/&sim;r/current/arch/amd64_linux26/lib/R/doc/manual/R-lang.pdf.|Jeremy Singer and Chris Kirkham. 2008. Dynamic analysis of Java program concepts for visualization and profiling. Sci. Comput. Program. 70, 2--3 (2008), 111--126.  |Vincent St-Amour, Leif Andersen, and Matthias Felleisen. 2012. Feature-specific profiling. In Proceedings of the International Conference on Compiler Construction. Retrieved from|Vincent St-Amour, Sam Tobin-Hochstadt, and Matthias Felleisen. 2012. Optimization coaching: Optimizers learn to communicate with programmers. In Proceedings of the ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications, 163--178.  |Juan M. Tamayo, Alex Aiken, Nathan Bronson, and Mooly Sagiv. 2012. Understanding the behavior of database operations under program control. In Proceedings of the ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications, 983--996.  |Sam Tobin-Hochstadt and Matthias Felleisen. 2008. The design and implementation of typed scheme. In Proceedings of the Conference on Principles of Programming Languages, 395--406.  |Hadley Wickham. 2014. Advanced R, 1st ed. Chapman and Hall/CRC. Retrieved from http://adv-r.had.co.nz/.|", "organization": "PLT @ Northeastern University, United States of America|PLT @ Northwestern University, United States of America|Northeastern University and Czech Technical University|PLT @ Northwestern University, United States of America|PLT @ Northeastern University, United States of America|PLT @ Northwestern University, United States of America|Northeastern University and Czech Technical University|PLT @ Northwestern University, United States of America|", "title": ["Feature-Specific Profiling"]},
{"abstract": "We consider the ultimate limits of program-specific garbage collector (GC) performance for real programs. We first characterize the GC schedule optimization problem. Based on this characterization, we develop a linear-time dynamic programming solution that, given a program run and heap size, computes an \n schedule of collections for a non-generational collector. Using an analysis of a heap object graph of the program, we compute a property of heap objects that we call their \n time. This information enables us to extend the non-generational GC schedule problem to the generational GC case in a way that also admits a dynamic programming solution with cost quadratic in the length of the trace (number of objects allocated). This improves our previously reported approximately optimal result. We further extend the two-generation dynamic program to any number of generations, allowing other generalizations as well. Our experimental results for two generations on traces from Java programs of the DaCapo benchmark suite show that there is considerable promise to reduce garbage collection costs for some programs by developing program-specific collection policies. For a given space budget, optimal schedules often obtain modest but useful time savings, and for a given time budget, optimal schedules can obtain considerable space savings.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Nicholas Jacek|Meng-Chieh Chiu|Benjamin M. Marlin|J. Eliot B. Moss|Nicholas Jacek|Meng-Chieh Chiu|Benjamin M. Marlin|J. Eliot B. Moss|", "references": "", "organization": "University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|University of Massachusetts Amherst, MA, USA|", "title": ["Optimal Choice of When to Garbage Collect"]},
{"abstract": "We present a new, syntax-directed framework for Curry-style type systems with subtyping. It supports a rich set of features, and allows for a reasonably simple theory and implementation. The system we consider has sum and product types, universal and existential quantifiers, and inductive and coinductive types. The latter two may carry size invariants that can be used to establish the termination of recursive programs. For example, the termination of quicksort can be derived by showing that partitioning a list does not increase its size. The system deals with complex programs involving mixed induction and coinduction, or even mixed polymorphism and (co-)induction. One of the key ideas is to separate the notion of size from recursion. We do not check the termination of programs directly, but rather show that their (circular) typing proofs are well-founded. Termination is then obtained using a standard (semantic) normalisation proof. To demonstrate the practicality of the system, we provide an implementation accepting all the examples discussed in the article.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Rodolphe Lepigre|Christophe Raffalli|Rodolphe Lepigre|Christophe Raffalli|", "references": "", "organization": "LAMA, CNRS, Univ. Savoie Mont Blanc and Inria, LSV, CNRS, Univ. Paris-Saclay|LAMA, CNRS, Univ. Savoie Mont Blanc and IMERL, FING, UdelaR|LAMA, CNRS, Univ. Savoie Mont Blanc and Inria, LSV, CNRS, Univ. Paris-Saclay|LAMA, CNRS, Univ. Savoie Mont Blanc and IMERL, FING, UdelaR|", "title": ["Practical Subtyping for Curry-Style Languages"]},
{"abstract": "A theory of slicing non-deterministic programs and systems is developed. Non-deterministic programs and systems are represented as non-deterministic program graphs (NDPGs) that allow arbitrary non-deterministic branching to be expressed. Structural and semantic relationships that must exist between an NDPG and (1) its non-termination insensitive (weak) slices and (2) its non-termination sensitive (strong) slices are defined. Weak and strong commitment closure are introduced. These are the NDPG equivalents of being closed under non-termination sensitive and non-termination insensitive control dependence; properties defined on subsets of vertices of the equivalent deterministic structure: the control flow graph.\nIt is proved that if a subset of the vertices of an NDPG is both data dependence closed and (weak/strong) commitment closed, then the resulting induced graph will, indeed, satisfy our structural and semantic requirements. \n(\n) algorithms for computing minimal data and weak/strong commitment closed sets are given. The resulting induced graphs are thus guaranteed to be weak and strong slices, respectively.\nIt is demonstrated, with examples, that programs written in Dijkstra's non-deterministic guarded command language (DNGCL) can be converted to NDPGs to which our slicing algorithms can then be applied. It is proved that the resulting slices (NDPGs) can always be converted back to valid DNGCL programs, highlighting the applicability of our approach to slicing at the source code level.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sebastian Danicic|Michael R. Laurence|Sebastian Danicic|Michael R. Laurence|", "references": "", "organization": "Department of Computing, Goldsmiths, University of London, UK|Department of Computer Science, University of Sheffield, UK|Department of Computing, Goldsmiths, University of London, UK|Department of Computer Science, University of Sheffield, UK|", "title": ["Static Backward Slicing of Non-deterministic Programs and Systems"]},
{"abstract": "Pointer analysis is at the heart of most interprocedural program analyses. However, scaling pointer analysis to large programs is extremely challenging. In this article, we study incremental pointer analysis and present a new algorithm for computing the points-to information incrementally (i.e., upon code insertion, deletion, and modification). Underpinned by new observations of incremental pointer analysis, our algorithm significantly advances the state of the art in that it avoids redundant computations and the expensive graph reachability analysis, and preserves precision as the corresponding whole program exhaustive analysis. Moreover, it is parallel within each iteration of fixed-point computation. We have implemented our algorithm, IPA, for Java based on the WALA framework and evaluated its performance extensively on real-world large, complex applications. Experimental results show that IPA achieves more than 200X speedups over existing incremental algorithms, two to five orders of magnitude faster than whole program pointer analysis, and also improves the performance of an incremental data race detector by orders of magnitude. Our IPA implementation is open source and has been adopted by WALA.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bozhen Liu|Jeff Huang|Lawrence Rauchwerger|Bozhen Liu|Jeff Huang|Lawrence Rauchwerger|", "references": "2018. Language Server Protocol. https://langserver.org/.|Karim Ali and Ond\u0159ej Lhot\u00e1k. 2012. Application-only call graph construction. In Proceedings of the 26th European Conference on Object-Oriented Programming. Springer Berlin Heidelberg, 688--712.  |Lars Ole Andersen. 1994. Program Analysis and Specialization for the C Programming Language. Ph.D. Dissertation. University of Copenhagen.|Steven Arzt and Eric Bodden. 2014. Reviser: Efficiently updating IDE-/IFDS-based data-flow analyses in response to incremental program changes. In Proceedings of the 36th International Conference on Software Engineering. ACM, 288--298.  |SSA based IR in WALA. 2018. Retrieved January 23, 2019 from https://github.com/wala/WALA/wiki/Intermediate-Representation-(IR).|Michael A. Bender, Jeremy T. Fineman, Seth Gilbert, and Robert E. Tarjan. 2016. A new approach to incremental cycle detection and related problems. ACM Trans. Algorithms 12, 2 (2016), 14:1--14:22.  |G\u00e1bor Bergmann, Istv\u00e1n R\u00e1th, Tam\u00e1s Szab\u00f3, Paolo Torrini, and D\u00e1niel Varr\u00f3. 2012. Incremental pattern matching for the efficient computation of transitive closure. In Graph Transformations. Springer Berlin Heidelberg, 386--400.  |S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovi\u0107, T. VanDrunen, D. von Dincklage, and B. Wiedermann. 2006. The DaCapo benchmarks: Java benchmarking development and analysis. In Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications. ACM, 169--190.  |Eric Bodden, Andreas Sewe, Jan Sinschek, Hela Oueslati, and Mira Mezini. 2011. Taming reflection: Aiding static analysis in the presence of reflection and custom class loaders. In Proceedings of the 33rd International Conference on Software Engineering. ACM, 241--250.  |Martin Bravenboer and Yannis Smaragdakis. 2009. Exception analysis and points-to analysis: Better together. In Proceedings of the 18th International Symposium on Software Testing and Analysis. ACM, 1--12.  |Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative specification of sophisticated points-to analyses. In Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications. ACM, 243--262.  |Michael G. Burke, Paul R. Carini, Jong-Deok Choi, and Michael Hind. 1994. Flow-insensitive interprocedural alias analysis in the presence of pointers. In Proceedings of the 7th International Workshop of Languages and Compilers for Parallel Computing. Springer-Verlag, 234--250. |Arnab De and Deepak D\u2019Souza. 2012. Scalable flow-sensitive pointer analysis for Java with strong updates. In Proceedings of the 26th European Conference on Object-Oriented Programming. Springer-Verlag, 665--687.  |Jens Dietrich, Nicholas Hollingum, and Bernhard Scholz. 2015. Giga-scale exhaustive points-to analysis for Java in under a minute. In Proceedings of the ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications. ACM, 535--551.  |Jens Dietrich, Nicholas Hollingum, and Bernhard Scholz. 2016. A note on the soundness of difference propagation. In Proceedings of the 18th Workshop on Formal Techniques for Java-like Programs. ACM, 3:1--3:5.  |LLVM discussions on pointer analysis. 2016. Retrieved January 28, 2019 from http://lists.llvm.org/pipermail/llvm-dev/2016-March/096851.html.|Marcus Edvinsson, Jonas Lundberg, and Welf L\u00f6we. 2011. Parallel points-to analysis for multi-core machines. In Proceedings of the 6th International Conference on High Performance and Embedded Architectures and Compilers. ACM, 45--54.  |Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. 1994. Context-sensitive interprocedural points-to analysis in the presence of function pointers. In Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation. ACM, 242--256.  |Charles L. Forgy. 1982. Rete: A fast algorithm for the many pattern/many object pattern match problem. Artif. Intell. 19, 1 (1982), 17--37.  |Neville Grech and Yannis Smaragdakis. 2017. P/Taint: Unified points-to and taint analysis. Proceedings of the ACM on Programming Languages (OOPSLA\u201917). ACM, 102:1--102:28.  |David Grove and Craig Chambers. 2001. A framework for call graph construction algorithms. ACM Trans. Program. Lang. Syst. 23, 6 (2001), 685--746.  |Ashish Gupta, Inderpal Singh Mumick, and V. S. Subrahmanian. 1993. Maintaining views incrementally. In Proceedings of the ACM SIGMOD International Conference on Management of Data. ACM, 157--166.  |Ben Hardekopf and Calvin Lin. 2007. The ant and the grasshopper: Fast and accurate pointer analysis for millions of lines of code. In Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 290--299.  |Ben Hardekopf and Calvin Lin. 2009. Semi-sparse flow-sensitive pointer analysis. In Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, 226--238.  |Ben Hardekopf and Calvin Lin. 2011. Flow-sensitive pointer analysis for millions of lines of code. In Proceedings of the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization. IEEE Computer Society, 289--298. |Nevin Heintze and Olivier Tardieu. 2001. Demand-driven pointer analysis. In Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation. ACM, 24--34.  |Michael Hind. 2001. Pointer analysis: Haven\u2019t we solved this problem yet?. In Proceedings of the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering. ACM, 54--61.  |Michael Hind, Michael Burke, Paul Carini, and Jong-Deok Choi. 1999. Interprocedural pointer alias analysis. ACM Trans. Program. Lang. Syst. 21, 4 (1999), 848--894.  |Pointer Analysis in WALA. 2017. Retrieved January 28, 2019 from http://wala.sourceforge.net/wiki/index.php/UserGuide:PointerAnalysis.|IPA. 2018. https://github.com/april1989/Incremental_Points_to_Analysis.|George Kastrinis and Yannis Smaragdakis. 2013. Efficient and effective handling of exceptions in Java points-to analysis. In Proceedings of the 22nd International Conference on Compiler Construction. Springer-Verlag, 41--60.  |George Kastrinis and Yannis Smaragdakis. 2013. Hybrid context-sensitivity for points-to analysis. In Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 423--434.  |J. A. La Poutr\u00e9 and J. van Leeuwen. 1988. Maintenance of transitive closures and transitive reductions of graphs. In Proceedings of the International Workshop on Graph-theoretic Concepts in Computer Science. Springer-Verlag, 106--120. |William Landi and Barbara G. Ryder. 1991. Pointer-induced aliasing: A problem classification. In Proceedings of the 18th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, 93--103.  |William Alexander Landi. 1992. Interprocedural Aliasing in the Presence of Pointers. Ph.D. Dissertation. Rutgers University.|WALA language-independent IDE support. 2018. Retrieved January 28, 2019 from https://github.com/wala/IDE.|Ond\u0159ej Lhot\u00e1k. 2002. Spark: A flexible points-to analysis framework for Java. Master\u2019s thesis. McGill University, Montreal.|Ond\u0159ej Lhot\u00e1k and Laurie Hendren. 2008. Evaluating the benefits of context-sensitive points-to analysis using a BDD-based implementation. ACM Trans. Softw. Eng. Methodol. 18, 1 (2008), 3:1--3:53.  |Lian Li, Cristina Cifuentes, and Nathan Keynes. 2011. Boosting the performance of flow-sensitive points-to analysis using value flow. In Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering. ACM, 343--353.  |Yue Li, Tian Tan, Yulei Sui, and Jingling Xue. 2014. Self-inferencing reflection resolution for Java. In Proceedings of the 28th European Conference on Object-Oriented Programming. Springer-Verlag, 27--53.  |Bozhen Liu and Jeff Huang. 2018. D4: Fast concurrency debugging with parallel differential analysis. In Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 359--373.  |Yanhong A. Liu and Scott D. Stoller. 2009. From datalog rules to efficient programs with time and space guarantees. ACM Trans. Program. Lang. Syst. 31, 6 (2009), 21:1--21:38.  |Benjamin Livshits, John Whaley, and Monica S. Lam. 2005. Reflection analysis for Java. In Proceedings of the 3rd Asian Conference on Programming Languages and Systems. Springer-Verlag, 139--160.  |LogicBlox. 2018. LogiQL. Retrieved January 28, 2019 from http://www.logicblox.com/technology/.|Yi Lu, Lei Shang, Xinwei Xie, and Jingling Xue. 2013. An incremental points-to analysis with CFL-reachability. In Proceedings of the 22nd International Conference on Compiler Construction. Springer-Verlag, 61--81.  |Nick Malone, Kendra Lesser, Meeko Oishi, and Lydia Tapia. 2014. Stochastic reachability based motion planning for multiple moving obstacle avoidance. In Proceedings of the 17th International Conference on Hybrid Systems: Computation and Control. ACM, 51--60.  |Thomas J. Marlowe and Barbara G. Ryder. 1990. An efficient hybrid algorithm for incremental data flow analysis. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, 184--196.  |Mario M\u00e9ndez-Lojo, Martin Burtscher, and Keshav Pingali. 2012. A GPU implementation of inclusion-based points-to analysis. In Proceedings of the 17th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming. ACM, 107--116.  |Mario M\u00e9ndez-Lojo, Augustine Mathew, and Keshav Pingali. 2010. Parallel inclusion-based points-to analysis. In Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications. ACM, 428--443.  |Ana Milanova, Atanas Rountev, and Barbara G. Ryder. 2005. Parameterized object sensitivity for points-to analysis for Java. ACM Trans. Softw. Eng. Methodol. 14, 1 (2005), 1--41.  |Boris Motik, Yavor Nenov, Robert Piro, and Ian Horrocks. 2015. Incremental update of datalog materialisation: The backward/forward algorithm. In Proceedings of the 29th AAAI Conference on Artificial Intelligence. AAAI Press, 1560--1568. |Vaivaswatha Nagaraj and R. Govindarajan. 2013. Parallel flow-sensitive pointer analysis by graph-rewriting. In Proceedings of the 22nd International Conference on Parallel Architectures and Compilation Techniques. IEEE Press, 19--28. |Y. K. Hwang and P. C. Chen. 1998. SANDROS: A dynamic graph search algorithm for motion planning. IEEE Transactions on Robotics and Automation 4, 3 (1998), 390--403.|David J. Pearce, Paul H. J. Kelly, and Chris Hankin. 2007. Efficient field-sensitive pointer analysis of C. ACM Trans. Program. Lang. Syst. 30, 1 (2007).  |Sandeep Putta and Rupesh Nasre. 2012. Parallel replication-based points-to analysis. In Proceedings of the 21st International Conference on Compiler Construction. Springer-Verlag, 61--80.  |G. Ramalingam. 1994. The undecidability of aliasing. ACM Trans. Program. Lang. Syst. 16, 5 (1994), 1467--1471.  |Thomas Reps, Susan Horwitz, and Mooly Sagiv. 1995. Precise interprocedural dataflow analysis via graph reachability. In Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, 49--61.  |Barbara G. Ryder. 1983. Incremental data flow analysis. In Proceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages. ACM, 167--176.  |Barbara G. Ryder. 2003. Dimensions of precision in reference analysis of object-oriented programming languages. In Proceedings of the 12th International Conference on Compiler Construction. Springer-Verlag, 126--137. |Diptikalyan Saha and C. R. Ramakrishnan. 2005. Incremental and demand-driven points-to analysis using logic programming. In Proceedings of the 7th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming. ACM, 117--128.  |Diptikalyan Saha and C. R. Ramakrishnan. 2005. Symbolic support graph: A space efficient data structure for incremental tabled evaluation. In Logic Programming. Springer Berlin Heidelberg, 235--249.  |Diptikalyan Saha and C. R. Ramakrishnan. 2006. A local algorithm for incremental evaluation of tabled logic programs. In Logic Programming. Springer Berlin Heidelberg, 56--71.  |Lei Shang, Yi Lu, and Jingling Xue. 2012. Fast and precise points-to analysis with incremental CFL-reachability summarisation: Preliminary experience. In Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering. ACM, 270--273.  |Olin Shivers. 1991. Control-Flow Analysis of Higher-Order Languages. Ph.D. Dissertation. Carnegie Mellon University, Pittsburgh, PA. |Yannis Smaragdakis and George Balatsouras. 2015. Pointer analysis. Found. Trends Program. Lang. 2, 1 (2015), 1--69.  |Yannis Smaragdakis, George Kastrinis, and George Balatsouras. 2014. Introspective analysis: Context-sensitivity, across the board. In Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 485--495.  |Robert Smith, Aaron Sloman, and John. Gibson. 1992. POPLOG\u2019s two-level virtual machine support for interactive languages. In Research Directions in Cognitive Science Volume 5: Artificial Intelligence. Psychology Press, 203--231.|Johannes Sp\u00e4th, Lisa Nguyen Quang Do, Karim Ali, and Eric Bodden. 2016. Boomerang: Demand-driven flow- and context-sensitive pointer analysis for Java. In 30th European Conference on Object-Oriented Programming, Vol. 56. Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik, 22:1--22:26.|Vugranam C. Sreedhar, Michael Burke, and Jong-Deok Choi. 2000. A framework for interprocedural optimization in the presence of dynamic class loading. In Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation. ACM, 196--207.  |Vugranam C. Sreedhar, Guang R. Gao, and Yong-Fong Lee. 1998. A new framework for elimination-based data flow analysis using DJ graphs. ACM Trans. Program. Lang. Syst. 20, 2 (1998), 388--435.  |Manu Sridharan and Rastislav Bod\u00edk. 2006. Refinement-based context-sensitive points-to analysis for Java. In Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM,387--400.  |Manu Sridharan, Satish Chandra, Julian Dolby, Stephen J. Fink, and Eran Yahav. 2013. Alias Analysis for Object-oriented Programs. In Aliasing in Object-Oriented Programming, ed. David, Clarke, Tobias Wrigstad, James Noble. Springer-Verlag, 196--232. |Manu Sridharan and Stephen J. Fink. 2009. The complexity of Andersen\u2019s analysis in practice. In Proceedings of the 16th International Symposium on Static Analysis. Springer-Verlag, 205--221.  |Manu Sridharan, Denis Gopan, Lexin Shan, and Rastislav Bod\u00edk. 2005. Demand-driven points-to analysis for Java. In Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications. ACM, 59--76.  |Bjarne Steensgaard. 1996. Points-to analysis in almost linear time. In Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, 32--41.  |Yu Su, Ding Ye, and Jingling Xue. 2014. Parallel pointer analysis with CFL-reachability. In Proceedings of the Brazilian Conference on Intelligent Systems. IEEE Computer Society, 451--460.  |Yulei Sui, Sen Ye, Jingling Xue, and Pen-Chung Yew. 2011. SPAS: Scalable path-sensitive pointer analysis on full-sparse SSA. In Proceedings of the 9th Asian Conference on Programming Languages and Systems. Springer-Verlag, 155--171.  |Galois System. 2018. Retrieved January 28, 2019 from http://iss.ices.utexas.edu/.|Tam\u00e1s Szab\u00f3, Sebastian Erdweg, and Markus Voelter. 2016. IncA: A DSL for the definition of incremental program analyses. In Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering. ACM, 320--331.  |Tian Tan, Yue Li, and Jingling Xue. 2017. Efficient and precise points-to analysis: Modeling the heap by merging equivalent automata. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 278--291.  |Robert Tarjan. 1972. Depth first search and linear graph algorithms. SIAM J, Comput. 1, 2 (1972).|K. Tuncay Tekle and Yanhong A. Liu. 2016. Precise complexity guarantees for pointer analysis via datalog with extensions. TPLP 16 (2016), 916--932.|Zolt\u00e1n Ujhelyi, G\u00e1bor Bergmann, \u00c1bel Heged\u00fcs, \u00c1kos Horv\u00e1th, Benedek Izs\u00f3, Istv\u00e1n R\u00e1th, Zolt\u00e1n Szatm\u00e1ri, and D\u00e1niel Varr\u00f3. 2015. EMF-IncQuery: An integrated development environment for live model queries. Sci. Comput. Program. 98 (2015), 80--99.  |Raja Vall\u00e9e-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick Lam, and Vijay Sundaresan. 1999. Soot - a Java bytecode optimization framework. In Proceedings of the Conference of the Centre for Advanced Studies on Collaborative Research. IBM Press, 1--11. |WALA. 2017. T. J. Watson Libraries for Analysis (WALA). Retrieved January 28, 2019 from http://wala.sourceforge.net/.|John Whaley and Monica S. Lam. 2004. Cloning-based context-sensitive pointer alias analysis using binary decision diagrams. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM, 131--144.  |Jyh-shiarn Yur, Barbara G. Ryder, and William A. Landi. 1999. An incremental flow- and context-sensitive pointer aliasing analysis. In Proceedings of the 21st International Conference on Software Engineering. ACM, 442--451.  |Sheng Zhan and Jeff Huang. 2016. ECHO: Instantaneous in situ race detection in the IDE. In Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering. ACM, 775--786.  |Jisheng Zhao, Michael G. Burke, and Vivek Sarkar. 2018. Parallel sparse flow-sensitive points-to analysis. In Proceedings of the 27th International Conference on Compiler Construction. ACM, 59--70.  |", "organization": "Texas A8M University, College Station, TX, USA|Texas A8M University, College Station, TX, USA|Texas A8M University, College Station, TX, USA|Texas A8M University, College Station, TX, USA|Texas A8M University, College Station, TX, USA|Texas A8M University, College Station, TX, USA|", "title": ["Rethinking Incremental and Parallel Pointer Analysis"]},
{"abstract": "Some interesting communication protocols can be precisely described only by context-free session types, an extension of conventional session types supporting a general form of sequential composition. The complex metatheory of context-free session types, however, hinders the definition of corresponding checking and inference algorithms. In this work, we study a new syntax-directed type system for context-free session types that is easy to embed into a host programming language. We also detail 2 OCaml embeddings that allow us to piggyback on OCaml\u2019s type system to check and infer context-free session types.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Luca Padovani|Luca Padovani|", "references": "", "organization": "Universit\u00e0 di Torino, Torino, Italy|Universit\u00e0 di Torino, Torino, Italy|", "title": ["Context-Free Session Type Inference"]},
{"abstract": "Dependent types are a key feature of the proof assistants based on the Curry-Howard isomorphism. It is well known that this correspondence can be extended to classical logic by enriching the language of proofs with control operators. However, they are known to misbehave in the presence of dependent types, unless dependencies are restricted to values. Moreover, while sequent calculi naturally support continuation-passing-style interpretations, there is no such presentation of a language with dependent types. The main achievement of this article is to give a sequent calculus presentation of a call-by-value language with a control operator and dependent types, and to justify its soundness through a continuation-passing-style translation.\nWe start from the call-by-value version of the \n-calculus. We design a minimal language with a value restriction and a type system that includes a list of explicit dependencies to maintain type safety. We then show how to relax the value restriction and introduce delimited continuations to directly prove the consistency by means of a continuation-passing-style translation. Finally, we relate our calculus to a similar system by Lepigre and present a methodology to transfer properties from this system to our own.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "\u00c9tienne Miquey|\u00c9tienne Miquey|", "references": "", "organization": "INRIA, \u00c9quipe Gallinette, B\u00e2timent, Nantes|INRIA, \u00c9quipe Gallinette, B\u00e2timent, Nantes|", "title": ["A Classical Sequent Calculus with Dependent Types"]},
{"abstract": "We prove that the observational equivalence problem for a finitary fragment of the programming langauge ML is recursively equivalent to the reachability problem for \n (EBVASS). This result has two natural and independent parts. We first prove that the observational equivalence problem is equivalent to the emptiness problem for a new class of class memory automata equipped with a visibly pushdown stack, called \n (VPCMA). Our proof uses the fully abstract game semantics of the language. We then prove that the VPCMA emptiness problem is equivalent to the reachability problem for EBVASS. The results of this article complete our programme to give an automata classification of the ML types with respect to the observational equivalence problem for closed terms.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Conrad Cotton-Barratt|Andrzej S. Murawski|C.-H. Luke Ong|Conrad Cotton-Barratt|Andrzej S. Murawski|C.-H. Luke Ong|", "references": "", "organization": "Jump Trading London, London, UK|University of Oxford, Oxford, UK|University of Oxford, Oxford, UK|Jump Trading London, London, UK|University of Oxford, Oxford, UK|University of Oxford, Oxford, UK|", "title": ["ML, Visibly Pushdown Class Memory Automata, and Extended Branching Vector Addition Systems with States"]},
{"abstract": "We present a new machine-learning algorithm with disjunctive model for data-driven program analysis. One major challenge in static program analysis is a substantial amount of manual effort required for tuning the analysis performance. Recently, data-driven program analysis has emerged to address this challenge by automatically adjusting the analysis based on data through a learning algorithm. Although this new approach has proven promising for various program analysis tasks, its effectiveness has been limited due to simple-minded learning models and algorithms that are unable to capture sophisticated, in particular disjunctive, program properties. To overcome this shortcoming, this article presents a new disjunctive model for data-driven program analysis as well as a learning algorithm to find the model parameters. Our model uses Boolean formulas over atomic features and therefore is able to express nonlinear combinations of program properties. A key technical challenge is to efficiently determine a set of good Boolean formulas, as brute-force search would simply be impractical. We present a stepwise and greedy algorithm that efficiently learns Boolean formulas. We show the effectiveness and generality of our algorithm with two static analyzers: context-sensitive points-to analysis for Java and flow-sensitive interval analysis for C. Experimental results show that our automated technique significantly improves the performance of the state-of-the-art techniques including ones hand-crafted by human experts.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Minseok Jeon|Sehun Jeong|Sungdeok Cha|Hakjoo Oh|Minseok Jeon|Sehun Jeong|Sungdeok Cha|Hakjoo Oh|", "references": "", "organization": "Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|Korea University, Republic of Korea|", "title": ["A Machine-Learning Algorithm with Disjunctive Model for Data-Driven Program Analysis"]},
{"abstract": "Rigorous estimation of maximum floating-point round-off errors is an important capability central to many formal verification tools. Unfortunately, available techniques for this task often provide very pessimistic overestimates, causing unnecessary verification failure. We have developed a new approach called \n that avoids these problems, and implemented a new tool called FPTaylor embodying this approach. Key to our approach is the use of rigorous global optimization, instead of the more familiar interval arithmetic, affine arithmetic, and/or SMT solvers. FPTaylor emits per-instance analysis certificates in the form of HOL Light proofs that can be machine checked.\nIn this article, we present the basic ideas behind Symbolic Taylor Expansions in detail. We also survey as well as thoroughly evaluate six tool families, namely, Gappa (two tool options studied), Fluctuat, PRECiSA, Real2Float, Rosa, and FPTaylor (two tool options studied) on 24 examples, running on the same machine, and taking care to find the best options for running each of these tools. This study demonstrates that FPTaylor estimates round-off errors within much tighter bounds compared to other tools on a significant number of case studies. We also release FPTaylor along with our benchmarks, thus contributing to future studies and tool development in this area.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Alexey Solovyev|Marek S. Baranowski|Ian Briggs|Charles Jacobsen|Zvonimir Rakamari\u0107|Ganesh Gopalakrishnan|Alexey Solovyev|Marek S. Baranowski|Ian Briggs|Charles Jacobsen|Zvonimir Rakamari\u0107|Ganesh Gopalakrishnan|", "references": "Jean-Marc Alliot, Nicolas Durand, David Gianazza, and Jean-Baptiste Gotteland. 2012a. Finding and proving the optimum: Cooperative stochastic and deterministic search. In Proceedings of the 20th European Conference on Artificial Intelligence (ECAI\u201912). ACM, 55--60. |Jean-Marc Alliot, Nicolas Durand, David Gianazza, and Jean-Baptiste Gotteland. 2012b. Implementing an interval computation library for OCaml on x86/AMD64 architectures (short paper). In Proceedings of the International Conference on Functional Programming (ICFP\u201912). ACM.|Marc Andrysco, Ranjit Jhala, and Sorin Lerner. 2016. Printing floating-point numbers: A faster, always correct method. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201916). ACM, 555--567.  |Earl T. Barr, Thanh Vo, Vu Le, and Zhendong Su. 2013. Automatic detection of floating-point exceptions. In Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201913). ACM, 549--560.  |Jesse Bingham and Joe Leslie-Hurd. 2014. Verifying relative error bounds using symbolic simulation. In Proceedings of the 26th International Conference on Computer Aided Verification (CAV\u201914). Springer, 277--292.  |Sylvie Boldo, Fran\u00e7ois Cl\u00e9ment, Jean-Christophe Filli\u00e2tre, Micaela Mayero, Guillaume Melquiond, and Pierre Weis. 2013. Wave equation numerical resolution: A comprehensive mechanized proof of a C program. Journal of Automated Reasoning (JAR) 50, 4 (2013), 423--456.  |Sylvie Boldo, Jean-Christophe Filli\u00e2tre, and Guillaume Melquiond. 2009. Combining Coq and Gappa for certifying floating-point programs. In Proceedings of the 16th Symposium on the Integration of Symbolic Computation and Mechanised Reasoning (CALCULEMUS\u201909). Springer, 59--74.  |Sylvie Boldo, Jacques-Henri Jourdan, Xavier Leroy, and Guillaume Melquiond. 2015. Verified compilation of floating-point computations. Journal of Automated Reasoning (JAR) 54, 2 (2015), 135--163.  |Sylvie Boldo and Guillaume Melquiond. 2011. Flocq: A unified library for proving floating-point algorithms in Coq. In Proceedings of the IEEE Symposium on Computer Arithmetic. 243--252.  |Angelo Brillout, Daniel Kroening, and Thomas Wahl. 2009. Mixed abstractions for floating-point arithmetic. In Formal Methods in Computer-Aided Design (FMCAD\u201909). 69--76.|Liqian Chen, Antoine Min\u00e9, and Patrick Cousot. 2008. A sound floating-point polyhedra abstract domain. In Proceedings of the 6th Asian Symposium on Programming Languages and Systems (APLAS\u201908). Springer, 3--18.  |Wei-Fan Chiang, Mark Baranowski, Ian Briggs, Alexey Solovyev, Ganesh Gopalakrishnan, and Zvonimir Rakamari\u0107. 2017. Rigorous floating-point mixed-precision tuning. In Proceedings of the ACM SIGPLAN Symposium on Principles of Programming Languages (POPL\u201917). ACM, 300--315.  |Wei-Fan Chiang, Ganesh Gopalakrishnan, Zvonimir Rakamari\u0107, and Alexey Solovyev. 2014. Efficient search for inputs causing high floating-point errors. In Proceedings of the 19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP\u201914). ACM, 43--52.  |Alessandro Cimatti, Alberto Griggio, BastiaanJoost Schaafsma, and Roberto Sebastiani. 2013. The MathSAT5 SMT solver. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201913), Lecture Notes in Computer Science, Vol. 7795. Springer, 93--107.  |Coq 2016. The Coq Proof Assistant. http://coq.inria.fr.|Patrick Cousot and Radhia Cousot. 1977. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL\u201977). ACM, 238--252.  |Patrick Cousot, Radhia Cousot, Jer\u00f4me Feret, Laurent Mauborgne, Antoine Min\u00e9, David Monniaux, and Xavier Rival. 2005. The ASTR\u00c9E analyser. In Proceedings of the 14th European Symposium on Programming Languages and Systems (ESOP\u201905), Lecture Notes in Computer Science, Vol. 3444. Springer, 21--30.  |Nasrine Damouche, Matthieu Martel, and Alexandre Chapoutot. 2017. Improving the numerical accuracy of programs by automatic transformation. International Journal on Software Tools for Technology Transfer (STTT) 19, 4 (2017), 427--448.  |Catherine Daramy, David Defour, Florent de Dinechin, and Jean-Michel Muller. 2003. CR-LIBM: A correctly rounded elementary function library. Advanced Signal Processing Algorithms, Architectures, and Implementations XIII, SPIE 5205 (2003), 458--464.|Eva Darulova and Viktor Kuncak. 2011. Trustworthy numerical computation in Scala. In Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA\u201911). ACM, 325--344.  |Eva Darulova and Viktor Kuncak. 2014. Sound compilation of reals. In Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201914). ACM, 235--248.  |Eva Darulova and Viktor Kuncak. 2017. Towards a compiler for reals. ACM Trans. Program. Lang. Syst. 39, 2 (2017), 8:1--8:28.  |Marc Daumas and Guillaume Melquiond. 2010. Certification of bounds on expressions involving rounded operators. ACM Trans. Math. Software 37, 1 (2010), Article 2, 20 pages.  |Leonardo de Moura and Nikolaj Bj\u00f8rner. 2008. Z3: An efficient SMT solver. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201908), Lecture Notes in Computer Science, Vol. 4963. Springer, Berlin, 337--340. |David Delmas, Eric Goubault, Sylvie Putot, Jean Souyris, Karim Tekkal, and Franck V\u00e9drine. 2009. Towards an industrial use of FLUCTUAT on safety-critical avionics software. In Formal Methods for Industrial Critical Systems (FMICS\u201909), Lecture Notes in Computer Science, Vol. 5825. Springer, Berlin, 53--69.  |Laurent Fousse, Guillaume Hanrot, Vincent Lef\u00e8vre, Patrick P\u00e9lissier, and Paul Zimmermann. 2007. MPFR: A multiple-precision binary floating-point library with correct rounding. ACM Trans. Math. Software 33, 2 (2007).  |Frama-C 2017. Frama-C Software Analyzers. Retrieved October 13, 2017 from http://frama-c.com/index.html.|Sicun Gao, Soonho Kong, and Edmund M. Clarke. 2013. dReal: An SMT solver for nonlinear theories over the reals. In Proceedings of the 24th International Conference on Automated Deduction (CADE\u201913). 208--214.  |Attila G\u00e1ti. 2012. Miller analyzer for Matlab: A Matlab package for automatic roundoff analysis. Comput. Inf. 31, 4 (2012), 713--726.|Gelpia 2017. Gelpia: A Global Optimizer for Real Functions. Retrieved October 13, 2017 from https://github.com/soarlab/gelpia.|Dimitra Giannakopoulou, Falk Howar, Malte Isberner, Todd Lauderdale, Zvonimir Rakamari\u0107, and Vishwanath Raman. 2014. Taming test inputs for separation assurance. In Proceedings of the 29th IEEE/ACM International Conference on Automated Software Engineering (ASE\u201914). ACM, 373--384.  |David Goldberg. 1991. What every computer scientist should know about floating-point arithmetic. Comput. Surveys 23, 1 (March 1991), 5--48.  |Alwyn Goodloe, C\u00e9sar Mu\u00f1oz, Florent Kirchner, and Lo\u00efc Correnson. 2013. Verification of numerical programs: From real numbers to floating point numbers. In Proceedings of the 5th NASA Formal Methods Symposium (NFM\u201913), Lecture Notes in Computer Science, Vol. 7871. Springer, 441--446.|Fr\u00e9d\u00e9ric Goualard. 2014. How do you compute the midpoint of an interval? ACM Trans. Math. Software 40, 2, Article 11 (2014), 25 pages.  |Fr\u00e9d\u00e9ric Goualard. 2017. GAOL (Not Just Another Interval Library). Retrieved October 13, 2017 from http://frederic.goualard.net/#research-software.|Eric Goubault and Sylvie Putot. 2011. Static analysis of finite precision computations. In Proceedings of the International Workshop on Verification, Model Checking, and Abstract Interpretation (VMCAI\u201911), Lecture Notes in Computer Science, Vol. 6538. Springer, Berlin, 232--247. |Leopold Haller, Alberto Griggio, Martin Brain, and Daniel Kroening. 2012. Deciding floating-point logic with systematic abstraction. In Formal Methods in Computer-Aided Design (FMCAD\u201912). 131--140.|John Harrison. 2000. Formal verification of floating point trigonometric functions. In Proceedings of the 3rd International Conference on Formal Methods in Computer-Aided Design (FMCAD\u201900), Lecture Notes in Computer Science, Vol. 1954. Springer, 254--270. |John Harrison. 2006. Floating-point verification using theorem proving. In SFM 2006. Lecture Notes in Computer Science, Vol. 3965. Springer Berlin Heidelberg, 211--242.  |John Harrison. 2009. HOL light: An overview. In TPHOLs 2009, Lecture Notes in Computer Science, Vol. 5674. Springer Berlin Heidelberg, 60--66.  |2008. IEEE Standard for floating-point arithmetic. IEEE Std 754-2008 (2008), 1--70.|Charles Jacobsen, Alexey Solovyev, and Ganesh Gopalakrishnan. 2015. A parameterized floating-point formalization in HOL light. Electro. Notes Theor. Comput. Sci. 317 (2015), 101--107.  |Steven G. Johnson. 2017. The NLopt Nonlinear-Optimization Package. Retrieved October 13, 2017 from https://nlopt.readthedocs.io/en/latest/.|William Kahan. 2006. How Futile Are Mindless Assessments of Roundoff in Floating-Point Computation? Retrieved October 13, 2017 from https://people.eecs.berkeley.edu/&sim;wkahan/Mindless.pdf.|R. Baker Kearfott. 2009. GlobSol user guide. Opt. Methods Softw. 24, 4--5 (2009), 687--708.  |Yahia Lebbah. 2009. ICOS: A branch and bound based solver for rigorous global optimization. Optim. Methods Softw. 24, 4--5 (2009), 709--726.  |Wonyeol Lee, Rahul Sharma, and Alex Aiken. 2016. Verifying bit-manipulations of floating-point. In Proceedings of the 37th Annual ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201916). 70--84.  |Miriam Leeser, Saoni Mukherjee, Jaideep Ramachandran, and Thomas Wahl. 2014. Make it real: Effective floating-point reasoning via exact arithmetic. In Proceedings of the Conference on Design, Automation 8 Test in Europe (DATE\u201914). 1--4. |Michael D. Linderman, Matthew Ho, David L. Dill, Teresa H. Meng, and Garry P. Nolan. 2010. Towards program optimization through automated analysis of numerical precision. In Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO\u201910). ACM, 230--237.  |Victor Magron, George Constantinides, and Alastair Donaldson. 2017. Certified roundoff error bounds using semidefinite programming. ACM Trans. Math. Software 43, 4 (Jan. 2017), Article 34, 31 pages.  |Matthieu Martel. 2006. Semantics of roundoff error propagation in finite precision calculations. High.-Order Symb. Comput. 19, 1 (2006), 7--30.  |Matthieu Martel. 2009. Program transformation for numerical precision. In Proceedings of the 2009 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation (PEPM\u201909). ACM, 101--110.  |Matthieu Martel. 2011. RangeLab: A static-analyzer to bound the accuracy of finite-precision computations. In Proceedings of the 13th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC\u201911). IEEE Computer Society, 118--122.  |\u00c9rik Martin-Dorel, Laurence Rideau, Laurent Th\u00e9ry, Micaela Mayero, and Ioana Pasca. 2013. Certified, efficient and sharp univariate Taylor models in Coq. In Proceedings of the 2013 15th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC\u201913). IEEE, 193--200.  |Maxima. 2013. Maxima, a Computer Algebra System. Version 5.30.0. Retrieved April 3, 2013 from http://maxima.sourceforge.net/.|Guillaume Melquiond. 2012. Floating-point arithmetic in the Coq system. Inf. Comput. 216 (2012), 14--23.  |Piotr Mikusinski and Michael Taylor. 2002. An Introduction to Multivariable Analysis from Vector to Manifold. Birkh\u00e4user Boston.|Webb Miller. 1975. Software for roundoff analysis. ACM. Math. Softw. 1, 2 (1975), 108--128.  |R. E. Moore. 1966. Interval Analysis. Prentice-Hall.|Mark P. W. Mutrie, Richard H. Bartels, and Bruce W. Char. 1992. An approach for floating-point error analysis using computer algebra. In Papers from the International Symposium on Symbolic and Algebraic Computation (ISSAC\u201992). ACM, 284--293.  |Anthony Narkawicz and C\u00e9sar Munoz. 2013. A formally verified generic branching algorithm for global optimization. In Working Conference on Verified Software: Theories, Tools, and Experiments. Springer, 326--343.  |NASA. 2017. NASA World Wind Java SDK. Retrieved October 13, 2017 from http://worldwind.arc.nasa.gov/java/.|Arnold Neumaier. 2003. Taylor forms\u2014Use and limits. Reliab. Comput. 9, 1 (Feb. 2003), 43--79.|Arnold Neumaier. 2004. Complete search in continuous global optimization and constraint satisfaction. Acta Num. 13 (2004), 271--369.|OpenOpt. 2017. OpenOpt: Universal Numerical Optimization Package. Retrieved October 13, 2017 from http://openopt.org.|Gabriele Paganelli and Wolfgang Ahrendt. 2013. Verifying (in-)stability in floating-point programs by increasing precision, using SMT solving. In Symbolic and Numeric Algorithms for Scientific Computing (SYNASC\u201913). 209--216.  |Pavel Panchekha, Alex Sanchez-Stern, James R. Wilcox, and Zachary Tatlock. 2015. Automatically improving accuracy for floating point expressions. In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201915). ACM, 1--11.  |Olivier Ponsini, Claude Michel, and Michel Rueher. 2014. Verifying floating-point programs with constraint programming and abstract interpretation techniques. Autom. Softw. Eng. (2014), 1--27.  |Zvonimir Rakamari\u0107 and Michael Emmi. 2014. SMACK: Decoupling source language details from verifier implementations. In Computer Aided Verification (CAV\u201914), Lecture Notes in Computer Science, Vol. 8559. Springer International Publishing, 106--113.  |N. Revol, K. Makino, and M. Berz. 2005. Taylor models and floating-point arithmetic: Proof that arithmetic operations are validated in COSY. J. Logic Algebr.c Program. 64, 1 (2005), 135--154.|Philipp R\u00fcmmer and Thomas Wahl. 2010. An SMT-LIB theory of binary floating-point arithmetic. In Informal Proceedings of the 8th International Workshop on Satisfiability Modulo Theories (SMT Workshop\u201910).|Alexey Solovyev. 2017. TOPLAS FPTaylor Results Table. Retrieved October 10, 2017 from http://tinyurl.com/TOPLAS-FPTaylor-Results-Table.|Alexey Solovyev and Thomas C. Hales. 2013. Formal verification of nonlinear inequalities with Taylor interval approximations. In NASA Formal Methods (NFM\u201913), Lecture Notes in Computer Science, Vol. 7871. Springer, Berlin, 383--397.|Alexey Solovyev, Charles Jacobsen, Zvonimir Rakamari\u0107, and Ganesh Gopalakrishnan. 2015. Rigorous estimation of floating-point round-off errors with symbolic Taylor expansions. In Proceedings of the 20th International Symposium on Formal Methods Formal (FM\u201915). 532--550.|Jorge Stolfi and Luiz H. de Figueiredo. 2003. An introduction to affine arithmetic. TEMA Trends Appl. Comput. Math. 4, 3 (2003), 297--312.|David R. Stoutemyer. 1977. Automatic error analysis using computer algebraic manipulation. ACM Trans. Math. Software 3, 1 (1977), 26--43.  |Microsoft Support. 2018. Floating-point arithmetic may give inaccurate results in Excel. https://support.microsoft.com/en-us/help/78113/floating-point-arithmetic-may-give-inaccurate-results-in-excel Last updated April 17, 2018.|Sonja Surjanovic and Derek Bingham. 2017. Trid Function. Retrieved October 10, 2017 from http://www.sfu.ca/%7Essurjano/trid.html Tridiagonal Examples.|Laura Titolo. 2017. Schloss Dagstuhl: Seminar Homepage. Retrieved October 10, 2017 from http://www.dagstuhl.de/en/program/calendar/semhp/?semnr&equals;17352.|Eric Weisstein. 2017a. Chebyschev Polynomial of the First Kind\u2014From Wolfram MathWorld. Retrieved October 10, 2017 from http://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html.|Eric Weisstein. 2017b. Legendre Polynomial\u2014From Wolfram MathWorld. Retrieved October 13, 2017 from http://mathworld.wolfram.com/LegendrePolynomial.html.|", "organization": "School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|School of Computing, University of Utah, Salt Lake City, UT, USA|", "title": ["Rigorous Estimation of Floating-Point Round-Off Errors with Symbolic Taylor Expansions"]},
{"abstract": "Self-stabilization is an elegant approach for designing fault tolerant systems. A system is considered self-stabilizing if, starting in any state, it converges to the desired behavior. Self-stabilizing algorithms were designed for solving fundamental distributed tasks, such as leader election, token circulation and communication network protocols. The algorithms were expressed using guarded commands or pseudo-code. The realization of these algorithms requires the existence of a (self-stabilizing) infrastructure such as a self-stabilizing microprocessor and a self-stabilizing operating system for their execution. Moreover, the high-level description of the algorithms needs to be converted into machine language of the microprocessor. In this article, we present our design for a self-stabilization preserving compiler. The compiler we designed and implemented transforms programs written in a language similar to the abstract state machine (ASM). The compiler preserves the stabilization property of the high level program.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Shlomi Dolev|Yinnon Haviv|Mooly Sagiv|Shlomi Dolev|Yinnon Haviv|Mooly Sagiv|", "references": "", "organization": "Ben-Gurion University, Beer-Sheva, Israel|Ben-Gurion University, Beer-Sheva, Israel|Tel-Aviv University, Tel-Aviv, Israel|Ben-Gurion University, Beer-Sheva, Israel|Ben-Gurion University, Beer-Sheva, Israel|Tel-Aviv University, Tel-Aviv, Israel|", "title": ["Self-stabilization preserving compiler"]},
{"abstract": "Recent work on adaptive functional programming (AFP) developed techniques for writing programs that can respond to modifications to their data by performing \n. To achieve this, executions of programs are represented with \n (DDGs) that record data dependences and control dependences in a way that a change-propagation algorithm can update the computation as if the program were from scratch, by re-executing only the parts of the computation affected by the changes. Since change-propagation only re-executes parts of the computation, it can respond to certain incremental modifications asymptotically faster than recomputing from scratch, potentially offering significant speedups. Such asymptotic speedups, however, are rare: for many computations and modifications, change propagation is no faster than recomputing from scratch.\nIn this article, we realize a duality between dynamic dependence graphs and memoization, and combine them to give a change-propagation algorithm that can dramatically increase computation reuse. The key idea is to use DDGs to identify and re-execute the parts of the computation that are affected by modifications, while using memoization to identify the parts of the computation that remain unaffected by the changes. We refer to this approach as self-adjusting computation. Since DDGs are imperative, but (traditional) memoization requires purely functional computation, reusing computation correctly via memoization becomes a challenge. We overcome this challenge with a technique for remembering and reusing not just the results of function calls (as in conventional memoization), but their executions represented with DDGs. We show that the proposed approach is realistic by describing a library for self-adjusting computation, presenting efficient algorithms for realizing the library, and describing and evaluating an implementation. Our experimental evaluation with a variety of applications, ranging from simple list primitives to more sophisticated computational geometry algorithms, shows that the approach is effective in practice: compared to recomputing from-scratch; self-adjusting programs respond to small modifications to their data orders of magnitude faster.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Umut A. Acar|Guy E. Blelloch|Matthias Blume|Robert Harper|Kanat Tangwongsan|Umut A. Acar|Guy E. Blelloch|Matthias Blume|Robert Harper|Kanat Tangwongsan|", "references": "", "organization": "Toyota Technological Institute at Chicago|Carnegie Mellon University|Toyota Technological Institute at Chicago|Carnegie Mellon University|Carnegie Mellon University|Toyota Technological Institute at Chicago|Carnegie Mellon University|Toyota Technological Institute at Chicago|Carnegie Mellon University|Carnegie Mellon University|", "title": ["An experimental analysis of self-adjusting computation"]},
{"abstract": "An extension of the \u03bb-calculus is proposed, to study resource usage analysis and verification. It features usage policies with a possibly nested, local scope, and dynamic creation of resources. We define a type and effect system that, given a program, extracts a history expression, that is, a sound overapproximation to the set of histories obtainable at runtime. After a suitable transformation, history expressions are model-checked for validity. A program is resource-safe if its history expression is verified valid: If such, no runtime monitor is needed to safely drive its executions.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Massimo Bartoletti|Pierpaolo Degano|Gian-Luigi Ferrari|Roberto Zunino|Massimo Bartoletti|Pierpaolo Degano|Gian-Luigi Ferrari|Roberto Zunino|", "references": "", "organization": "Universit\u00e0 degli Studi di Cagliari, and Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 degli Studi di Trento, Povo, Italy|Universit\u00e0 degli Studi di Cagliari, and Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 di Pisa, Pisa, Italy|Universit\u00e0 degli Studi di Trento, Povo, Italy|", "title": ["Local policies for resource usage analysis"]},
{"abstract": "Traditional static type systems are effective for verifying basic interface specifications. Dynamically checked contracts support more precise specifications, but these are not checked until runtime, resulting in incomplete detection of defects. Hybrid type checking is a synthesis of these two approaches that enforces precise interface specifications, via static analysis where possible, but also via dynamic checks where necessary. This article explores the key ideas and implications of hybrid type checking, in the context of the \u03bb-calculus extended with \n, that is, with dependent function types and with arbitrary refinements of base types.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Kenneth Knowles|Cormac Flanagan|Kenneth Knowles|Cormac Flanagan|", "references": "", "organization": "University of California at Santa Cruz, Santa Cruz, CA|University of California at Santa Cruz, Santa Cruz, CA|University of California at Santa Cruz, Santa Cruz, CA|University of California at Santa Cruz, Santa Cruz, CA|", "title": ["Hybrid type checking"]},
{"abstract": "This article describes a method for transforming any given set of Datalog rules into an efficient specialized implementation with guaranteed worst-case time and space complexities, and for computing the complexities from the rules. The running time is optimal in the sense that only useful combinations of facts that lead to all hypotheses of a rule being simultaneously true are considered, and each such combination is considered exactly once in constant time. The associated space usage may sometimes be reduced using scheduling optimizations to eliminate some summands in the space usage formula. The transformation is based on a general method for algorithm design that exploits fixed-point computation, incremental maintenance of invariants, and combinations of indexed and linked data structures. We apply the method to a number of analysis problems, some with improved algorithm complexities and all with greatly improved algorithm understanding and greatly simplified complexity analysis.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Yanhong A. Liu|Scott D. Stoller|Yanhong A. Liu|Scott D. Stoller|", "references": "", "organization": "State University of New York at Stony Brook, Stony Brook, NY|State University of New York at Stony Brook, Stony Brook, NY|State University of New York at Stony Brook, Stony Brook, NY|State University of New York at Stony Brook, Stony Brook, NY|", "title": ["From datalog rules to efficient programs with time and space guarantees"]},
{"abstract": "We introduce a system of monadic affine sized types, which substantially generalizes usual sized types and allows in this way to capture probabilistic higher-order programs that terminate almost surely. Going beyond plain, strong normalization without losing soundness turns out to be a hard task, which cannot be accomplished without a richer, quantitative notion of types, but also without imposing some affinity constraints. The proposed type system is powerful enough to type classic examples of probabilistically terminating programs such as random walks. The way typable programs are proved to be almost surely terminating is based on reducibility but requires a substantial adaptation of the technique.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Ugo Dal Lago|Charles Grellois|Ugo Dal Lago|Charles Grellois|", "references": "", "organization": "University of Bologna 8 INRIA Sophia Antipolis, Bologna, Italy|INRIA Sophia Antipolis|University of Bologna 8 INRIA Sophia Antipolis, Bologna, Italy|INRIA Sophia Antipolis|", "title": ["Probabilistic Termination by Monadic Affine Sized Typing"]},
{"abstract": "This article addresses the verification of properties of imperative programs with recursive procedure calls, heap-allocated storage, and destructive updating of pointer-valued fields, that is, \n. The article makes three contributions.\n\u2014 It introduces a new method for abstracting relations over memory configurations for use in abstract interpretation.\n\u2014 It shows how this method furnishes the elements needed for a compositional approach to shape analysis. In particular, abstracted relations are used to represent the shape transformation performed by a sequence of operations, and an overapproximation to relational composition can be performed using the meet operation of the domain of abstracted relations.\n\u2014 It applies these ideas in a new algorithm for context-sensitive interprocedural shape analysis. The algorithm creates procedure summaries using abstracted relations over memory configurations, and the meet-based composition operation provides a way to apply the summary transformer for a procedure \n at each call site from which \n is called.\nThe algorithm has been applied successfully to establish properties of both (i) recursive programs that manipulate lists and (ii) recursive programs that manipulate binary trees.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bertrand Jeannet|Alexey Loginov|Thomas Reps|Mooly Sagiv|Bertrand Jeannet|Alexey Loginov|Thomas Reps|Mooly Sagiv|", "references": "", "organization": "INRIA|GrammaTech, Inc.|University of Wisconsin|Tel Aviv University|INRIA|GrammaTech, Inc.|University of Wisconsin|Tel Aviv University|", "title": ["A relational approach to interprocedural shape analysis"]},
{"abstract": "Computational grids have an enormous potential to provide compute power. However, this power remains largely unexploited today for most applications, except trivially parallel programs. Developing parallel grid applications simply is too difficult. Grids introduce several problems not encountered before, mainly due to the highly heterogeneous and dynamic computing and networking environment. Furthermore, failures occur frequently, and resources may be claimed by higher-priority jobs at any time.\nIn this article, we solve these problems for an important class of applications: divide-and-conquer. We introduce a system called Satin that simplifies the development of parallel grid applications by providing a rich high-level programming model that completely hides communication. All grid issues are transparently handled in the runtime system, not by the programmer. Satin's programming model is based on Java, features spawn-sync primitives and shared objects, and uses asynchronous exceptions and an abort mechanism to support speculative parallelism.\nTo allow an efficient implementation, Satin consistently exploits the idea that grids are hierarchically structured. Dynamic load-balancing is done with a novel cluster-aware scheduling algorithm that hides the long wide-area latencies by overlapping them with useful local work. Satin's shared object model lets the application define the consistency model it needs. If an application needs only loose consistency, it does not have to pay high performance penalties for wide-area communication and synchronization.\nWe demonstrate how grid problems such as resource changes and failures can be handled transparently and efficiently. Finally, we show that adaptivity is important in grids. Satin can increase performance considerably by adding and removing compute resources automatically, based on the application's requirements and the utilization of the machines and networks in the grid.\nUsing an extensive evaluation on real grids with up to 960 cores, we demonstrate that it is possible to provide a simple high-level programming model for divide-and-conquer applications, while achieving excellent performance on grids. At the same time, we show that the divide-and-conquer model scales better on large systems than the master-worker approach, since it has no single central bottleneck.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Rob V. Van Nieuwpoort|Gosia Wrzesi\u0144ska|Ceriel J. H. Jacobs|Henri E. Bal|Rob V. Van Nieuwpoort|Gosia Wrzesi\u0144ska|Ceriel J. H. Jacobs|Henri E. Bal|", "references": "", "organization": "Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|Vrije Universiteit Amsterdam, The Netherlands|", "title": ["Satin: A high-level and efficient grid programming model"]},
{"abstract": "Pluggable types enable users to enforce multiple type systems in one programming language. We have developed a suite of tools, called the JavaCOP framework, that allows developers to create pluggable type systems for Java. JavaCOP provides a simple declarative language in which program constraints are defined over a program's abstract syntax tree. The JavaCOP compiler automatically enforces these constraints on programs during compilation. The JavaCOP framework also includes a dataflow analysis API in order to support type systems which depend on flow-sensitive information. Finally, JavaCOP includes a novel test framework which helps users gain confidence in the correctness of their pluggable type systems. We demonstrate the framework by discussing a number of pluggable type systems which have been implemented in JavaCOP in order to detect errors and enforce strong invariants in programs. These type systems range from general-purpose checkers, such as a type system for nonnull references, to domain-specific ones, such as a checker for conformance to a library's usage rules.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Shane Markstrum|Daniel Marino|Matthew Esquivel|Todd Millstein|Chris Andreae|James Noble|Shane Markstrum|Daniel Marino|Matthew Esquivel|Todd Millstein|Chris Andreae|James Noble|", "references": "", "organization": "Bucknell University, Lewisburg, PA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|Victoria University of Wellington, Wellington, New Zealand|Victoria University of Wellington, Wellington, New Zealand|Bucknell University, Lewisburg, PA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|University of California, Los Angeles, Los Angeles, CA|Victoria University of Wellington, Wellington, New Zealand|Victoria University of Wellington, Wellington, New Zealand|", "title": ["JavaCOP: Declarative pluggable types for java"]},
{"abstract": "Modern embedded processors with dedicated address generation unit support memory accesses through auto-increment/decrement addressing mode. The auto-increment/decrement mode, if properly utilized, can save address arithmetic instructions, reduce static and dynamic memory footprint of the program, and speed up the execution as well.\nLiao [1995, 1996] categorized this problem as Simple Offset Assignment (SOA) and General Offset Assignment (GOA), which involves storage layout of variables and assignment of address registers, respectively, proposing several heuristic solutions. This article proposes a new direction for investigating the solution space of the problem. The general idea [Zhuang 2003] is to perform simplification of the underlying access graph through coalescence of the memory locations of program variables. A comprehensive framework is proposed including coalescence-based offset assignment and post/pre-optimization. Variables not interfering with others (not simultaneously live at any program point) can be coalesced into the same memory location. Coalescing allows simplifications of the access graph yielding better SOA solutions; it also reduces the address register pressure to such low values that some GOA solutions become optimal. Moreover, it can reduce the memory footprint both statically and at runtime for stack variables. Our second optimization (post/pre-optimization) considers both post- and pre-modification mode for optimizing code across basic blocks, which makes it useful. Making use of both addressing modes further reduces SOA/GOA cost and our post/pre-optimization phase is optimal in selecting post or pre mode after variable offsets have been determined.\nWe have shown the advantages of our framework over previous approaches to capture more opportunities to reduce both stack size and SOA/GOA cost, leading to more speedup.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Xiaotong Zhuang|Santosh Pande|Xiaotong Zhuang|Santosh Pande|", "references": "", "organization": "IBM T.J. Watson Research Center, New York|Georgia Institute of Technology, Atlanta, GA|IBM T.J. Watson Research Center, New York|Georgia Institute of Technology, Atlanta, GA|", "title": ["An optimization framework for embedded processors with auto-addressing mode"]},
{"abstract": "Typed Assembly Languages (TALs) are used to validate the safety of machine-language programs. The Foundational Proof-Carrying Code project seeks to verify the soundness of TALs using the smallest possible set of axioms: the axioms of a suitably expressive logic plus a specification of machine semantics. This article proposes general semantic foundations that permit modular proofs of the soundness of TALs. These semantic foundations include Typed Machine Language (TML), a type theory for specifying properties of low-level data with powerful and orthogonal type constructors, and \n, a compositional logic for specifying properties of machine instructions with simplified reasoning about unstructured control flow. Both of these components, whose semantics we specify using higher-order logic, are useful for proving the soundness of TALs. We demonstrate this by using TML and \n to verify the soundness of a low-level, typed assembly language, LTAL, which is the target of our core-ML-to-sparc compiler.\nTo prove the soundness of the TML type system we have successfully applied a new approach, that of \n. This approach provides the first semantic model for a type system with updatable references to values of impredicative quantified types. Both impredicative polymorphism and mutable references are essential when representing function closures in compilers with typed closure conversion, or when compiling objects to simpler typed primitives.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Amal Ahmed|Andrew W. Appel|Christopher D. Richards|Kedar N. Swadi|Gang Tan|Daniel C. Wang|Amal Ahmed|Andrew W. Appel|Christopher D. Richards|Kedar N. Swadi|Gang Tan|Daniel C. Wang|", "references": "", "organization": "Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|Princeton University, Princeton NJ|", "title": ["Semantic foundations for typed assembly languages"]},
{"abstract": "It is important to prove that supposedly terminating programs actually terminate, particularly if those programs must be run on critical systems or downloaded into a client such as a mobile phone. Although termination of computer programs is generally undecidable, it is possible and useful to prove termination of a large, nontrivial subset of the terminating programs. In this article, we present our termination analyzer for sequential Java bytecode, based on a program property called \n. We describe the analyses which are needed before the path-length can be computed such as sharing, cyclicity, and aliasing. Then we formally define the path-length analysis and prove it correct with respect to a reference denotational semantics of the bytecode. We show that a constraint logic program \n can be built from the result of the path-length analysis of a Java bytecode program \n and formally prove that if \n terminates, then \n also terminates. Hence a termination prover for constraint logic programs can be applied to prove the termination of \n. We conclude with some discussion of the possibilities and limitations of our approach. Ours is the first existing termination analyzer for Java bytecode dealing with any kind of data structures dynamically allocated on the heap and which does not require any help or annotation on the part of the user.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Fausto Spoto|Fred Mesnard|\u00c9tienne Payet|Fausto Spoto|Fred Mesnard|\u00c9tienne Payet|", "references": "", "organization": "Universit\u00e0 di Verona, Italy|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, France|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, France|Universit\u00e0 di Verona, Italy|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, France|IREMIA, LIM, Universit\u00e9 de la R\u00e9union, France|", "title": ["A termination analyzer for Java bytecode based on path-length"]},
{"abstract": "In this article, we present a general method for achieving global static analyzers that are precise and sound, yet also scalable. Our method, on top of the abstract interpretation framework, is a general sparse analysis technique that supports relational as well as nonrelational semantics properties for various programming languages. Analysis designers first use the abstract interpretation framework to have a global and correct static analyzer whose scalability is unattended. Upon this underlying sound static analyzer, analysis designers add our generalized sparse analysis techniques to improve its scalability while preserving the precision of the underlying analysis. Our method prescribes what to prove to guarantee that the resulting sparse version should preserve the precision of the underlying analyzer.\nWe formally present our framework and show that existing sparse analyses are all restricted instances of our framework. In addition, we show more semantically elaborate design examples of sparse nonrelational and relational static analyses. We then present their implementation results that scale to globally analyze up to one million lines of C programs. We also show a set of implementation techniques that turn out to be critical to economically support the sparse analysis process.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Hakjoo Oh|Kihong Heo|Wonchan Lee|Woosuk Lee|Daejun Park|Jeehoon Kang|Kwangkeun Yi|Hakjoo Oh|Kihong Heo|Wonchan Lee|Woosuk Lee|Daejun Park|Jeehoon Kang|Kwangkeun Yi|", "references": "", "organization": "Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|", "title": ["Global Sparse Analysis Framework"]},
{"abstract": "No abstract available.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Kathryn S. Mckinley|Keshav Pingali|Kathryn S. Mckinley|Keshav Pingali|", "references": "", "organization": "TOPLAS Editors-in-Chief|TOPLAS Editors-in-Chief|TOPLAS Editors-in-Chief|TOPLAS Editors-in-Chief|", "title": ["La prossima vita at TOPLAS"]},
{"abstract": "Dynamic software updating (DSU) systems facilitate software updates to running programs, thereby permitting developers to add features and fix bugs without downtime. This article introduces Kitsune, a DSU system for C. Kitsune\u2019s design has three notable features. First, Kitsune updates the whole program, rather than individual functions, using a mechanism that places no restrictions on data representations or allowed compiler optimizations. Second, Kitsune makes the important aspects of updating explicit in the program text, making the program\u2019s semantics easy to understand while minimizing programmer effort. Finally, the programmer can write simple specifications to direct Kitsune to generate code that traverses and transforms old-version state for use by new code; such state transformation is often necessary and is significantly more difficult in prior DSU systems. We have used Kitsune to update six popular, open-source, single- and multithreaded programs and find that few program changes are required to use Kitsune, that it incurs essentially no performance overhead, and that update times are fast.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Christopher M. Hayden|Karla Saur|Edward K. Smith|Michael Hicks|Jeffrey S. Foster|Christopher M. Hayden|Karla Saur|Edward K. Smith|Michael Hicks|Jeffrey S. Foster|", "references": "", "organization": "University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|University of Maryland, College Park, USA|", "title": ["Kitsune: Efficient, General-Purpose Dynamic Software Updating for C"]},
{"abstract": "Typestate reflects how the legal operations on imperative objects can change at runtime as their internal state changes. A typestate checker can statically ensure, for instance, that an object method is only called when the object is in a state for which the operation is well defined. Prior work has shown how modular typestate checking can be achieved thanks to access permissions and state guarantees. However, typestate was not treated as a primitive language concept: typestate checkers are an additional verification layer on top of an existing language. In contrast, a typestate-oriented programming (TSOP) language directly supports expressing typestates. For example, in the Plaid programming language, the typestate of an object directly corresponds to its class, and that class can change dynamically. Plaid objects have not only typestate-dependent interfaces but also typestate-dependent behaviors and runtime representations.\nThis article lays foundations for TSOP by formalizing a nominal object-oriented language with mutable state that integrates typestate change and typestate checking as primitive concepts. We first describe a statically typed language\u2014Featherweight Typestate (FT)\u2014where the types of object references are augmented with access permissions and state guarantees. We describe a novel flow-sensitive permission-based type system for FT. Because static typestate checking is still too rigid for some applications, we then extend this language into a gradually typed language\u2014Gradual Featherweight Typestate (GFT). This language extends the notion of gradual typing to account for typestate: gradual typestate checking seamlessly combines static and dynamic checking by automatically inserting runtime checks into programs. The gradual type system of GFT allows programmers to write dynamically safe code even when the static type checker can only partly verify it.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Ronald Garcia|\u00c9ric Tanter|Roger Wolff|Jonathan Aldrich|Ronald Garcia|\u00c9ric Tanter|Roger Wolff|Jonathan Aldrich|", "references": "", "organization": "University of British Columbia|University of Chile|Carnegie Mellon University|Carnegie Mellon University|University of British Columbia|University of Chile|Carnegie Mellon University|Carnegie Mellon University|", "title": ["Foundations of Typestate-Oriented Programming"]},
{"abstract": "Pthread-style multithreaded programs feature rich thread communication mechanisms, such as shared variables, signals, and broadcasts. In this article, we consider the automated verification of such programs where an unknown number of threads execute a given finite-data procedure in parallel. Such procedures are typically obtained as predicate abstractions of recursion-free source code written in C or Java. Many safety problems over finite-data replicated multithreaded programs are decidable via a reduction to the \n in certain types of well-ordered infinite-state transition systems. On the other hand, in full generality, this problem is Ackermann-hard, which seems to rule out efficient algorithmic treatment.\nWe present a novel, sound, and complete yet empirically efficient solution. Our approach is to judiciously \n the original set of coverability targets by configurations that involve fewer threads and are thus easier to decide, and whose exploration may well be sufficient: if they turn out uncoverable, so are the original targets. To soften the impact of \u201cbad guesses\u201d\u2014configurations that turn out coverable\u2014the exploration is accompanied by a parallel engine that generates coverable configurations; none of these is ever selected for widening. Its job being merely to prevent bad widening choices, such an engine need not be complete for coverability analysis, which enables a range of existing partial (e.g., nonterminating) techniques. We present extensive experiments on multithreaded C programs, including device driver code from FreeBSD, Solaris, and Linux distributions. Our approach outperforms existing coverability methods by orders of magnitude.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Alexander Kaiser|Daniel Kroening|Thomas Wahl|Alexander Kaiser|Daniel Kroening|Thomas Wahl|", "references": "P. A. Abdulla. 2010. Well (and better) quasi-ordered transition systems. Bulletin of Symbolic Logic 16, 4, 457--515.|P. A. Abdulla, K. Cerans, B. Jonsson, and Y.-K. Tsay. 1996. General decidability theorems for infinite-state systems. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (LICS\u201996). 313--321. |P. A. Abdulla, F. Haziza, and L. Hol\u00edk. 2013. All for the price of few. In Verification, Model Checking, and Abstract Interpretation. Lecture Notes in Computer Science, Vol. 7737. Springer, 476--495.|P. A. Abdulla, S. P. Iyer, and A. Nyl\u00e9n. 2004. SAT-solving the coverability problem for Petri nets. Formal Methods in System Design 24, 1, 25--43.  |G. Basler, M. Mazzucchi, T. Wahl, and D. Kroening. 2009. Symbolic counter abstraction for concurrent software. In Proceedings of the 21st International Conference on Computer Aided Verification (CAV\u201909). 64--78.  |B. Berthomieu and F. Vernadat. 2009. The Tina Tool, Release 2.9.6, LAAS/CNRS. Retrieved September 4, 2014, from http://projects.laas.fr/tina.|E. Cardoza, R. J. Lipton, and A. R. Meyer. 1976. Exponential space complete problems for Petri nets and commutative semigroups: Preliminary report. In Proceedings of the 8th Annual ACM Symposium on Theory of Computing (STOC\u201976). 50--54.  |G. Ciardo. 1994. Petri nets with marking-dependent arc cardinality: Properties and analysis. In Application and Theory of Petri Nets. Lecture Notes in Computer Science, Vol. 815. 179--198. |G. Delzanno, J.-F. Raskin, and L. V. Begin. 2002. Towards the automated verification of multithreaded Java programs. In Proceedings of the 8th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201902). 173--187. |A. F. Donaldson, A. Kaiser, D. Kroening, M. Tautschnig, and T. Wahl. 2012. Counterexample-guided abstraction refinement for symmetric concurrent programs. Formal Methods in System Design 41, 1, 25--44.  |A. F. Donaldson, A. Kaiser, D. Kroening, and T. Wahl. 2011. Symmetry-aware predicate abstraction for shared-variable concurrent programs. In Proceedings of the 23rd International Conference on Computer Aided Verification (CAV\u201911). 356--371. |C. Dufourd, A. Finkel, and P. Schnoebelen. 1998. Reset nets between decidability and undecidability. In Proceedings of the 25th International Colloquium on Automata, Languages, and Programming (ICALP\u201998). 103--115. |A. Eli\u00ebns and E. P. de Vink. 1992. Asynchronous rendez-vous in distributed logic programming. In Proceedings of the REX Workshop on Semantics: Foundations and Applications. 174--203. |E. A. Emerson and K. S. Namjoshi. 1998. On model checking for non-deterministic infinite-state systems. In Proceedings of the 13th Annual IEEE Symposium on Logic in Computer Science (LICS\u201998). 70--80. |J. Esparza, A. Finkel, and R. Mayr. 1999. On the verification of broadcast protocols. In Proceedings of the 14th Annual IEEE Symposium on Logic in Computer Science (LICS\u201999). 352--359. |A. Farzan and Z. Kincaid. 2012. Verification of parameterized concurrent programs by modular reasoning about data and control. In Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201912). 297--308.  |A. Farzan, Z. Kincaid, and A. Podelski. 2013. Inductive data flow graphs. In Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201913). 129--142.  |D. Figueira, S. Figueira, S. Schmitz, and P. Schnoebelen. 2011. Ackermannian and primitive-recursive bounds with Dickson\u2019s lemma. In Proceedings of the 26th Annual IEEE Symposium on Logic in Computer Science (LICS\u201911). 269--278.  |A. Finkel, G. Geeraerts, J.-F. Raskin, and L. V. Begin. 2006. On the omega-language expressive power of extended Petri nets. Theoretical Computer Science 356, 3, 374--386.  |A. Finkel and J. Goubault-Larrecq. 2009. Forward analysis for WSTS, part II: Complete WSTS. In Automata, Languages, and Programming. Lecture Notes in Computer Science, Vol. 2009. Springer, 188--199.  |A. Finkel, J.-F. Raskin, M. Samuelides, and L. V. Begin. 2002. Monotonic extensions of Petri nets: Forward and backward search revisited. Electronic Notes in Theoretical Computer Science 68, 6, 85--106.|A. Finkel and P. Schnoebelen. 2001. Well-structured transition systems everywhere&excl; Theoretical Computer Science 256, 1--2, 63--92.  |C. Flanagan and S. Qadeer. 2003. Thread-modular model checking. In Proceedings of the 10th International Conference on Model Checking Software (SPIN\u201903). 213--224. |P. Ganty, L. V. Begin, and A. Piron. n.d. The MIST2 Tool (Version 0.1). Retrieved September 4, 2014, from https://github.com/pierreganty/mist.|P. Ganty, G. Geeraerts, J.-F. Raskin, and L. V. Begin. 2009. Le probl\u00e8me de couverture pour les r\u00e9seaux de Petri: R\u00e9sultats classiques et d\u00e9veloppements r\u00e9cents. Technique et Science Informatiques 28, 9, 1107--1142.|P. Ganty, C. Meuter, G. Delzanno, G. Kalyon, J.-F. Raskin, and L. Van Begin. 2007. Symbolic data structure for sets of |-uples. Technical Report. Universit\u00e9 Libre de Bruxelles, Belgium.|P. Ganty, J.-F. Raskin, and L. V. Begin. 2006. A complete abstract interpretation framework for coverability properties of WSTS. In Proceedings of the 7th International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI\u201906). 49--64.  |G. Geeraerts, J.-F. Raskin, and L. V. Begin. 2006. Expand, enlarge and check: New algorithms for the coverability problem of WSTS. Journal of Computer and Systems Sciences 72, 1, 180--203.  |G. Geeraerts, J.-F. Raskin, and L. V. Begin. 2007. On the efficient computation of the minimal coverability set for Petri nets. In Proceedings of the 5th International Conference on Automated Technology for Verification and Analysis (ATVA\u201907). 98--113. |S. M. German and A. P. Sistla. 1992. Reasoning about systems with many processes. Journal of the ACM 39, 3, 675--735.  |B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes, and D. Lea. 2006. Java Concurrency in Practice. Addison-Wesley. |A. Gupta, C. Popeea, and A. Rybalchenko. 2011a. Predicate abstraction and refinement for verifying multi-threaded programs. In Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201911). 331--344.  |A. Gupta, C. Popeea, and A. Rybalchenko. 2011b. Threader: A constraint-based verifier for multi-threaded programs. In Proceedings of the 23rd International Conference on Computer Aided Verification (CAV\u201911). 412--417. |C. B. Jones. 1983. Tentative steps toward a development method for interfering programs. ACM Transactions on Programming Languages and Systems 5, 4, 596--619.  |A. Kaiser, D. Kroening, and T. Wahl. 2010. Dynamic cutoff detection in parameterized concurrent programs. In Proceedings of the 22nd International Conference on Computer Aided Verification (CAV\u201910). 645--659.  |R. M. Karp and R. E. Miller. 1969. Parallel program schemata. Journal of Computer and System Sciences 3, 2, 147--195.  |J. Kloos, R. Majumdar, F. Niksic, and R. Piskac. 2013. Incremental, inductive coverability. In Proceedings of the 25th International Conference on Computer Aided Verification (CAV\u201913). 158--173.  |M. Leuschel and H. Lehmann. 2000. Coverability of reset Petri nets and other well-structured transition systems by partial deduction. In Computational Logic\u2014CL 2000. Lecture Notes in Computer Science, Vol. 1861. Springer, 101--115. |S. Lu, S. Park, E. Seo, and Y. Zhou. 2008. Learning from mistakes: A comprehensive study on real world concurrency bug characteristics. In Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XIII). 329--339.  |R. Meyer and T. Strazny. 2010. Petruchio: From dynamic networks to nets. In Proceedings of the 22nd International Conference on Computer Aided Verification (CAV\u201910). 175--179.  |S. S. Owicki. 1975. Axiomatic Proof Techniques for Parallel Programs. Outstanding Dissertations in the Computer Sciences. Garland Publishing, New York, NY. |A. Pnueli, J. Xu, and L. D. Zuck. 2002. Liveness with (0,1,\u221e )-counter abstraction. In Proceedings of the 14th International Conference on Computer Aided Verification (CAV\u201902). 107--122. |C. Rackoff. 1978. The covering and boundedness problems for vector addition systems. Theoretical Computer Science 6, 223--231.|P.-A. Reynier and F. Servais. 2011. Minimal coverability set for Petri nets: Karp and Miller algorithm with pruning. In Applications and Theory of Petri Nets. Lecture Notes in Computer Science, Vol. 6709. Springer, 69--88. |P. Schnoebelen. 2010. Revisiting Ackermann-hardness for lossy counter machines and reset Petri nets. In Proceedings of the 35th International Conference on Mathematical Foundations of Computer Science (MFCS\u201910). 616--628. |A. Valmari and H. Hansen. 2012. Old and new algorithms for minimal coverability sets. In Application and Theory of Petri Nets. Lecture Notes in Computer Science, Vol. 7347. Springer, 208--227.  |D. Zufferey, T. Wies, and T. A. Henzinger. 2012. Ideal abstractions for well-structured transition systems. In Proceedings of the 13th International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI\u201912). 445--460.  |", "organization": "University of Oxford, United Kingdom|University of Oxford, United Kingdom|Northeastern University, Boston, MA, United States|University of Oxford, United Kingdom|University of Oxford, United Kingdom|Northeastern University, Boston, MA, United States|", "title": ["A Widening Approach to Multithreaded Program Verification"]},
{"abstract": "", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Kathryn S. Mckinley|Keshav Pingali|Kathryn S. Mckinley|Keshav Pingali|", "references": "", "organization": "", "title": ["La dolce vita at TOPLAS"]},
{"abstract": "Software-controlled scratchpad memory is increasingly employed in embedded systems as it offers better timing predictability compared to caches. Previous scratchpad allocation algorithms typically consider single-process applications. But embedded applications are mostly multitasking with real-time constraints, where the scratchpad memory space has to be shared among interacting processes that may preempt each other. In this work, we develop a novel dynamic scratchpad allocation technique that takes these process interferences into account to improve the performance and predictability of the memory system. We model the application as a Message Sequence Chart (MSC) to best capture the interprocess interactions. Our goal is to optimize the Worst-Case Response Time (WCRT) of the application through runtime reloading of the scratchpad memory content at appropriate execution points. We propose an iterative allocation algorithm that consists of two critical steps: (1) analyze the MSC along with the existing allocation to determine potential interference patterns, and (2) exploit this interference information to tune the scratchpad reloading points and content so as to best improve the WCRT. We present various alternative scratchpad allocation heuristics and evaluate their effectiveness in reducing the WCRT. The scheme is also extended to work on Message Sequence Graph models. We evaluate our memory allocation scheme on two real-world embedded applications controlling an Unmanned Aerial Vehicle (UAV) and an in-orbit monitoring instrument, respectively.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Vivy Suhendra|Abhik Roychoudhury|Tulika Mitra|Vivy Suhendra|Abhik Roychoudhury|Tulika Mitra|", "references": "", "organization": "Institute for Infocomm Research, Singapore|National University of Singapore, Singapore|National University of Singapore, Singapore|Institute for Infocomm Research, Singapore|National University of Singapore, Singapore|National University of Singapore, Singapore|", "title": ["Scratchpad allocation for concurrent embedded software"]},
{"abstract": "With the commercial development of multicore processors, the challenges of writing multithreaded programs to take advantage of these new hardware architectures are becoming more and more pertinent. Concurrent programming is necessary to achieve the performance that the hardware offers. Traditional approaches present concurrency as an \n topic: they have proven difficult to use, reason about with confidence, and scale up to high levels of concurrency. This article reviews \n, based on Hoare's algebra of Communicating Sequential Processes (CSP), and proposes that this approach to concurrency leads to solutions that are manageable by novice programmers; that is, they are easy to design and maintain, that they are scalable for complexity, \n, and relatively easy to verify using formal reasoning and/or model checkers. These solutions can be developed in conventional programming languages (through CSP libraries) or specialized ones (such as occam-\u03c0) in a manner that directly reflects their formal expression. Systems can be developed without needing specialist knowledge of the CSP formalism, since the supporting mathematics is burnt into the tools and languages supporting it. We illustrate these concepts with the \n, which has been used as a challenge for concurrency mechanisms since 1994. We consider this problem as an example control system, producing external signals reporting changes of internal state (that model the external world). We claim our occam-\u03c0 solution is \n, but follow this up with formal verification (using the FDR model checker for CSP) that the system is free from deadlock and livelock, that the produced control signals obey crucial ordering constraints, and that the system has key liveness properties.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Peter H. Welch|Jan B. Pedersen|Peter H. Welch|Jan B. Pedersen|", "references": "", "organization": "University of Kent, United Kingdom|University of Nevada, Las Vegas, NV|University of Kent, United Kingdom|University of Nevada, Las Vegas, NV|", "title": ["Santa Claus: Formal analysis of a process-oriented solution"]},
{"abstract": "Dataflow languages provide natural support for specifying constraints between objects in dynamic applications, where programs need to react efficiently to changes in their environment. In this article, we show that one-way dataflow constraints, largely explored in the context of interactive applications, can be seamlessly integrated in any imperative language and can be used as a general paradigm for writing performance-critical reactive applications that require efficient incremental computations. In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as \u201creactive.\u201d Reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures. Statements defining constraints are automatically re-executed every time their input memory locations change, letting a program behave like a spreadsheet where the values of some variables depend on the values of other variables. The constraint-solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects. We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers. We discuss common coding idioms and relevant applications to reactive scenarios, including incremental computation, observer design pattern, data structure repair, and software visualization. The performance of our implementation is compared to problem-specific change propagation algorithms, as well as to language-centric approaches such as self-adjusting computation and subject/observer communication mechanisms, showing that the proposed approach is efficient in practice.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Camil Demetrescu|Irene Finocchi|Andrea Ribichini|Camil Demetrescu|Irene Finocchi|Andrea Ribichini|", "references": "", "organization": "Sapienza University of Rome, Rome, Italy|Sapienza University of Rome, Rome, Italy|Sapienza University of Rome, Rome, Italy|Sapienza University of Rome, Rome, Italy|Sapienza University of Rome, Rome, Italy|Sapienza University of Rome, Rome, Italy|", "title": ["Reactive Imperative Programming with Dataflow Constraints"]},
{"abstract": "Decentralized Information Flow Control (DIFC) is a promising model for writing programs with powerful, end-to-end security guarantees. Current DIFC systems that run on commodity hardware can be broadly categorized into two types: language-level and operating system-level DIFC. Language solutions provide no guarantees against security violations on system resources such as files and sockets. Operating system solutions mediate accesses to system resources but are either inefficient or imprecise at monitoring the flow of information through fine-grained program data structures. This article describes Laminar, the first system to implement DIFC using a unified set of abstractions for OS resources and heap-allocated objects. Programmers express security policies by labeling data with secrecy and integrity labels and access the labeled data in \n. Laminar enforces the security policies specified by the labels at runtime. Laminar is implemented using a modified Java virtual machine and a new Linux security module. This article shows that security methods ease incremental deployment and limit dynamic security checks by retrofitting DIFC policies on four application case studies. Replacing the applications' ad hoc security policies changes less than 10% of the code and incurs performance overheads from 5% to 56%. Compared to prior DIFC systems, Laminar supports a more general class of multithreaded DIFC programs efficiently and integrates language and OS abstractions.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Donald E. Porter|Michael D. Bond|Indrajit Roy|Kathryn S. Mckinley|Emmett Witchel|Donald E. Porter|Michael D. Bond|Indrajit Roy|Kathryn S. Mckinley|Emmett Witchel|", "references": "", "organization": "Stony Brook University, Stony Brook, NY|Ohio State University, Columbus, OH|Hewlett Packard Labs, Palo Alto, CA|Microsoft Research, WA|The University of Texas at Austin, Austin, TX|Stony Brook University, Stony Brook, NY|Ohio State University, Columbus, OH|Hewlett Packard Labs, Palo Alto, CA|Microsoft Research, WA|The University of Texas at Austin, Austin, TX|", "title": ["Practical Fine-Grained Information Flow Control Using Laminar"]},
{"abstract": "Mobile computation, in which executing computations can move from one physical computing device to another, is a recurring theme: from OS process migration, to language-level mobility, to virtual machine migration. This article reports on the design, implementation, and verification of overlay networks to support reliable communication between migrating computations, in the Nomadic Pict project. We define two levels of abstraction as calculi with precise semantics: a low-level Nomadic \u03c0 calculus with migration and location-dependent communication, and a high-level calculus that adds location-independent communication. Implementations of location-independent communication, as overlay networks that track migrations and forward messages, can be expressed as translations of the high-level calculus into the low. We discuss the design space of such overlay network algorithms and define three precisely, as such translations. Based on the calculi, we design and implement the Nomadic Pict distributed programming language, to let such algorithms (and simple applications above them) to be quickly prototyped. We go on to develop the semantic theory of the Nomadic \u03c0 calculi, proving correctness of one example overlay network. This requires novel equivalences and congruence results that take migration into account, and reasoning principles for agents that are temporarily immobile (e.g., waiting on a lock elsewhere in the system). The whole stands as a demonstration of the use of principled semantics to address challenging system design problems.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Peter Sewell|Pawe\u0142 T. Wojciechowski|Asis Unyapoth|Peter Sewell|Pawe\u0142 T. Wojciechowski|Asis Unyapoth|", "references": "", "organization": "University of Cambridge, Cambridge, UK|Pozna\u0144 University of Technology, Pozna\u0144, Poland|Government Information Technology Services, Thailand|University of Cambridge, Cambridge, UK|Pozna\u0144 University of Technology, Pozna\u0144, Poland|Government Information Technology Services, Thailand|", "title": ["Nomadic pict: Programming languages, communication infrastructure overlays, and semantics for mobile computation"]},
{"abstract": "Spatial architectures provide energy-efficient computation but require effective scheduling algorithms. Existing heuristic-based approaches offer low compiler/architect productivity, little optimality insight, and low architectural portability.\nWe seek to develop a spatial-scheduling framework by utilizing constraint-solving theories and find that architecture primitives and scheduler responsibilities can be related through five abstractions: computation placement, data routing, event timing, resource utilization, and the optimization objective. We encode these responsibilities as 20 mathematical constraints, using SMT and ILP, and create schedulers for the TRIPS, DySER, and PLUG architectures. Our results show that a general declarative approach using constraint solving is implementable, is practical, and can outperform specialized schedulers.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tony Nowatzki|Michael Sartin-Tarm|Lorenzo De Carli|Karthikeyan Sankaralingam|Cristian Estan|Behnam Robatmili|Tony Nowatzki|Michael Sartin-Tarm|Lorenzo De Carli|Karthikeyan Sankaralingam|Cristian Estan|Behnam Robatmili|", "references": "", "organization": "University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|Broadcom, CA|Qualcomm Research Silicon Valley, Santa Clara, CA|University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|University of Wisconsin-Madison, Madison, WI|Broadcom, CA|Qualcomm Research Silicon Valley, Santa Clara, CA|", "title": ["A Scheduling Framework for Spatial Architectures Across Multiple Constraint-Solving Theories"]},
{"abstract": "The most commonly used integer types have fixed bit-width, making it possible for computations to \u201cwrap around,\u201d and many programs depend on this behaviour. Yet much work to date on program analysis and verification of integer computations treats integers as having infinite precision, and most analyses that do respect fixed width lose precision when overflow is possible. We present a novel integer interval abstract domain that correctly handles wrap-around. The analysis is signedness agnostic. By treating integers as strings of bits, only considering signedness for operations that treat them differently, we produce precise, correct results at a modest cost in execution time.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Graeme Gange|Jorge A. Navas|Peter Schachte|Harald S\u00f8ndergaard|Peter J. Stuckey|Graeme Gange|Jorge A. Navas|Peter Schachte|Harald S\u00f8ndergaard|Peter J. Stuckey|", "references": "Gogul Balakrishnan. 2007. WYSINWYX: What You See Is Not What You Execute. Ph.D. Dissertation. University of Wisconsin at Madison, Madison, WI. |Gogul Balakrishnan and Thomas Reps. 2004. Analyzing memory accesses in x86 executables. In Compiler Construction: Proceedings of the 13th International Conference, E. Duesterwald (Ed.). Lecture Notes in Computer Science, Vol. 2985. Springer, 5--23.|S\u00e9bastien Bardin, Philippe Herrmann, and Florian Perroud. 2010. An alternative to SAT-based approaches for bit-vectors. In Proceedings of the 16th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS\u201910), J. Esparza and R. Majumdar (Eds.). Lecture Notes in Computer Science, Vol. 6015. Springer, 84--98.  |Bruno Blanchet, Patrick Cousot, Radhia Cousot, J\u00e9r\u00f4me Feret, Laurent Mauborgne, Antoine Min\u00e9, David Monniaux, and Xavier Rival. 2002. Design and implementation of a special-purpose static program analyzer for safety-critical real-time embedded software. In The Essence of Computation: Complexity, Analysis, Transformation, T. \u00c6. Mogensen, D. A. Schmidt, and I. H. Sudborough (Eds.). Lecture Notes in Computer Science, Vol. 2566. Springer, 85--108. |Sandrine Blazy, Vincent Laporte, Andre Maroneze, and David Pichardie. 2013. Formal verification of a C value analysis based on abstract interpretation. In Static Analysis, F. Logozzo and M. F\u00e4hndrich (Eds.). Lecture Notes in Computer Science, Vol. 7935. Springer, 324--344.|J\u00f6rg Brauer and Andy King. 2010. Automatic abstraction for intervals using boolean formulae. In Static Analysis, R. Cousot and M. Martel (Eds.). Lecture Notes in Computer Science, Vol. 6337. Springer, 167--183. |Zack Coker and Munawar Hafiz. 2013. Program transformations to fix C integers. In Proceedings of the 35th International Conference on Software Engineering (ICSE\u201913). IEEE, 792--801. |Jeremy Condit, Matthew Harren, Scott McPeak, George C. Necula, and Westley Weimer. 2003. CCured in the real world. In Proceedings of ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation (PLDI\u201903). ACM, New York, NY, 232--244.  |Patrick Cousot and Radhia Cousot. 1977. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Proceedings of the 4th ACM Symposium on Principles of Programming Languages. ACM, New York, NY, 238--252.  |Patrick Cousot and Radhia Cousot. 1979. Systematic design of program analysis frameworks. In Proceedings of the Sixth ACM Symposium on Principles of Programming Languages. ACM, New York, NY, 269--282.  |Patrick Cousot and Radhia Cousot. 1992. Comparing the Galois connection and widening/narrowing approaches to abstract interpretation. In Proceedings of the International Symposium on Programming Language Implementation and Logic Programming, M. Bruynooghe and M. Wirsing (Eds.). Lecture Notes in Computer Science, Vol. 631. Springer, 269--295. |Will Dietz, Peng Li, John Regehr, and Vikram Adve. 2012. Understanding integer overflow in C/C&plus;&plus;. In Proceedings of the 34th International Conference on Software Engineering. IEEE, 760--770. |Manuel F\u00e4hndrich and Francesco Logozzo. 2010. Static contract checking with abstract interpretation. In FoVeOSS, B. Beckert and C. March\u00e9 (Eds.). Lecture Notes in Computer Science, Vol. 6528. Springer, 10--30. |Stephan Falke, Deepak Kapur, and Carsten Sinz. 2012. Termination analysis of imperative programs using bitvector arithmetic. In Verified Software: Theories, Tools, and Experiments, R. Joshi, P. M\u00fcller, and A. Podelski (Eds.). Lecture Notes in Computer Science, Vol. 7152. Springer, 261--277.  |Stephan Falke, Florian Merz, and Carsten Sinz. 2013. LLBNC: Improved bounded model checking of C programs using LLVM. In Tools and Algorithms for the Construction and Analysis of Systems, N. Piterman and S. Smolka (Eds.). Lecture Notes in Computer Science, Vol. 7795. Springer, 623--626.  |Graeme Gange, Jorge A. Navas, Peter Schachte, Harald S\u00f8ndergaard, and Peter J. Stuckey. 2013a. Abstract interpretation over non-lattice abstract domains. In Static Analysis, F. Logozzo and M. F\u00e4hndrich (Eds.). Lecture Notes in Computer Science, Vol. 7935. Springer, 6--24.|Graeme Gange, Harald S\u00f8ndergaard, Peter J. Stuckey, and Peter Schachte. 2013b. Solving difference constraints over modular arithmetic. In Automated Deduction, M. Bonacina (Ed.). Lecture Notes in Artificial Intelligence, Vol. 7898. Springer, 215--230.  |Thomas Gawlitza, J\u00e9r\u00f4me Leroux, Jan Reineke, Helmut Seidl, Gr\u00e9goire Sutre, and Reinhard Wilhelm. 2009. Polynomial precise interval analysis revisited. In Efficient Algorithms: Essays Dedicated to Kurt Mehlhorn on the Occasion of His 60th Birthday, S. Albers, H. Alt, and S. N\u00e4her (Eds.). Lecture Notes in Computer Science, Vol. 5760. Springer, 422--437.  |Arnaud Gotlieb, Michel Leconte, and Bruno Marre. 2010. Constraint solving on modular integers. In Proceedings of the Ninth International Workshop on Constraint Modelling and Reformulation (ModRef\u201910).|Philippe Granger. 1989. Static analysis of arithmetical congruences. International Journal of Computer Mathematics 30 (1989), 165--190.|Philippe Granger. 1991. Static analyses of linear congruence equalities among variables of a program. In Theory and Practice of Software Development. Lecture Notes in Computer Science, Vol. 493. Springer, 167--192. |Andy King and Harald S\u00f8ndergaard. 2010. Automatic abstraction for congruences. In Verification, Model Checking and Abstract Interpretation, G. Barthe and M. Hermenegildo (Eds.). Lecture Notes in Computer Science, Vol. 5944. Springer, 197--213.  |Michel Leconte and Bruno Berstel. 2006. Extending a CP solver with congruences as domains for program verification. In Proceedings of the 1st Workshop on Software Testing, Verification and Analysis (CSTVA\u201906), B. Blanc, A. Gotlieb, and C. Michel (Eds.). 22--33.|J\u00e9r\u00f4me Leroux and Gr\u00e9goire Sutre. 2007. Accelerated data-flow analysis. In Static Analysis, H. Riis Nielson and G. Fil\u00e9 (Eds.). Lecture Notes in Computer Science, Vol. 4634. Springer, 184--199. |Francesco Logozzo and Matthieu Martel. 2013. Automatic repair of overflowing expressions with abstract interpretation. In Semantics, Abstract Interpretation, and Reasoning about Programs, A. Banerjee, O. Danvy, K.-G. Doh, and J. Hatcliff (Eds.). Electronic Proceedings in Theoretical Computer Science, Vol. 129. 341--357.|Kim Marriott and Peter J. Stuckey. 1998. Programming with Constraints: An Introduction. MIT Press, Cambridge, MA.|Laurant D. Michel and Pascal Van Hentenryck. 2012. Constraint satisfaction over bit-vectors. In Constraint Programming: Proceedings of the 2012 Conference, M. Milano (Ed.). Lecture Notes in Computer Science, Vol. 7514. Springer, 527--543.  |Antoine Min\u00e9. 2006. The octagon abstract domain. Higher-Order and Symbolic Computation 19, 1, 31--100.  |Tsuneo Nakanishi, Kazuki Joe, Constantine D. Polychronopoulos, and Akira Fukuda. 1999. The modulo interval: A simple and practical representation for program analysis. In Parallel Architecture and Compilation Techniques. IEEE, 91--96. DOI:http://dx.doi.org/10.1109/PACT.1999.807422 |Jorge A. Navas, Peter Schachte, Harald S\u00f8ndergaard, and Peter J. Stuckey. 2012. Signedness-agnostic program analysis: Precise integer bounds for low-level code. In Proceedings of the 10th Asian Symposium on Programming Languages and Systems (APLAS\u201912), R. Jhala and A. Igarashi (Eds.). Lecture Notes in Computer Science, Vol. 7705. Springer, 115--130.|Flemming Nielson, Hanne Riis Nielson, and Chris Hankin. 1999. Principles of Program Analysis. Springer, New York, NY. |John Regehr and Usit Duongsaa. 2006. Deriving abstract transfer functions for analyzing embedded software. In Proceedings of the 2006 SIGPLAN/SIGBED Conference on Language, Compilers, and Tool Support for Embedded Systems (LCTES\u201906). ACM Press, 34--43.  |Thomas Reps, Gogul Balakrishnan, and Junghee Lim. 2006. Intermediate-representation recovery from low-level code. In Proceedings of the 2006 ACM SIGPLAN Conference on Partial Evaluation and Semantics-Based Program Manipulation. ACM Press, New York, NY, 100--111.  |Raphael E. Rodrigues, Victor H. Sperle Campos, and Fernando M. Quint\u00e3o Pereira. 2013. A fast and low-overhead technique to secure programs against integer overflows. In Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO\u201913). IEEE, 1--11.  |Helmut Seidl, Reinhard Wilhelm, and Sebastian Hack. 2012. Compiler Design: Analysis and Transformation. Springer. |Rathijit Sen and Y. N. Srikant. 2007. Executable analysis using abstract interpretation with circular linear progressions. In Proceedings of the Fifth IEEE/ACM International Conference on Formal Methods and Models for Codesign. IEEE, 39--48.  |Axel Simon and Andy King. 2007. Taming the wrapping of integer arithmetic. In Static Analysis, H. Riis Nielson and G. Fil\u00e9 (Eds.). Lecture Notes in Computer Science, Vol. 4634. Springer, 121--136. |Zhendong Su and David Wagner. 2004. A class of polynomially solvable range constraints for interval analysis without widenings and narrowings. In Tools and Algorithms for the Construction and Analysis of Systems, K. Jensen and A. Podelski (Eds.). Lecture Notes in Computer Science, Vol. 2988. Springer, 280--295.|Douglas D. C. Teixera and Fernando M. Q. Pereira. 2011. The design and implementation of a non-iterative range analysis algorithm on a production compiler. In Proceedings of the 2011 Brazilian Symposium on Programming Languages.|Xi Wang, Nickolai Zeldovich, M. Frans Kaashoek, and Armando Solar-Lezama. 2013. Towards optimization-safe systems: Analyzing the impact of undefined behavior. In Proceedings of the 24th ACM Symposium on Operating Systems Principles. ACM, New York, NY, 260--275.  |Henry S. Warren Jr. 2003. Hacker\u2019s Delight. Addison Wesley, New York, NY.|Chao Zhang, Tielei Wang, Tao Wei, Yu Chen, and Wei Zou. 2010. IntPatch: Automatically fix integer-overflow-to-buffer-overflow vulnerability at compile-time. In Computer Security -- ESORICS 2010, D. Gritzalis, B. Preneel, and M. Theoharidou (Eds.). Lecture Notes in Computer Science, Vol. 6345. Springer, 71--86. |Chao Zhang, Wei Zou, Tielei Wang, Yu Chen, and Tao Wei. 2011. Using type analysis in compiler to mitigate integer-overflow-to-buffer-overflow threat. Journal of Computer Security 19, 6, 1083--1107. |", "organization": "The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|The University of Melbourne, Australia|", "title": ["Interval Analysis and Machine Arithmetic: Why Signedness Ignorance Is Bliss"]},
{"abstract": "A fully abstract compiler prevents security features of the source language from being bypassed by an attacker operating at the target language level. Unfortunately, developing fully abstract compilers is very complex, and it is even more so when the target language is an untyped assembly language. To provide a fully abstract compiler that targets untyped assembly, it has been suggested to extend the target language with a protected module architecture\u2014an assembly-level isolation mechanism which can be found in next-generation processors. This article provides a fully abstract compilation scheme whose source language is an object-oriented, high-level language and whose target language is such an extended assembly language. The source language enjoys features such as dynamic memory allocation and exceptions. Secure compilation of first-order method references, cross-package inheritance, and inner classes is also presented. Moreover, this article contains the formal proof of full abstraction of the compilation scheme. Measurements of the overhead introduced by the compilation scheme indicate that it is negligible.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Marco Patrignani|Pieter Agten|Raoul Strackx|Bart Jacobs|Dave Clarke|Frank Piessens|Marco Patrignani|Pieter Agten|Raoul Strackx|Bart Jacobs|Dave Clarke|Frank Piessens|", "references": "", "organization": "iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|Dept. Information Technology, Uppsala, Sweden and iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium |iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|Dept. Information Technology, Uppsala, Sweden and iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium |iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium|", "title": ["Secure Compilation to Protected Module Architectures"]},
{"abstract": "Data races are one of the main causes of concurrency problems in multithreaded programs. Whether all data races are bad, or some are harmful and others are harmless, is still the subject of vigorous scientific debate [Narayanasamy et al. 2007; Boehm 2012]. What is clear, however, is that today's code has many data races [Kasikci et al. 2012; Jin et al. 2012; Erickson et al. 2010], and fixing data races without introducing bugs is time consuming [Godefroid and Nagappan 2008]. Therefore, it is important to efficiently identify data races in code and understand their consequences to prioritize their resolution.\nWe present Portend\n, a tool that not only detects races but also automatically classifies them based on their potential consequences: Could they lead to crashes or hangs? Could their effects be visible outside the program? Do they appear to be harmless? How do their effects change under weak memory models? Our proposed technique achieves high accuracy by efficiently analyzing multiple paths and multiple thread schedules in combination, and by performing symbolic comparison between program outputs.\nWe ran Portend\n on seven real-world applications: it detected 93 true data races and correctly classified 92 of them, with no human effort. Six of them were harmful races. Portend\n's classification accuracy is up to 89% higher than that of existing tools, and it produces easy-to-understand evidence of the consequences of \u201charmful\u201d races, thus both proving their harmfulness and making debugging easier. We envision Portend\n being used for testing and debugging, as well as for automatically triaging bug reports.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Baris Kasikci|Cristian Zamfir|George Candea|Baris Kasikci|Cristian Zamfir|George Candea|", "references": "", "organization": "\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Switzerland, Switzerland|", "title": ["Automated Classification of Data Races Under Both Strong and Weak Memory Models"]},
{"abstract": "We present a technique for the formal verification of GPU kernels, addressing two classes of correctness properties: data races and barrier divergence. Our approach is founded on a novel formal operational semantics for GPU kernels termed <i>synchronous, delayed visibility (SDV)</i> semantics, which captures the execution of a GPU kernel by multiple groups of threads. The SDV semantics provides operational definitions for barrier divergence and for both inter- and intra-group data races. We build on the semantics to develop a method for reducing the task of verifying a massively parallel GPU kernel to that of verifying a sequential program. This completely avoids the need to reason about thread interleavings, and allows existing techniques for sequential program verification to be leveraged. We describe an efficient encoding of data race detection and propose a method for automatically inferring the loop invariants that are required for verification. We have implemented these techniques as a practical verification tool, GPUVerify, that can be applied directly to OpenCL and CUDA source code. We evaluate GPUVerify with respect to a set of 162 kernels drawn from public and commercial sources. Our evaluation demonstrates that GPUVerify is capable of efficient, automatic verification of a large number of real-world kernels.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Adam Betts|Nathan Chong|Alastair F. Donaldson|Jeroen Ketema|Shaz Qadeer|Paul Thomson|John Wickerson|Adam Betts|Nathan Chong|Alastair F. Donaldson|Jeroen Ketema|Shaz Qadeer|Paul Thomson|John Wickerson|", "references": "", "organization": "Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Microsoft Research Redmond, WA, USA|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|Microsoft Research Redmond, WA, USA|Imperial College London, London, United Kingdom|Imperial College London, London, United Kingdom|", "title": ["The Design and Implementation of a Verification Technique for GPU Kernels"]},
{"abstract": "Recent research has shown that it is possible to leverage general-purpose theorem-proving techniques to develop powerful type systems for the verification of a wide range of security properties on application code. Although successful in many respects, these type systems fall short of capturing resource-conscious properties that are crucial in large classes of modern distributed applications. In this article, we propose the first type system that statically enforces the safety of cryptographic protocol implementations with respect to authorization policies expressed in affine logic. Our type system draws on a novel notion of \u201cexponential serialization\u201d of affine formulas, a general technique to protect affine formulas from the effect of duplication. This technique allows formulate of an expressive logical encoding of the authentication mechanisms underpinning distributed resource-aware authorization policies. We discuss the effectiveness of our approach on two case studies: the EPMO e-commerce protocol and the Kerberos authentication protocol. We finally devise a sound and complete type-checking algorithm, which is the key to achieving an efficient implementation of our analysis technique.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Michele Bugliesi|Stefano Calzavara|Fabienne Eigner|Matteo Maffei|Michele Bugliesi|Stefano Calzavara|Fabienne Eigner|Matteo Maffei|", "references": "", "organization": "Universit\u00e0 Ca\u2019 Foscari Venezia, Venezia Mestre (Italy)|Universit\u00e0 Ca\u2019 Foscari Venezia, Venezia Mestre (Italy)|CISPA, Saarland University, Saarbr\u00fccken, Germany|CISPA, Saarland University, Saarbr\u00fccken, Germany|Universit\u00e0 Ca\u2019 Foscari Venezia, Venezia Mestre (Italy)|Universit\u00e0 Ca\u2019 Foscari Venezia, Venezia Mestre (Italy)|CISPA, Saarland University, Saarbr\u00fccken, Germany|CISPA, Saarland University, Saarbr\u00fccken, Germany|", "title": ["Affine Refinement Types for Secure Distributed Programming"]},
{"abstract": "Verification of a dynamically dispatched method call, \n.\n(), seems to depend on \n\u2019s dynamic type. To avoid case analysis and allow incremental development, object-oriented program verification uses supertype abstraction. In other words, one reasons about \n.\n() using \n\u2019s specification for \n\u2019s static type. Supertype abstraction is valid when each subtype in the program is a behavioral subtype. This article semantically formalizes supertype abstraction and behavioral subtyping for a Java-like sequential language with mutation and proves that behavioral subtyping is both necessary and sufficient for the validity of supertype abstraction. Specification inheritance, as in JML, is also formalized and proved to entail behavioral subtyping.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gary T. Leavens|David A. Naumann|Gary T. Leavens|David A. Naumann|", "references": "", "organization": "University of Central Florida, FL, USA|Stevens Institute of Technology, NJ, USA|University of Central Florida, FL, USA|Stevens Institute of Technology, NJ, USA|", "title": ["Behavioral Subtyping, Specification Inheritance, and Modular Reasoning"]},
{"abstract": "Tree automata and transducers are used in a wide range of applications in software engineering. While these formalisms are of immense practical use, they can only model finite alphabets. To overcome this problem we augment tree automata and transducers with symbolic alphabets represented as parametric theories. Admitting infinite alphabets makes these models more general and succinct than their classic counterparts. Despite this, we show how the main operations, such as composition and language equivalence, remain computable given a decision procedure for the alphabet theory. We introduce a high-level language called F\n that acts as a front-end for the preceding formalisms.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Loris D'antoni|Margus Veanes|Benjamin Livshits|David Molnar|Loris D'antoni|Margus Veanes|Benjamin Livshits|David Molnar|", "references": "", "organization": "University of Pennsylvania, Philadelphia, PA|Microsoft Research, Redmond, WA|Microsoft Research, Redmond, WA|Microsoft Research, Redmond, WA|University of Pennsylvania, Philadelphia, PA|Microsoft Research, Redmond, WA|Microsoft Research, Redmond, WA|Microsoft Research, Redmond, WA|", "title": ["Fast: A Transducer-Based Language for Tree Manipulation"]},
{"abstract": "We propose an extension to \n (\n), called \n (\n), for specifying collaboration among agents in a multiagent system. We show that BSIL is strictly more expressive than ATL\n but incomparable with ATL\n, \n (\n), and \n (\n) in expressiveness. We show that a memoryful strategy is necessary for fulfilling a specification in BSIL. We establish that the BSIL model-checking problem is PSPACE-complete. However, BSIL model checking can be performed in time quadratic in the model for fixed formulas. The BSIL (and hence ATL\n) satisfiability is 2EXPTIME-complete. Finally, we report our experiment with a model checker for BSIL.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Farn Wang|Sven Schewe|Chung-Hao Huang|Farn Wang|Sven Schewe|Chung-Hao Huang|", "references": "", "organization": "Graduate Institute of Electronic Engineering, National Taiwan University; Department of Electrical Engineering, National Taiwan University; Research Center for Information Technology Innovation (CITI), Academia Sinica, Taiwan, ROC |Department of Computer Sciences, University of Liverpool, UK|Graduate Institute of Electronic Engineering, National Taiwan University, Taipei, Taiwan, ROC |Graduate Institute of Electronic Engineering, National Taiwan University; Department of Electrical Engineering, National Taiwan University; Research Center for Information Technology Innovation (CITI), Academia Sinica, Taiwan, ROC |Department of Computer Sciences, University of Liverpool, UK|Graduate Institute of Electronic Engineering, National Taiwan University, Taipei, Taiwan, ROC |", "title": ["An Extension of ATL with Strategy Interaction"]},
{"abstract": "Recently, Esparza et al. generalized Newton\u2019s method\u2014a numerical-analysis algorithm for finding roots of real-valued functions\u2014to a method for finding fixed-points of systems of equations over semirings. Their method provides a new way to solve interprocedural dataflow-analysis problems. As in its real-valued counterpart, each iteration of their method solves a simpler \u201clinearized\u201d problem.\nOne of the reasons this advance is exciting is that some numerical analysts have claimed that \u201c\u2018all\u2019 effective and fast iterative [numerical] methods are forms (perhaps very disguised) of Newton\u2019s method.\u201d However, there is an important difference between the dataflow-analysis and numerical-analysis contexts: When Newton\u2019s method is used in numerical-analysis problems, \n is relied on to rearrange an expression of the form \u201c\n * \n * \n + \n * \n * \n\u201d into \u201c(\n*\n + \n*\n)*\n.\u201d Equations with such expressions correspond to path problems described by regular languages. In contrast, when Newton\u2019s method is used for interprocedural dataflow analysis, the \u201cmultiplication\u201d operation involves function composition and hence is non-commutative: \u201c\n*\n*\n + \n*\n*\n\u201d cannot be rearranged into \u201c(\n*\n + \n*\n)*\n.\u201d Equations with such expressions correspond to path problems described by linear context-free languages (LCFLs).\nIn this article, we present an improved technique for solving the LCFL sub-problems produced during successive rounds of Newton\u2019s method. Our method applies to predicate abstraction, on which most of today\u2019s software model checkers rely.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Thomas Reps|Emma Turetsky|Prathmesh Prabhu|Thomas Reps|Emma Turetsky|Prathmesh Prabhu|", "references": "T. Ball and S. K. Rajamani. 2000. Bebop: A symbolic model checker for Boolean programs. In Spin Workshop. |A. Bouajjani, J. Esparza, and T. Touili. 2003. A generic approach to the static analysis of concurrent programs with procedures. In POPL.  |R. E. Bryant. 1986. Graph-based algorithms for Boolean function manipulation. IEEE Trans. Comp. C-35, 6 (Aug. 1986), 677--691.  |J. Cocke. 1970. Global common subexpression elimination. Proceedings of the Symposium on Compiler Optimization (1970).  |P. Cousot and R. Cousot. 1978. Static determination of dynamic properties of recursive procedures. In Formal Descriptions of Programming Concepts. North-Holland.|M. Droste, W. Kuich, and H. Vogler (Eds.). 2009. Handbook of Weighted Automata. Springer-Verlag. |M. Elder, J. Lim, T. Sharma, T. Andersen, and T. Reps. 2014. Abstract domains of affine relations. Trans. Prog. Lang. Syst. 36, 4 (Jan. 2014).  |J. Esparza, S. Kiefer, and M. Luttenberger. 2008. Newton\u2019s method for omega-continuous semirings. In ICALP.  |J. Esparza, S. Kiefer, and M. Luttenberger. 2010. Newtonian program analysis. J. ACM 57, 6 (2010).  |A. Farzan and Z. Kincaid. 2015. Compositional recurrence analysis. In FMCAD. |J. P. Gallagher. 2016. Personal communication. (Oct. 2016).|P. Ganty, R. Iosif, and F. Kone\u010dn\u00fd. 2016. Underapproximation of procedure summaries for integer programs. Softw. Tools for Tech. Transfer (2016). Corrected version available as arXiv:1210.4289v3.|S. Graf and H. Sa\u00efdi. 1997. Construction of abstract state graphs with PVS. In CAV. |S. L. Graham and M. Wegman. 1976. A fast and usually linear algorithm for data flow analysis. J. ACM 23, 1 (1976), 172--202.  |N. B. B. Grathwohl, D. Kozen, and K. Mamouras. 2014. KAT + B&excl;. In CSL-LICS.  |B. Kafle and J. P. Gallagher. 2015. Horn clause verification with convex polyhedral abstraction and tree automata-based refinement. Computer Languages, Systems 8 Structures (2015).|B. Kafle, J. P. Gallagher, and P. Ganty. 2016. Solving non-linear Horn clauses using a linear Horn clause solver. In Proceedings of the 3rd Workshop on Horn Clauses for Verification and Synthesis.|J. B. Kam and J. D. Ullman. 1976. Global data flow analysis and iterative algorithms. J. ACM 23, 1 (1976), 158--171.  |J. B. Kam and J. D. Ullman. 1977. Monotone data flow analysis frameworks. Acta Inf. 7, 3 (1977), 305--318.  |N. Kidd, A. Lal, and T. Reps. 2007. WALi: The Weighted Automaton Library. Retrieved from www.cs.wisc.edu/wpis/wpds/download.php.|G. A. Kildall. 1973. A unified approach to global program optimization. In POPL.  |Z. Kincaid, J. Breck, A. Forouhi Boroujeni, and T. Reps. 2016. Compositional Recurrence Analysis Revisited. Tech. Rep. TR-1840. Comp. Sci. Dept., Univ. of Wisconsin\u2014Madison.|J. Knoop and B. Steffen. 1992. The interprocedural coincidence theorem. In CC. |D. E. Knuth. 1977. A generalization of Dijkstra\u2019s algorithm. Inf. Proc. Let. 6, 1 (1977), 1--5.|A. Lal, N. Kidd, T. Reps, and T. Touili. 2007. Abstract error projection. In Static Analysis Symp. |A. Lal and T. Reps. 2006. Improving pushdown system model checking. In CAV.  |A. Lal and T. Reps. 2009. Reducing concurrent analysis under a context bound to sequential analysis. Formal Methods Syst. Des. 35, 1 (2009), 73--97.  |A. Lal, T. Reps, and G. Balakrishnan. 2005. Extended weighted pushdown systems. In CAV.  |A. Lal, T. Touili, N. Kidd, and T. Reps. 2007. Interprocedural Analysis of Concurrent Programs Under a Context Bound. Tech. Rep. TR-1598. Comp. Sci. Dept., University of Wisconsin\u2014Madison.|A. Lal, T. Touili, N. Kidd, and T. Reps. 2008. Interprocedural analysis of concurrent programs under a context bound. In TACAS. |G. L. Litvinov, A.Ya. Rodionov, S. N. Sergeev, and A. N. Sobolevski. 2013. Universal algorithms for solving the matrix Bellman equations over semirings. Soft Comput. 17, 10 (2013), 1767--1785.  |R. McNaughton and H. Yamada. 1960. Regular expressions and state graphs for automata. IRE Trans. Elec. Comput. 9 (1960), 39--47.|U. M\u00f6ncke and R. Wilhelm. 1991. Grammar flow analysis. In Attribute Grammars, Applications and Systems, (Int. Summer School SAGA). 151--186. |M. M\u00fcller-Olm and H. Seidl. 2004. Precise interprocedural analysis through linear algebra. In POPL.  |M. M\u00fcller-Olm and H. Seidl. 2005. Analysis of modular arithmetic. In ESOP.|G. Ramalingam. 1996. Bounded Incremental Computation. Springer-Verlag. |T. Reps, S. Horwitz, and M. Sagiv. 1995. Precise interprocedural dataflow analysis via graph reachability. In POPL. 49--61.  |T. Reps, A. Lal, and N. Kidd. 2007. Program analysis using weighted pushdown systems. In FSTTCS. |T. Reps, S. Schwoon, S. Jha, and D. Melski. 2005. Weighted pushdown systems and their application to interprocedural dataflow analysis. SCP 58, 1--2 (Oct. 2005), 206--263.  |T. Reps, E. Turetsky, and P. Prabhu. 2016. Newtonian program analysis via tensor product. In POPL.  |M. Schlund. 2016. Algebraic Systems of Fixpoint Equations over Semirings: Theory and Applications. Ph.D. Dissertation. Lehrstuhl f\u00fcr Informatik VII, Technischen Universit\u00e4t M\u00fcnchen, Munich, Germany.|M. Schlund, M. Terepeta, and M. Luttenberger. 2013. Putting Newton into practice: A solver for polynomial equations over semirings. In LPAR.|M. Sharir and A. Pnueli. 1981. Two approaches to interprocedural data flow analysis. In Program Flow Analysis: Theory and Applications. Prentice-Hall.|Static Driver Verifier. 2017. Retrieved from msdn.microsoft.com/en-us/library/windows/hardware/ff552808(v&equals;vs.85).aspx.|R. A. Tapia. 2008. Inverse, Shifted Inverse, and Rayleigh Quotient Iteration as Newton\u2019s Method. Retrieved from www.frequency.com/video/lecture-series-/18347021.|R. E. Tarjan. 1981a. Fast algorithms for solving path problems. J. ACM 28, 3 (1981), 594--614.  |R. E. Tarjan. 1981b. A unified approach to path problems. J. ACM 28, 3 (1981), 577--593.  |J. D. Ullman. 1973. Fast algorithms for the elimination of common subexpressions. Acta Inf. 2 (1973), 191--213.  |J. D. Ullman and A. Van Gelder. 1986. Parallel complexity of logical query programs. In Foundations of Computer Science.  |V. Vyssotsky and P. Wegner. 1963. A graph theoretical Fortran source language analyzer. (1963). Unpublished technical report, Bell Labs, Murray-Hill, NJ (as cited in Aho et al., \u201cCompilers: Principles, Techniques, and Tools,\u201d Addison-Wesley, 1986). |M. Yannakakis. 1990. Graph-theoretic methods in database theory. In PODS.  |", "organization": "University of Wisconsin\u2014Madison and Gramma Tech, Inc., Madison, WI|University of Wisconsin\u2014Madison, Mountain View, CA|University of Wisconsin\u2014Madison, Mountain View, CA|University of Wisconsin\u2014Madison and Gramma Tech, Inc., Madison, WI|University of Wisconsin\u2014Madison, Mountain View, CA|University of Wisconsin\u2014Madison, Mountain View, CA|", "title": ["Newtonian Program Analysis via Tensor Product"]},
{"abstract": "Runtime analysis provides an effective method for measuring the sensitivity of programs to rounding errors. To date, implementations have required significant changes to source code, detracting from their widespread application. In this work, we present an open source system that automates the quantitative analysis of floating point rounding errors through the use of C-based source-to-source compilation and a Monte Carlo arithmetic library. We demonstrate its application to the comparison of algorithms, detection of catastrophic cancellation, and determination of whether single precision floating point provides sufficient accuracy for a given application. Methods for obtaining quantifiable measurements of sensitivity to rounding error are also detailed.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Michael Frechtling|Philip H. W. Leong|Michael Frechtling|Philip H. W. Leong|", "references": "", "organization": "The University of Sydney, Darlington, NSW, Australia|The University of Sydney, Darlington, NSW, Australia|The University of Sydney, Darlington, NSW, Australia|The University of Sydney, Darlington, NSW, Australia|", "title": ["MCALIB: Measuring Sensitivity to Rounding Error with Monte Carlo Programming"]},
{"abstract": "This article describes a very high-level language for clear description of distributed algorithms and optimizations necessary for generating efficient implementations. The language supports high-level control flows in which complex synchronization conditions can be expressed using high-level queries, especially logic quantifications, over message history sequences. Unfortunately, the programs would be extremely inefficient, including consuming unbounded memory, if executed straightforwardly.\nWe present new optimizations that automatically transform complex synchronization conditions into incremental updates of necessary auxiliary values as messages are sent and received. The core of the optimizations is the first general method for efficient implementation of logic quantifications. We have developed an operational semantics of the language, implemented a prototype of the compiler and the optimizations, and successfully used the language and implementation on a variety of important distributed algorithms.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Yanhong A. Liu|Scott D. Stoller|Bo Lin|Yanhong A. Liu|Scott D. Stoller|Bo Lin|", "references": "Umut A. Acar, Guy E. Blelloch, and Robert Harper. 2006. Adaptive functional programming. ACM Transactions on Programming Languages and Systems 28, 6, 990--1034.  |Gul Agha. 1986. Actors: A Model of Concurrent Computation in Distributed Systems. MIT Press, Cambridge, MA. |Frances E. Allen, John Cocke, and Ken Kennedy. 1981. Reduction of operator strength. In Program Flow Analysis, Steven S. Muchnick and Neil D. Jones (Eds.). Prentice-Hall, Upper Saddle River, NJ. 79--101.|P. Alvaro, T. Condie, N. Conway, J. M. Hellerstein, and R. Sears. 2010. I do declare: Consensus in a logic language. ACM SIGOPS Operating Systems Review 43, 4, 25--30.  |Gregory R. Andrews and Ronald A. Olsson. 1993. The SR Programming Language: Concurrency in Practice. Benjamin Cummings. |Michael P. Ashley-Rollman, Peter Lee, Seth Copen Goldstein, Padmanabhan Pillai, and Jason D. Campbell. 2009. A language for large ensembles of independently executing nodes. In Proceedings of the 25th International Conference on Logic Programming. Springer, 265--280.  |Hagit Attiya and Jennifer Welch. 2004. Distributed Computing: Fundamentals, Simulations, and Advanced Topics (2nd ed.). Wiley, Hoboken, NJ. |Joshua S. Auerbach, Arthur P. Goldberg, Germ\u00e1n S. Goldszmidt, Ajei S. Gopal, Mark T. Kennedy, Josyula R. Rao, and James R. Russell. 1994. Concert/C: A language for distributed programming. In Proceedings of the USENIX Winter 1994 Technical Conference. USENIX Association, Article 8, 18 pages. |Antonio Badia. 2007. Question answering and database querying: Bridging the gap with generalized quantification. Journal of Applied Logic 5, 1, 3--19.|Antonio Badia, Brandon Debes, and Bin Cao. 2008. An implementation of a query language with generalized quantifiers. In Proceedings of the 27th International Conference on Conceptual Modeling. Springer, 547--548.  |Antonio Badia, Dirk Van Gucht, and Marc Gyssens. 1995. Query languages with generalized quantifiers. In Applications of Logic in Databases, R. Ramakrishnan (Ed.). Kluwer Academic, Dordrecht, The Netherlands.|Jason Baker, Chris Bond, James C. Corbett, J. J. Furman, Andrey Khorlin, James Larson, Jean-Michel L\u00e9on, Yawei Li, Alexander Lloyd, and Vadim Yushprakh. 2011. Megastore: Providing scalable, highly available storage for interactive services. In Proceedings of the Conference on Innovative Database Research. 223--234.|Berkeley Orders of Magnitude 2013. Bloom Programming Language. Retrieved April 8, 2017 from http://www.bloom-lang.net.|Mark Bickford. 2009. Component specification using event classes. In Proceedings of the 12th International Symposium on Component-Based Software Engineering. Springer, 140--155.  |Andrew P. Black, Norman C. Hutchinson, Eric Jul, and Henry M. Levy. 2007. The development of the Emerald programming language. In Proceedings of the 3rd ACM SIGPLAN Conference on History of Programming Languages. 11--1--11--51.  |Mike Burrows. 2006. The chubby lock service for loosely-coupled distributed systems. In Proceedings of the 7th USENIX Symposium on Operating Systems Design and Implementation. 335--350. |Jiazhen Cai, Philippe Facon, Fritz Henglein, Robert Paige, and Edmond Schonberg. 1991. Type analysis and data structure selection. In Constructing Programs from Specifications, Bernhard M\u00f6ller (Ed.). North-Holland, Amsterdam, The Netherlands, 126--164.|Saksham Chand, Yanhong A. Liu, and Scott D. Stoller. 2016. Formal verification of multi-Paxos for distributed consensus. In Proceedings of the 21st International Symposium on Formal Methods. Springer, 119--136.|Fay Chang, Jeffrey Dean, Sanjay Ghemawat, Wilson C. Hsieh, Deborah A. Wallach, Mike Burrows, Tushar Chandra, Andrew Fikes, and Robert E. Gruber. 2008. Bigtable: A distributed storage system for structured data. ACM Transactions on Computer Systems 26, 2 (2008), 4.  |Jens Clau\u00dfen, Alfons Kemper, Guido Moerkotte, and Klaus Peithner. 1997. Optimizing queries with universal quantification in object-oriented and object-relational databases. In Proceedings of the 23rd International Conference on Very Large Data Bases. Morgan Kaufman, San Francisco, CA, 286--295. |Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms (3rd ed.). MIT Press, Cambridge, MA. |Flavio Cruz, Ricardo Rocha, Seth Copen Goldstein, and Frank Pfenning. 2014. A linear logic programming language for concurrent programming over graph structures. Theory and Practice of Logic Programming 14, 7, 493--507.|Jeffrey Dean and Sanjay Ghemawat. 2008. MapReduce: Simplified data processing on large clusters. Commun. ACM 51, 1, 107--113.  |Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gunavardhan Kakulapati, Avinash Lakshman, Alex Pilchin, Swaminathan Sivasubramanian, Peter Vosshall, and Werner Vogels. 2007. Dynamo: Amazon\u2019s highly available key-value store. ACM SIGOPS Operating Systems Review 41, 6, 205--220.  |DistAlgo. 2016. DistAlgo: A Language for Distributed Algorithms. Retrieved April 8, 2017 from http://github.com/DistAlgo.|Erlang. 2015. Erlang Programming Language. Retrieved April 8, 2017 from http://www.erlang.org/.|Colin J. Fidge. 1988. Timestamps in message-passing systems that preserve the partial ordering. In Proceedings of the 11th Australian Computer Science Conference. 56--66.|F. Fioravanti, A. Pettorossi, M. Proietti, and V. Senni. 2011. Program transformation for development, verification, and synthesis of programs. Intelligenza Artificiale 5, 1, 119--125.|Vijay K. Garg. 2002. Elements of Distributed Computing. Wiley. |Gautam and S. Rajopadhye. 2006. Simplifying reductions. In Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 30--41.  |Chryssis Georgiou, Nancy A. Lynch, and Panayiotis Mavrommatis and Joshua A. Tauber. 2009. Automated implementation of complex distributed algorithms specified in the IOA language. International Journal on Software Tools for Technology Transfer 11, 2, 153--171.|Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. 2003. The Google file system. ACM SIGOPS Operating Systems Review 37, 5, 29--43.  |Michael Gorbovitski, Yanhong A. Liu, Scott D. Stoller, Tom Rothamel, and Tuncay Tekle. 2010. Alias analysis for optimization of dynamic languages. In Proceedings of the 6th Symposium on Dynamic Languages. ACM Press, 27--42.  |Deepak Goyal. 2000. A Language Theoretic Approach to Algorithms. Ph.D. Dissertation. Department of Computer Science, New York University, New York, NY. |Adam Granicz, Daniel M. Zimmerman, and Jason Hickey. 2003. Rewriting UNITY. In Proceedings of the 14th International Conference on Rewriting Techniques and Applications. Springer, 138--147. |Ashish Gupta, Inderpal Singh Mumick, and V. S. Subrahmanian. 1993. Maintaining views incrementally. In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data. 157--166.  |David Hansel, Rance Cleaveland, and Scott A. Smolka. 2004. Distributed prototyping from validated specifications. Journal of Systems and Software 70, 3, 275--298.  |Patrick Hunt, Mahadev Konar, Flavio Paiva Junqueira, and Benjamin Reed. 2010. ZooKeeper: Wait-free coordination for Internet-scale Systems. In USENIX Annual Technical Conference. 9. |Dilsun Kaynar, Nancy Lynch, Roberto Segala, and Frits Vaandrager. 2010. The Theory of Timed I/O Automata. 2nd ed.) Morgan 8 Claypool, San Francisco, CA. |Ingolf Heiko Kr\u00fcger. 1996. An experiment in compiler design for a concurrent object-based programming language. Master\u2019s thesis. The University of Texas at Austin, Austin, TX.|A. D. Kshemkalyani and M. Singhal. 2008. Distributed Computing: Principles, Algorithms, and Systems. Cambridge University Press, New York, NY. |Avinash Lakshman and Prashant Malik. 2010. Cassandra: A decentralized structured storage system. ACM SIGOPS Operating Systems Review 44, 2, 35--40.  |Leslie Lamport. 1978. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM 21, 7, 558--565.  |Leslie Lamport. 2002. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers. Addison-Wesley, New York, NY. |Leslie Lamport. 2009. The pluscal algorithm language. In Proceedings of the 6th International Colloquium on Theoretical Aspects of Computing. Springer, 36--60.  |Jim Larson. 2009. Erlang for concurrent programming. Communications of the ACM 52, 3, 48--56.  |Barbara Liskov. 1988. Distributed programming in Argus. Communications of the ACM 31, 3, 300--312.  |Yanhong Annie Liu. 2013. Systematic Program Design: From Clarity to Efficiency. Cambridge University Press. New York, NY. |Yanhong A. Liu, Jon Brandvein, Scott D. Stoller, and Bo Lin. 2016. Demand-driven incremental object queries. In Proceedings of the 18th International Symposium on Principles and Practice of Declarative Programming. ACM Press, 228--241.  |Yanhong A. Liu, Michael Gorbovitski, and Scott D. Stoller. 2009. A language and framework for invariant-driven transformations. In Proceedings of the 8th International Conference on Generative Programming and Component Engineering. ACM Press, 55--64.  |Yanhong A. Liu and Scott D. Stoller. 2003. Dynamic programming via static incrementalization. Higher-Order and Symbolic Computation 16, 1--2, 37--62.  |Yanhong A. Liu and Scott D. Stoller. 2009. From datalog rules to efficient programs with time and space guarantees. ACM Transactions on Programming Languages and Systems 31, 6, 1--38.  |Yanhong A. Liu, Scott D. Stoller, Michael Gorbovitski, Tom Rothamel, and Yanni E. Liu. 2005a. Incrementalization across object abstraction. In Proceedings of the 20th ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications. 473--486.  |Yanhong A. Liu, Scott D. Stoller, Ning Li, and Tom Rothamel. 2005b. Optimizing aggregate array computations in loops. ACM Transactions on Programming Languages and Systems 27, 1, 91--125.  |Yanhong A. Liu, Scott D. Stoller, and Bo Lin. 2012. High-level executable specifications of distributed algorithms. In Proceedings of the 14th International Symposium on Stabilization, Safety, and Security of Distributed Systems. Springer, 95--110.  |Yanhong A. Liu, Scott D. Stoller, Bo Lin, and Michael Gorbovitski. 2012. From clarity to efficiency for distributed algorithms. In Proceedings of the 27th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications. 395--410.  |Yanhong A. Liu, Chen Wang, Michael Gorbovitski, Tom Rothamel, Yongxi Cheng, Yingchao Zhao, and Jing Zhang. 2006. Core role-based access control: Efficient implementations by transformations. In Proceedings of the ACM SIGPLAN 2006 Workshop on Partial Evaluation and Program Manipulation. 112--120.  |Nuno P. Lopes, Juan A. Navarro, Andrey Rybalchenko, and Atul Singh. 2010. Applying Prolog to develop distributed systems. Theory and Practice of Logic Programming 10, 4--6, 691--707.  |Nancy A. Lynch. 1996. Distributed Algorithms. Morgan Kaufman, San Francisco, CA. |Friedemann Mattern. 1989. Virtual time and global states of distributed systems. In Proceedings of the International Workshop on Parallel and Distributed Algorithms. North-Holland, Amsterdam, The Netherlands, 120--131.|Petar Maymounkov and David Mazi\u00e8res. 2002. Kademlia: A peer-to-peer information system based on the XOR metric. In Peer-to-Peer Systems. 53--65. |MPI. 2015. Message Passing Interface Forum. Retrieved April 8, 2017 from http://www.mpi-forum.org/.|Hiroaki Nakamura. 2001. Incremental computation of complex object queries. In Proceedings of the 16th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications. 156--165.  |Robert Paige. 1989. Real-time simulation of a set machine on a RAM. In Proceedings of the International Conference on Computing and Information. Canadian Scholars Press, Toronto, ON, 69--73.|Robert Paige and Shaye Koenig. 1982. Finite differencing of computable expressions. ACM Transactions on Programming Languages and Systems 4, 3, 402--454.  |Vyacheslav Petukhin. 1997. Programs with universally quantified embedded implications. In Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning. Springer, 310--324. |PRL Project. 2013. EventML. Retrieved April 8, 2017 from http://www.nuprl.org/software/#WhatisEventML.|William Pugh and Tim Teitelbaum. 1989. Incremental computation via function caching. In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages. 315--328.  |G. Ramalingam and Thomas Reps. 1993. A categorized bibliography on incremental computation. In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages. 502--510.  |Michel Raynal. 1988. Distributed Algorithms and Protocols. Wiley, Hoboken, NJ. |Michel Raynal. 2010. Communication and Agreement Abstractions for Fault-Tolerant Asynchronous Distributed Systems. Morgan 8 Claypool, San Francisco, CA. |Michel Raynal. 2013. Distributed Algorithms for Message-Passing Systems. Springer. |Tom Rothamel and Yanhong A. Liu. 2008. Generating incremental implementations of object-set queries. In Proceedings of the 7th International Conference on Generative Programming and Component Engineering. ACM Press, 55--66.  |Antony Rowstron and Peter Druschel. 2001. Pastry: Scalable, decentralized object location, and routing for large-scale peer-to-peer systems. In Proceedings of the IFIP/ACM International Conference on Distributed Systems Platforms (Middleware 2001). Springer, 329--350. |Diptikalyan Saha and C. R. Ramakrishnan. 2003. Incremental evaluation of tabled logic programs. In Proceedings of the 19th International Conference on Logic Programming. Springer, 392--406.|Michael L. Scott. 1991. The Lynx distributed programming language: Motivation, design, and experience. Computer Languages 16, 3, 209--233.  |Traian Florin Serbanuta, Grigore Rosu, and Jose Meseguer. 2009. A rewriting logic approach to operational semantics. Information and Computation 207, 2, 305--340.  |Konstantin Shvachko, Hairong Kuang, Sanjay Radia, and Robert Chansler. 2010. The Hadoop distributed file system. In Proceedings of the IEEE 26th Symposium on Mass Storage Systems and Technologies. IEEE CS Press, 1--10.  |I. Stoica, R. Morris, D. Liben-Nowell, D. R. Karger, M. F. Kaashoek, F. Dabek, and H. Balakrishnan. 2003. Chord: A scalable peer-to-peer lookup protocol for Internet applications. IEEE/ACM Transactions on Networking 11, 1, 17--32.  |Theresa Swift, David S. Warren, and others. 2016. The XSB System Version 3.7,x. Retrieved April 8, 2017 from http://xsb.sourceforge.net.|Gerard Tel. 2000. Introduction to Distributed Algorithms (2nd ed.) Cambridge University Press, New York, NY. |Robbert van Renesse and Deniz Altinbuken. 2015. Paxos made moderately complex. Computer Surveys 47, 3, 42:1--42:36.  |Robbert van Renesse and Fred B. Schneider. 2004. Chain replication for supporting high throughput and availability. In Proceedings of the 6th USENIX Symposium on Operating Systems Design and Implementation. USENIX Association, 91--104. |Dan E. Willard. 1984. Efficient processing of relational calculus expressions using range query theory. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data. 164--175.  |Dan E. Willard. 2002. An algorithm for handling many relational calculus queries efficiently. Journal of Computer and System Sciences 65, 295--331.|Andrew K. Wright and Matthias Felleisen. 1994. A syntactic approach to type soundness. Information and Computation 115, 38--94.  |Ben Y. Zhao, Ling Huang, Jeremy Stribling, Sean C. Rhea, Anthony D. Joseph, and John D Kubiatowicz. 2004. Tapestry: A resilient global-scale overlay for service deployment. IEEE Journal on Selected Areas in Communications 22, 1, 41--53.  |", "organization": "Stony Brook University, NY, USA|Stony Brook University, NY, USA|Stony Brook University, NY, USA|Stony Brook University, NY, USA|Stony Brook University, NY, USA|Stony Brook University, NY, USA|", "title": ["From Clarity to Efficiency for Distributed Algorithms"]},
{"abstract": "We introduce a novel approach to typestate-oriented programming based on the chemical metaphor: state and operations on objects are molecules of messages, and state transformations are chemical reactions. This approach allows us to investigate typestate in an inherently concurrent setting, whereby objects can be accessed and modified concurrently by several processes, each potentially changing only part of their state. We introduce a simple behavioral type theory to express in a uniform way both the private and the public interfaces of objects; describe and enforce structured object protocols consisting of possibilities, prohibitions, and obligations; and control object sharing.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Silvia Crafa|Luca Padovani|Silvia Crafa|Luca Padovani|", "references": "", "organization": "Universit\u00e0 di Padova, Padova, Italy|Universit\u00e0 di Torino, Torino, Italy|Universit\u00e0 di Padova, Padova, Italy|Universit\u00e0 di Torino, Torino, Italy|", "title": ["The Chemical Approach to Typestate-Oriented Programming"]},
{"abstract": "We present a sound method for clustering alarms from static analyzers. Our method clusters alarms by discovering sound dependencies between them such that if the dominant alarms of a cluster turns out to be false, all the other alarms in the same cluster are guaranteed to be false. We have implemented our clustering algorithm on top of a realistic buffer-overflow analyzer and proved that our method reduces 45% of alarm reports. Our framework is applicable to any abstract interpretation-based static analysis and orthogonal to abstraction refinements and statistical ranking schemes.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Woosuk Lee|Wonchan Lee|Dongok Kang|Kihong Heo|Hakjoo Oh|Kwangkeun Yi|Woosuk Lee|Wonchan Lee|Dongok Kang|Kihong Heo|Hakjoo Oh|Kwangkeun Yi|", "references": "", "organization": "Seoul National University, Seoul, Korea|Stanford University|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Korea University, Seongbuk-gu, Seoul, Korea|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Stanford University|Seoul National University, Seoul, Korea|Seoul National University, Seoul, Korea|Korea University, Seongbuk-gu, Seoul, Korea|Seoul National University, Seoul, Korea|", "title": ["Sound Non-Statistical Clustering of Static Analysis Alarms"]},
{"abstract": "The Message Passing Interface (MPI) is the standard API for parallelization in high-performance and scientific computing. Communication deadlocks are a frequent problem in MPI programs, and this article addresses the problem of discovering such deadlocks. We begin by showing that if an MPI program is single path, the problem of discovering communication deadlocks is NP-complete. We then present a novel propositional encoding scheme that captures the existence of communication deadlocks. The encoding is based on modeling executions with partial orders and implemented in a tool called \n. The tool executes an MPI program, collects the trace, builds a formula from the trace using the propositional encoding scheme, and checks its satisfiability. Finally, we present experimental results that quantify the benefit of the approach in comparison to other analyzers and demonstrate that it offers a scalable solution for single-path programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Vojt\u01cech Forejt|Saurabh Joshi|Daniel Kroening|Ganesh Narayanaswamy|Subodh Sharma|Vojt\u01cech Forejt|Saurabh Joshi|Daniel Kroening|Ganesh Narayanaswamy|Subodh Sharma|", "references": "", "organization": "Diffblue Ltd., Oxford, UK|IIT Hyderabad, Kandi, Telangana, India|University of Oxford and Diffblue Ltd.|University of Oxford, Oxford, UK|IIT Delhi, India|Diffblue Ltd., Oxford, UK|IIT Hyderabad, Kandi, Telangana, India|University of Oxford and Diffblue Ltd.|University of Oxford, Oxford, UK|IIT Delhi, India|", "title": ["Precise Predictive Analysis for Discovering Communication Deadlocks in MPI Programs"]},
{"abstract": "Verifying invariants of fine-grained concurrent data structures is challenging, because interference from other threads may occur at any time. We propose a new way of proving invariants of fine-grained concurrent data structures: applying rely-guarantee reasoning to references in the concurrent setting. Rely-guarantee applied to references can verify bounds on thread interference without requiring a whole program to be verified.\nThis article provides three new results. First, it provides a new approach to preserving invariants and restricting usage of concurrent data structures. Our approach targets a space between simple type systems and modern concurrent program logics, offering an intermediate point between unverified code and full verification. Furthermore, it avoids sealing concurrent data structure implementations and can interact safely with unverified imperative code. Second, we demonstrate the approach\u2019s broad applicability through a series of case studies, using two implementations: an axiomatic C\n domain-specific language and a library for Liquid Haskell. Third, these two implementations allow us to compare and contrast verifications by interactive proof (C\n) and a weaker form that can be expressed using automatically-discharged dependent refinement types (Liquid Haskell).\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Colin S. Gordon|Michael D. Ernst|Dan Grossman|Matthew J. Parkinson|Colin S. Gordon|Michael D. Ernst|Dan Grossman|Matthew J. Parkinson|", "references": "", "organization": "Drexel University, Philadelphia, USA|University of Washington, Seattle, USA|University of Washington, Seattle, USA|Microsoft Research, Cambridge, United Kingdom|Drexel University, Philadelphia, USA|University of Washington, Seattle, USA|University of Washington, Seattle, USA|Microsoft Research, Cambridge, United Kingdom|", "title": ["Verifying Invariants of Lock-Free Data Structures with Rely-Guarantee and Refinement Types"]},
{"abstract": "Distributed actor languages are an effective means of constructing scalable reliable systems, and the Erlang programming language has a well-established and influential model. While the Erlang model conceptually provides reliable scalability, it has some inherent scalability limits and these force developers to depart from the model at scale. This article establishes the scalability limits of Erlang systems and reports the work of the EU RELEASE project to improve the scalability and understandability of the Erlang reliable distributed actor model.\nWe systematically study the scalability limits of Erlang and then address the issues at the virtual machine, language, and tool levels. More specifically: (1) We have evolved the Erlang virtual machine so that it can work effectively in large-scale single-host multicore and NUMA architectures. We have made important changes and architectural improvements to the widely used Erlang/OTP release. (2) We have designed and implemented Scalable Distributed (SD) Erlang libraries to address language-level scalability issues and provided and validated a set of semantics for the new language constructs. (3) To make large Erlang systems easier to deploy, monitor, and debug, we have developed and made open source releases of five complementary tools, some specific to SD Erlang.\nThroughout the article we use two case studies to investigate the capabilities of our new technologies and tools: a distributed hash table based Orbit calculation and Ant Colony Optimisation (ACO). Chaos Monkey experiments show that two versions of ACO survive random process failure and hence that SD Erlang preserves the Erlang reliability model. While we report measurements on a range of NUMA and cluster architectures, the key scalability experiments are conducted on the Athos cluster with 256 hosts (6,144 cores). Even for programs with no global recovery data to maintain, SD Erlang partitions the network to reduce network traffic and hence improves performance of the Orbit and ACO benchmarks above 80 hosts. ACO measurements show that maintaining global recovery data dramatically limits scalability; however, scalability is recovered by partitioning the recovery data. We exceed the established scalability limits of distributed Erlang, and do not reach the limits of SD Erlang for these benchmarks at this scale (256 hosts, 6,144 cores).\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Phil Trinder|Natalia Chechina|Nikolaos Papaspyrou|Konstantinos Sagonas|Simon Thompson|Stephen Adams|Stavros Aronis|Robert Baker|Eva Bihari|Olivier Boudeville|Francesco Cesarini|Maurizio Di Stefano|Sverker Eriksson|Vikt\u00f3ria f\u00f6rd\u0151s|Amir Ghaffari|Aggelos Giantsios|Rickard Green|Csaba Hoch|David Klaftenegger|Huiqing Li|Kenneth Lundin|Kenneth Mackenzie|Katerina Roukounaki|Yiannis Tsiouris|Kjell Winblad|Phil Trinder|Natalia Chechina|Nikolaos Papaspyrou|Konstantinos Sagonas|Simon Thompson|Stephen Adams|Stavros Aronis|Robert Baker|Eva Bihari|Olivier Boudeville|Francesco Cesarini|Maurizio Di Stefano|Sverker Eriksson|Vikt\u00f3ria f\u00f6rd\u0151s|Amir Ghaffari|Aggelos Giantsios|Rickard Green|Csaba Hoch|David Klaftenegger|Huiqing Li|Kenneth Lundin|Kenneth Mackenzie|Katerina Roukounaki|Yiannis Tsiouris|Kjell Winblad|", "references": "", "organization": "University of Glasgow, Glasgow, Scotland|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|Uppsala University and National Technical University of Athens, Uppsala, Sweden|University of Kent, Canterbury, UK|University of Kent, Canterbury, UK|Uppsala University, Uppsala, Sweden|University of Kent, Canterbury, UK|Erlang Solutions, London, UK|\u00c9lectricit\u00e9 de France|Erlang Solutions, London, UK|University of Kent, Canterbury, UK|Ericsson AB, Kista, Sweden|Erlang Solutions, London, UK|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|Ericsson AB, Kista, Sweden|Erlang Solutions, London, UK|Uppsala University, Uppsala, Sweden|University of Kent, Canterbury, UK|Ericsson AB, Kista, Sweden|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|National Technical University of Athens, Athens, Greece|Uppsala University, Uppsala, Sweden|University of Glasgow, Glasgow, Scotland|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|Uppsala University and National Technical University of Athens, Uppsala, Sweden|University of Kent, Canterbury, UK|University of Kent, Canterbury, UK|Uppsala University, Uppsala, Sweden|University of Kent, Canterbury, UK|Erlang Solutions, London, UK|\u00c9lectricit\u00e9 de France|Erlang Solutions, London, UK|University of Kent, Canterbury, UK|Ericsson AB, Kista, Sweden|Erlang Solutions, London, UK|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|Ericsson AB, Kista, Sweden|Erlang Solutions, London, UK|Uppsala University, Uppsala, Sweden|University of Kent, Canterbury, UK|Ericsson AB, Kista, Sweden|University of Glasgow, Glasgow, Scotland|National Technical University of Athens, Athens, Greece|National Technical University of Athens, Athens, Greece|Uppsala University, Uppsala, Sweden|", "title": ["Scaling Reliably: Improving the Scalability of the Erlang Distributed Actor Platform"]},
{"abstract": "Non-termination is the root cause of a variety of program bugs, such as hanging programs and denial-of-service vulnerabilities. This makes an automated analysis that can prove the absence of such bugs highly desirable. To scale termination checks to large systems, an interprocedural termination analysis seems essential. This is a largely unexplored area of research in termination analysis, where most effort has focussed on small but difficult single-procedure problems.\nWe present a modular termination analysis for C programs using template-based interprocedural summarisation. Our analysis combines a context-sensitive, over-approximating forward analysis with the inference of under-approximating preconditions for termination. Bit-precise termination arguments are synthesised over lexicographic linear ranking function templates. Our experimental results show the advantage of interprocedural reasoning over monolithic analysis in terms of efficiency, while retaining comparable precision.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Hong-Yi Chen|Cristina David|Daniel Kroening|Peter Schrammel|Bj\u00f6rn Wachter|Hong-Yi Chen|Cristina David|Daniel Kroening|Peter Schrammel|Bj\u00f6rn Wachter|", "references": "", "organization": "Department of Computer Science, University of Oxford, United Kingdom|Department of Computer Science, University of Oxford, United Kingdom|Department of Computer Science, University of Oxford, United Kingdom|School of Engineering and Informatics, University of Sussex, United Kingdom|SSW-Trading GmbH, Oststeinbek, Germany|Department of Computer Science, University of Oxford, United Kingdom|Department of Computer Science, University of Oxford, United Kingdom|Department of Computer Science, University of Oxford, United Kingdom|School of Engineering and Informatics, University of Sussex, United Kingdom|SSW-Trading GmbH, Oststeinbek, Germany|", "title": ["Bit-Precise Procedure-Modular Termination Analysis"]},
{"abstract": "We introduce a general way to locate programmer mistakes that are detected by static analyses. The program analysis is expressed in a general constraint language that is powerful enough to model type checking, information flow analysis, dataflow analysis, and points-to analysis. Mistakes in program analysis result in unsatisfiable constraints. Given an unsatisfiable system of constraints, both satisfiable and unsatisfiable constraints are analyzed to identify the program expressions most likely to be the cause of unsatisfiability. The likelihood of different error explanations is evaluated under the assumption that the programmer\u2019s code is mostly correct, so the simplest explanations are chosen, following Bayesian principles. For analyses that rely on programmer-stated assumptions, the diagnosis also identifies assumptions likely to have been omitted. The new error diagnosis approach has been implemented as a tool called SHErrLoc, which is applied to three very different program analyses, such as type inference for a highly expressive type system implemented by the Glasgow Haskell Compiler\u2014including type classes, Generalized Algebraic Data Types (GADTs), and type families. The effectiveness of the approach is evaluated using previously collected programs containing errors. The results show that when compared to existing compilers and other tools, SHErrLoc consistently identifies the location of programmer errors significantly more accurately, without any language-specific heuristics.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Danfeng Zhang|Andrew C. Myers|Dimitrios Vytiniotis|Simon Peyton-Jones|Danfeng Zhang|Andrew C. Myers|Dimitrios Vytiniotis|Simon Peyton-Jones|", "references": "Alexander Aiken. 1999. Introduction to set constraint-based program analysis. Sci. Comput. Program. 35, 2--3 (1999), 79--111  |Alexander Aiken and Edward L. Wimmers. 1993. Type inclusion constraints and type inference. In Proceedings of the Conference on Functional Programming Languages and Computer Architecture. 31--41.  |Lars Ole Andersen. 1994. Program Analysis and Specialization for the C Programming Language. Ph.D. Dissertation. DIKU, University of Copenhagen.|Owen Arden, Michael D. George, Jed Liu, K. Vikram, Aslan Askarov, and Andrew C. Myers. 2012. Sharing mobile code securely with information flow control. In Proceedings of the IEEE Symposium on Security and Privacy. 191--205.  |Thomas Ball, Mayur Naik, and Sriram Rajamani. 2003. From symptom to cause: Localizing errors in counterexample traces. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201903). 97--105.  |Chris Barrett, Riko Jacob, and Madhav Marathe. 2000. Formal-language-constrained path problems. SIAM J. Comput. 30, 3 (2000), 809--837.  |Sam Blackshear and Shuvendu K. Lahiri. 2013. Almost-correct specifications: A modular semantic framework for assigning confidence to warnings. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201913). 209--218.  |Shen Chen. 2014. Accuracy of CF-Typing. Private communication. (2014).|Sheng Chen and Martin Erwig. 2014. Better Type-Error Messages Through Lazy Typing. Technical Report. Oregon State University.|Sheng Chen and Martin Erwig. 2014. Counter-factual typing for debugging type errors. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201914).  |Venkatesh Choppella and Christopher T. Haynes. 1995. Diagnosis of Ill-typed Programs. Technical Report. Indiana University.|Luis Manuel Martins Damas. 1985. Type Assignment in Programming Languages. Ph.D. Dissertation. Department of Computer Science, University of Edinburgh.|Dorothy E. Denning. 1976. A Lattice model of secure information flow. Commun. ACM 19, 5 (1976), 236--243.  |Isil Dillig, Thomas Dillig, and Alex Aiken. 2012. Automated error diagnosis using abductive inference. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201912). 181--192.  |EasyOCaml. 2009. EasyOCaml. Retrieved from http://easyocaml.forge.ocamlcore.org.|Jeffrey S. Foster, Manuel Fahndrich, and Alexander Aiken. 1997. Flow-Insensitive Points-to Analysis with Term and Set Constraints. Technical Report. Berkeley, CA, USA. |Jeffrey S. Foster, Robert Johnson, John Kodumal, and Alex Aiken. 2006. Flow-insensitive type qualifiers. ACM Trans. Program. Lang. Syst. 28, 6 (Nov. 2006), 1035--1087.  |Andrew Gelman, John B. Carlin, Hal S. Stern, and Donald B. Rubin. 2004. Bayesian Data Analysis (2nd ed.). Chapman 8 Hall/CRC.|Christian Haack and J. B. Wells. 2004. Type error slicing in implicitly typed higher-order languages. Sci. Comput. Program. 50, 1--3 (2004), 189--224.  |Jurriaan Hage. 2014. Helium benchmark programs (2002--2005). Private communication. (2014).|Jurriaan Hage and Bastiaan Heeren. 2007. Heuristics for type error discovery and recovery. In Implementation and Application of Functional Languages, Zolt\u00e1n Horv\u00e1th, Vikt\u00f3ria Zs\u00f3k, and Andrew Butterfield (Eds.). Lecture Notes in Computer Science, Vol. 4449. Springer, 199--216. |P. E. Hart, N. J. Nilsson, and B. Raphael. 1968. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans Syst. Sci. Cybernet. 4, 2 (1968), 100--107.|Bastiaan Heeren, Daan Leijen, and Arjan van IJzendoorn. 2003. Helium, for learning Haskell. In Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell. 62--71.  |Bastiaan J. Heeren. 2005. Top Quality Type Error Messages. Ph.D. Dissertation. Universiteit Utrecht, The Netherlands.|Helium 1.8(2014) 2014. Helium (ver. 1.8). Retrieved from https://hackage.haskell.org/package/helium.|Paul Hudak, Simon Peyton Jones, and Philip Wadler. 1992. Report on the programming language Haskell. SIGPLAN Not. 27, 5 (May 1992).  |Gregory F. Johnson and Janet A. Walz. 1986. A maximum flow approach to anomaly isolation in unification-based incremental type inference. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201986). 44--57.  |Dave King, Trent Jaeger, Somesh Jha, and Sanjit A. Seshia. 2008. Effective blame for information-flow violations. In Proceedings of the International Symposium on Foundations of Software Engineering. 250--260.  |Ted Kremenek, Paul Twohey, Godmar Back, Andrew Ng, and Dawson Engler. 2006. From uncertainty to belief: Inferring the specification within. In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI\u201906). 161--176. http://dl.acm.org/citation.cfm?id&equals;1298455.1298471 |Oukseh Lee and Kwangkeun Yi. 1998. Proofs about a folklore let-polymorphic type inference algorithm. ACM Trans. Program. Lang. Syst. 20, 4 (July 1998), 707--723.  |Benjamin S. Lerner, Matthew Flower, Dan Grossman, and Craig Chambers. 2007. Searching for type-error messages. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201907). 425--434.  |Ben Liblit, Mayur Naik, Alice X. Zheng, Alex Aiken, and Michael I. Jordan. 2005. Scalable statistical bug isolation. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201905). 15--26.  |Benjamin Livshits, Aditya V. Nori, Sriram K. Rajamani, and Anindya Banerjee. 2009. Merlin: Specification inference for explicit information flow problems. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201909). 75--86.  |Calvin Loncaric, Satish Chandra, Cole Schlesinger, and Manu Sridharan. 2016. A practical framework for type inference error explanation. 781--799.  |Simon Marlow and Simon Peyton-Jones. 1993. The Glasgow Haskell Compiler. Retrieved from http://www.aosabook.org/en/ghc.html.|Bruce James McAdam. 1998. On the unification of substitutions in type inference. In Implementation of Functional Languages. 139--154.|Bruce James McAdam. 2001. Repairing Type Errors in Functional Programs. Ph.D. Dissertation. Laboratory for Foundations of Computer Science, The University of Edinburgh.|David Melski and Thomas Reps. 2000. Interconvertibility of a class of set constraints and context-free language reachability. Theoret. Comput. Sci. 248, 1--2 (2000), 29--98.  |Robin Milner, Mads Tofte, and Robert Harper. 1990. The Definition of Standard ML. MIT Press, Cambridge, MA. |Andrew C. Myers and Barbara Liskov. 1997. A decentralized model for information flow control. In Proceedings of the ACM Symposium on Operating System Principles (SOSP\u201997). 129--142.  |Andrew C. Myers, Lantian Zheng, Steve Zdancewic, Stephen Chong, and Nathaniel Nystrom. 2006. Jif 3.0: Java Information Flow. Software release, www.cs.cornell.edu/jif. (July 2006).|Anil Nerode and Richard Shore. 1997. Logic for Applications (2nd ed.). Springer, New York, NY. |OCaml. 2016. OCaml programming language. Retrieved from http://ocaml.org.|Martin Odersky, Martin Sulzmann, and Martin Wehr. 1999. Type inference with constrained types. Theor. Pract. Object Syst. 5, 1 (Jan. 1999), 35--55. 2-4  |Zvonimir Pavlinovic, Tim King, and Thomas Wies. 2014. Finding minimum type error sources. In Proceedings of the 2014 ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA\u201914). 525--542.  |Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Mark Shields. 2007. Practical type inference for arbitrary-rank types. J. Funct. Program. 17, 1 (Jan. 2007), 1--82. 0956-7968  |Francois Pottier and Didier R\u00e9my. 2005. The essence of ML type inference. In Advanced Topics in Types and Programming Languages, Benjamin C. Pierce (Ed.). MIT Press, 389--489.|Vincent Rahli, J. B. Wells, and Fairouz Kamareddine. 2010. A Constraint System for a SML Type Error Slicer. Technical Report HW-MACS-TR-0079. Heriot-Watt University.|Thomas Reps. 1998. Program analysis via graph reachability. Info. Softw. Technol. 40, 11--12 (1998), 701--726.|SHErrLoc. 2014. SHErrLoc (Static Holistic Error Locator) Tool Release (ver 1.0). Retrieved from http://www.cs.cornell.edu/projects/sherrloc.|Bjarne Steensgaard. 1996. Points-to analysis in almost linear time. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201996). 32--41.  |Frank Tip and T. B. Dinesh. 2001. A slicing-based approach for locating type errors. ACM Trans. Softw. Eng. Methodol. 10, 1 (2001), 5--55.  |Dimitrios Vytiniotis, Simon Peyton Jones, Tom Schrijvers, and Martin Sulzmann. 2011. OutsideIn(X): Modular type inference with local assumptions. J. Funct. Program. 21, 4--5 (2011), 333\u2013412.  |Dimitrios Vytiniotis, Simon Peyton Jones, and Tom Schrijvers. 2010. Let should not be generalized. In Proceedings of the 5th ACM SIGPLAN Workshop on Types in Language Design and Implementation. ACM, New York, NY, 39--50.  |Mitchell Wand. 1986. Finding the source of type errors. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201986).  |Mitchell Wand. 1987. A simple algorithm and proof for type inference. Fundam. Inform. 10, 2 (1987), 115--122.|Jeroen Weijers, Jurriaan Hage, and Stefan Holdermans. 2013. Security type error diagnosis for higher-order, polymorphic languages. In Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation. 3--12.  |Danfeng Zhang and Andrew C. Myers. 2014. Toward general diagnosis of static errors. In Proceedings of the ACM Symposium on Principles of Programming Languages (POPL\u201914). 569--581. http://www.cs.cornell.edu/andru/papers/diagnostic.  |Danfeng Zhang, Andrew C. Myers, Dimitrios Vytiniotis, and Simon Peyton Jones. 2015. Diagnosing type errors with class. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\u201915). 12--21.  |Alice X. Zheng, Ben Liblit, and Mayur Naik. 2006. Statistical debugging: Simultaneous identification of multiple bugs. In Proceedings of the International Conference on Machine Learning (ICML\u201906). 1105--1112.  |", "organization": "Pennsylvania State University, PA, USA|Cornell University, NY, USA|Microsoft Research Cambridge, Cambridge, United Kingdom|Microsoft Research Cambridge, Cambridge, United Kingdom|Pennsylvania State University, PA, USA|Cornell University, NY, USA|Microsoft Research Cambridge, Cambridge, United Kingdom|Microsoft Research Cambridge, Cambridge, United Kingdom|", "title": ["SHErrLoc: A Static Holistic Error Locator"]},
{"abstract": "Modern systems are increasingly susceptible to soft errors that manifest themselves as bit flips and possibly alter the semantics of an application. We would like to measure the quality degradation on semantics due to such bit flips, and thus we introduce a Hyperball abstract domain that allows us to determine the worst-case distance between expected and actual results. Similar to intervals, hyperballs describe a connected and dense space. The semantics of low-level code in the presence of bit flips is hard to accurately describe in such a space. We therefore combine the Hyperball domain with an existing affine system abstract domain that we extend to handle bit flips, which are introduce as disjunctions. Bit-flips can reduce the precision of our analysis, and we therefor introduce the Scale domain as a disjunctive refinement to minimize precision loss. This domain bounds the number of disjunctive elements by quantifying the over-approximation of different partitions and uses submodular optimization to find a good partitioning (within a bound of optimal). We evaluate these domains to show benefits and potential problems. For the application we examine here, adding the Scale domain to the Hyperball abstraction improves accuracy by up to two orders of magnitude. Our initial results demonstrate the feasibility of this approach, although we would like to further improve execution efficiency.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jacob Lidman|Sally A. Mckee|Jacob Lidman|Sally A. Mckee|", "references": "", "organization": "Chalmers University of Technology, Gothenburg, Sweden|Chalmers University of Technology, Gothenburg, Sweden|Chalmers University of Technology, Gothenburg, Sweden|Chalmers University of Technology, Gothenburg, Sweden|", "title": ["Verifying Reliability Properties Using the Hyperball Abstract Domain"]},
{"abstract": "Constraint-based refactoring generalizes constraint-based type refactoring as introduced by Tip et al. [61] by extending the coverage of change from types to names, locations, accessibilities, and other properties of program elements. Starting with a generic specification of refactoring tools, we systematically develop constraint-based refactoring as a generic solution to a certain class of refactoring problems and provide a condition under which constraint-based refactoring tools are proven correct for any given target language. Although compliance with this correctness condition is hard to prove for target languages whose semantics is not formally defined, we show how the condition gives rise to automated testing procedures. We present a novel algorithm based on constraint-logic programming for the generation of constraints from a program to be refactored, and demonstrate its time and space requirements by using it in the application of refactorings to open source programs. Summarizing earlier work, we show how the principles underlying constraint-based refactoring tools extend to ad hoc refactoring, cross-language refactoring, and model/code co-refactoring.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Friedrich Steimann|Friedrich Steimann|", "references": "", "organization": "Fernuniversit\u00e4t in Hagen, Germany|Fernuniversit\u00e4t in Hagen, Germany|", "title": ["Constraint-Based Refactoring"]},
{"abstract": "For specifying and reasoning about object-based programs, it is often attractive for contracts to be expressed using calls to pure methods. It is useful for pure methods to have contracts, including read effects, to support local reasoning based on frame conditions. This leads to puzzles such as the use of a pure method in its own contract. These ideas have been explored in connection with verification tools based on axiomatic semantics, guided by the need to avoid logical inconsistency, and focusing on encodings that cater for first-order automated provers. This article adds pure methods and read effects to region logic, a first-order program logic that features frame-based local reasoning and provides modular reasoning principles for end-to-end correctness. Modular reasoning is embodied in a proof rule for linking a module\u2019s method implementations with a client that relies on the method contracts. Soundness is proved with respect to conventional operational semantics and uses an extensional (i.e, relational) interpretation of read effects. Applicability to tools based on SMT solvers is demonstrated through machine-checked verification of examples. The developments in this article can guide the implementations of linking as used in modular verifiers and serve as a basis for studying observationally pure methods and encapsulation.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Anindya Banerjee|David A. Naumann|Mohammad Nikouei|Anindya Banerjee|David A. Naumann|Mohammad Nikouei|", "references": "Jonathan Aldrich, Mike Barnett, Dimitra Giannakopoulou, Gary T. Leavens, Natasha Sharygina, and Robby. 2008. Seventh International Workshop on Specification and Verification of Component Systems (SAVCBS'08). Technical Report CS-TR-08-07. School of Electrical Engineering and Computer Science, University of Central Florida.|T. Amtoft, S. Bandhakavi, and A. Banerjee. 2006. A logic for information flow in object-oriented programs. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 91--102.  |Krzysztof R. Apt, Frank S. de Boer, and Ernst-R\u00fcdiger Olderog. 2009. Verification of Sequential and Concurrent Programs (3rd ed.). Springer. |Anindya Banerjee and David A. Naumann. 2005. Ownership confinement ensures representation independence for object-oriented programs. J. ACM 52, 6 (2005), 894--960.  |Anindya Banerjee and David A. Naumann. 2013. Local reasoning for global invariants, part II: Dynamic boundaries. J. ACM 60, 3 (2013), 19:1--19:73.  |Anindya Banerjee and David A. Naumann. 2014. A logical analysis of framing for specifications with pure method calls. In Verified Software: Theories, Tools, Experiments. Lecture Notes in Computer Science, Vol. 8471. Springer, 3--20.|Anindya Banerjee, David A. Naumann, and Mohammad Nikouei. 2016. Relational logic with framing and hypotheses. In Proceedings of the 36th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (LIPIcs'16), Vol. 65. Schloss Dagstuhl -- Leibniz-Zentrum f\u00fcr Informatik, 11:1--11:16.|Anindya Banerjee, David A. Naumann, and Stan Rosenberg. 2013. Local reasoning for global invariants, part I: Region logic. J. ACM 60, 3 (2013), 18:1--18:56.  |Yuyan Bao. 2017. Reasoning About Frame Properties in Object-Oriented Programs. Technical Report CS-TR-17-05. University of Central Florida. www.cs.ucf.edu/&sim;leavens/tech-reports/UCF/CS-TR-17-05/TR.pdf.|Yuyan Bao, Gary T. Leavens, and Gidon Ernst. 2015. Conditional effects in fine-grained region logic. In Proceedings of the 17th Workshop on Formal Techniques for Java-Like Programs (FTfJP'15). 5:1--5:6.  |Mike Barnett, Manuel F\u00e4hndrich, K. Rustan M. Leino, Peter M\u00fcller, Wolfram Schulte, and Herman Venter. 2011. Specification and verification: The spec# experience. Commun. ACM 54, 6 (2011), 81--91.  |Mike Barnett, David A. Naumann, Wolfram Schulte, and Qi Sun. 2004. 99.44% pure: Useful abstractions in specifications. In ECOOP Workshop on Formal Techniques for Java-like Programs (FTfJP'04). Technical Report NIII-R0426, University of Nijmegen.|Gilles Barthe, Pedro R. D\u2019Argenio, and Tamara Rezk. 2004. Secure information flow by self-composition. In Proceedings of the 17th IEEE Computer Security Foundations Workshop (CSFW\u201904). 100--114.  |Bernhard Beckert, Reiner H\u00e4hnle, and Peter H. Schmitt (eds.). 2007. Verification of Object-Oriented Software: The KeY Approach. Lecture Notes in Artificial Intelligence, Vol. 4334. Springer. |N. Benton. 2004. Simple relational correctness proofs for static analyses and program transformations. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 14--25.  |Nick Benton, Martin Hofmann, and Vivek Nigam. 2014. Abstract effects and proof-relevant logical relations. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 619--632.  |Nick Benton, Andrew Kennedy, Lennart Beringer, and Martin Hofmann. 2007. Relational semantics for effect-based program transformations with dynamic allocation. In Proceedings of the International Symposium on Principles and Practice of Declarative Programming. 87--96.  |Fran\u00e7ois Bobot and Jean-Christophe Filli\u00e2tre. 2012. Separation predicates: A taste of separation logic in first-order logic. In Proceedings of the International Conference on Formal Engineering Methods. Springer, 167--181.  |Richard Bornat, Cristiano Calcagno, Peter W. O\u2019Hearn, and Matthew J. Parkinson. 2005. Permission accounting in separation logic. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 259--270.  |Aaron R. Bradley and Zohar Manna. 2007. The Calculus of Computation--Decision Procedures with Applications to Verification. Springer. |David Cok and Gary T. Leavens. 2008. Extensions of the theory of observational purity and a practical design for JML. In Proceedings of the 7th International Workshop on Specification and Verification of Component-Based Systems. 43--50.|David R. Cok. 2005. Reasoning with specifications containing method calls and model fields. J. Object Tech. 4, 8 (2005), 77--103.|\u00c1d\u00e1m Darvas and K. Rustan M. Leino. 2007. Practical reasoning about invocations and implementations of pure methods. In Fundamental Approaches to Software Engineering. Springer, 336--351. |\u00c1d\u00e1m Darvas, Farhad Mehta, and Arsenii Rudich. 2008. Efficient well-definedness checking. In Automated Reasoning, 4th International Joint Conference. Lecture Notes in Computer Science, Vol. 5195. Springer, 100--115.  |\u00c1. Darvas and P. M\u00fcller. 2006. Reasoning about method calls in interface specifications. J. Object Tech. 5, 5 (June 2006), 59--85.|Jean-Christophe Filli\u00e2tre, L\u00e9on Gondelman, and Andrei Paskevich. 2016. The spirit of ghost code. Formal Meth. Sys. Des. 48, 3 (2016), 152--174.|Jean-Christophe Filli\u00e2tre, L\u00e9on Gondelman, and Andrei Paskevich. 2016. A Pragmatic Type System for Deductive Verification. Retrieved from https://hal.inria.fr/hal-01256434.|Cormac Flanagan, K. Rustan M. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe, and Raymie Stata. 2002. Extended static checking for Java. In Proceedings of the ACM Conference on Programming Language Design and Implementation. ACM, 234--245.  |John Hatcliff, Gary T. Leavens, K. Rustan M. Leino, Peter M\u00fcller, and Matthew J. Parkinson. 2012. Behavioral interface specification languages. ACM Comput. Surv. 44, 3 (2012), 16:1--16:58.  |Chris Hawblitzel, Jon Howell, Jacob R. Lorch, Arjun Narayan, Bryan Parno, Danfeng Zhang, and Brian Zill. 2014. Ironclad apps: End-to-end security via automated full-system verification. In Proceedings of the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI'14). USENIX Association, 165--181. |Stefan Heule, Ioannis T. Kassios, Peter M\u00fcller, and Alexander J. Summers. 2013. Verification condition generation for permission logics with abstract predicates and abstraction functions. In Proceedings of the European Conference on Object-Oriented Programming. Springer, 451--476.  |C. A. R. Hoare. 1972. Proofs of correctness of data representations. Acta Inform. 1 (1972), 271--281.  |Ioannis T. Kassios. 2006. Dynamic frames: Support for framing, dependencies and sharing without restrictions. In Formal Methods. Lecture Notes in Computer Science, Vol. 4085. Springer, 268--283.  |Ioannis T. Kassios. 2011. The dynamic frames theory. Form. Asp. Compu. 23, 3 (2011), 267--288.  |Gary T. Leavens, Albert L. Baker, and Clyde Ruby. 2006. Preliminary design of JML: A behavioral interface specification language for Java. ACM SIGSOFT Softw. Eng. Notes 31, 3 (2006), 1--38.  |Gary T. Leavens and David A. Naumann. 2015. Behavioral subtyping, specification inheritance, and modular reasoning. ACM Trans. on Progr. Lang. Systems 37, 4 (2015), 13:1--13:88.  |K. Rustan M. Leino. 2008. Specification and Versification in Object-Oriented Software. Microsoft.|K. Rustan M. Leino. 2010. Dafny: An automatic program verifier for functional correctness. In Proceedings of the International Conference on Logic for Programming Artificial Intelligence and Reasoning. Springer, 348--370. |K. Rustan M. Leino and Ronald Middelkoop. 2009. Proving consistency of pure methods and model fields. In Fundamental Aspects to Software Engineering. Lecture Notes in Computer Science, Vol. 5503. Springer, 231--245.  |K. Rustan M. Leino and Peter M\u00fcller. 2008. Verification of equivalent-results methods. In Proceedings of the ESOP. Springer, 307--321. |K. Rustan M. Leino and Peter M\u00fcller. 2009. A basis for verifying multi-threaded programs. In Proceedings of the European Symposium on Programming Languages and Systems. Springer, 378--393.  |K. Rustan M. Leino, Arnd Poetzsch-Heffter, and Yunhong Zhou. 2002. Using data groups to specify and check side effects. In Proceedings of the ACM Conference on Programming Langugage Design and Implementation. ACM, 246--257.  |Peter M\u00fcller, Malte Schwerhoff, and Alexander J. Summers. 2016. Viper: A verification infrastructure for permission-based reasoning. In Verification, Model Checking, and Abstract Interpretation. Lecture Notes in Computer Science, Vol. 9583. Springer, 41--62.  |Aleksandar Nanevski, Amal Ahmed, Greg Morrisett, and Lars Birkedal. 2007. Abstract predicates and mutable ADTs in Hoare type theory. In Programming Languages and Systems. Lecture Notes in Computer Science, Vol. 4421. Springer, 189--204. |Aleksandar Nanevski, Anindya Banerjee, and Deepak Garg. 2013. Dependent type theory for verification of information flow and access control policies. ACM Trans. Program. Lang. Syst. 35, 2 (2013), 6.  |David A. Naumann. 2007. Observational purity and encapsulation. Theo. Comput. Sci. 376, 3 (2007), 205--224.  |Peter W. O\u2019Hearn, Hongseok Yang, and John C. Reynolds. 2009. Separation and information hiding. ACM Tran. Progr. Lang. Sys. 31, 3 (2009), 1--50.  |Matthew Parkinson and Gavin Bierman. 2008. Separation logic, abstraction and inheritance. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 75--86.  |Matthew J. Parkinson and Gavin M. Bierman. 2005. Separation logic and abstraction. In Proceedings of the ACM Symposium on Principles of Programming Languages. ACM, 247--258.  |Matthew J. Parkinson and Alexander J. Summers. 2012. The relationship between separation logic and implicit dynamic frames. Log. Methods Comput. Sci. 8, 3 (2012), 802.|Ruzica Piskac, Thomas Wies, and Damien Zufferey. 2014. Grasshopper. In Tools and Algorithms for the Construction and Analysis of Systems. Lecture Notes in Computer Science, Vol. 8413. Springer, 124--139.|John C. Reynolds. 2002. Separation logic: A logic for shared mutable data structures. In Proceedings of the IEEE Symposium on Logic in Computer Science. IEEE Computer Society, 55--74. |Stan Rosenberg, Anindya Banerjee, and David A. Naumann. 2010. Local reasoning and dynamic framing for the composite pattern and its clients. In Verified Software: Theories, Tools, Experiments. Lecture Notes in Computer Science, Vol. 6217. Springer, 183--198. |Arsenii Rudich, \u00c1d\u00e1m Darvas, and Peter M\u00fcller. 2008. Checking well-formedness of pure-method specifications. In FM 2008: Formal Methods. Lecture Notes in Computer Science, Vol. 5014. Springer, 68--83.  |Alexandru Salcianu and Martin C. Rinard. 2005. Purity and side effect analysis for Java programs. In Verification, Model Checking, and Abstract Interpretation. Lecture Notes in Computer Science, Vol. 3385. Springer, 199--215.  |Peter H. Schmitt, Mattias Ulbrich, and Benjamin Wei\u00df. 2011. Dynamic frames in Java dynamic logic. In Formal Verification of Object-Oriented Software. Lecture Notes in Computer Science, Vol. 6528. Springer, Vol. 6528. 138--152. |Jan Smans, Bart Jacobs, and Frank Piessens. 2008. VeriCool: An automatic verifier for a concurrent object-oriented language. In Formal Methods for Open Object-Based Distributed Systems. Lecture Notes in Computer Science, Vol. 5051. Springer, 220--239.  |Jan Smans, Bart Jacobs, and Frank Piessens. 2012. Implicit dynamic frames. ACM Trans. Prog. Lang. Sys. 34, 1 (2012), 2.  |Jan Smans, Bart Jacobs, Frank Piessens, and Wolfram Schulte. 2010. Automatic verification of Java programs with dynamic frames. Form. Asp. Comput. 22, 3--4 (2010), 423--457.  |Alexander J. Summers and Sophia Drossopoulou. 2013. A formal semantics for isorecursive and equirecursive state abstractions. In Proceedings of the European Conference on Object-Oriented Programming. Springer, 129--153.  |Hongseok Yang. 2007. Relational separation logic. Theo. Comput. Sci. 375, 1--3 (2007), 308--334.  |", "organization": "IMDEA Software Institute, Madrid, Spain|Stevens Institute of Technology, Hoboken, NJ|Stevens Institute of Technology, Hoboken, NJ|IMDEA Software Institute, Madrid, Spain|Stevens Institute of Technology, Hoboken, NJ|Stevens Institute of Technology, Hoboken, NJ|", "title": ["A Logical Analysis of Framing for Specifications with Pure Method Calls"]},
{"abstract": "The syntax of the C programming language is described in the C11 standard by an ambiguous context-free grammar, accompanied with English prose that describes the concept of \u201cscope\u201d and indicates how certain ambiguous code fragments should be interpreted. Based on these elements, the problem of implementing a compliant C11 parser is not entirely trivial. We review the main sources of difficulty and describe a relatively simple solution to the problem. Our solution employs the well-known technique of combining an LALR(1) parser with a \u201clexical feedback\u201d mechanism. It draws on folklore knowledge and adds several original aspects, including a twist on lexical feedback that allows a smooth interaction with lookahead; a simplified and powerful treatment of scopes; and a few amendments in the grammar. Although not formally verified, our parser avoids several pitfalls that other implementations have fallen prey to. We believe that its simplicity, its mostly declarative nature, and its high similarity with the C11 grammar are strong informal arguments in favor of its correctness. Our parser is accompanied with a small suite of \u201ctricky\u201d C11 programs. We hope that it may serve as a reference or a starting point in the implementation of compilers and analysis tools.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jacques-Henri Jourdan|Fran\u00e7ois Pottier|Jacques-Henri Jourdan|Fran\u00e7ois Pottier|", "references": "", "organization": "Inria Paris, MPI-SWS, Saarbr\u00fccken, Germany|Inria Paris, Paris Cedex, France|Inria Paris, MPI-SWS, Saarbr\u00fccken, Germany|Inria Paris, Paris Cedex, France|", "title": ["A Simple, Possibly Correct LR Parser for C11"]},
{"abstract": "This article investigates the semantic intricacies of conditioning, a main feature in probabilistic programming. Our study is based on an extension of the imperative probabilistic guarded command language pGCL with conditioning. We provide a weakest precondition (wp) semantics and an operational semantics. To deal with possibly diverging program behavior, we consider liberal preconditions. We show that diverging program behavior plays a key role when defining conditioning. We establish that weakest preconditions coincide with conditional expected rewards in Markov chains\u2014the operational semantics\u2014and that the wp-semantics conservatively extends the existing semantics of pGCL (without conditioning). An extension of these results with nondeterminism turns out to be problematic: although an operational semantics using Markov decision processes is rather straightforward, we show that providing an inductive wp-semantics in this setting is impossible. Finally, we present two program transformations that eliminate conditioning from any program. The first transformation hoists conditioning while updating the probabilistic choices in the program, while the second transformation replaces conditioning\u2014in the same vein as rejection sampling\u2014by a program with loops. In addition, we present a last program transformation that replaces an independent identically distributed loop with conditioning.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Federico Olmedo|Friedrich Gretz|Nils Jansen|Benjamin Lucien Kaminski|Joost-Pieter Katoen|Annabelle Mciver|Federico Olmedo|Friedrich Gretz|Nils Jansen|Benjamin Lucien Kaminski|Joost-Pieter Katoen|Annabelle Mciver|", "references": "", "organization": "Department of Computer Science, University of Chile, Chile|Bosch Corporate Research, Germany|Radboud University Nijmegen, The Netherlands|RWTH Aachen University, Germany|RWTH Aachen University, Germany|Macquarie University, Sydney, Australia|Department of Computer Science, University of Chile, Chile|Bosch Corporate Research, Germany|Radboud University Nijmegen, The Netherlands|RWTH Aachen University, Germany|RWTH Aachen University, Germany|Macquarie University, Sydney, Australia|", "title": ["Conditioning in Probabilistic Programming"]},
{"abstract": "This article presents a full formal machine-checked verification of a C program: the OpenSSL implementation of SHA-256. This is an interactive proof of functional correctness in the Coq proof assistant, using the Verifiable C program logic. Verifiable C is a separation logic for the C language, proved sound with respect to the operational semantics for C, connected to the CompCert verified optimizing C compiler.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Andrew W. Appel|Andrew W. Appel|", "references": "", "organization": "Princeton University, Princeton, NJ|Princeton University, Princeton, NJ|", "title": ["Verification of a Cryptographic Primitive: SHA-256"]},
{"abstract": "In large-scale software applications, programmers often combine different programming languages because this allows them to use the most suitable language for a given problem, to gradually migrate existing projects from one language to another, or to reuse existing source code. However, different programming languages have fundamentally different implementations, which are hard to combine. The composition of language implementations often results in complex interfaces between languages, insufficient flexibility, or poor performance.\nWe propose TruffleVM, a virtual machine (VM) that can execute different programming languages and is able to compose them in a seamless way. TruffleVM supports dynamically-typed languages (e.g., JavaScript and Ruby) as well as statically typed low-level languages (e.g., C). It consists of individual language implementations, which translate source code to an intermediate representation that is executed by a shared VM. TruffleVM composes these different language implementations via \n. \n is a language-agnostic mechanism that language implementations use to access foreign data or call foreign functions. It features language-agnostic messages that the TruffleVM resolves to efficient foreign-language-specific operations at runtime. \n supports multiple languages, enables an efficient multi-language development, and ensures high performance.\nWe evaluate \n with two case studies. The first one explains the transparent composition of JavaScript, Ruby, and C. The second one shows an implementation of the C extensions application programming interface (API) for Ruby. We show that \n guarantees good runtime performance. It avoids conversion or marshalling of foreign objects at the language boundary and allows the dynamic compiler to perform its optimizations across language boundaries.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Matthias Grimmer|Roland Schatz|Chris Seaton|Thomas W\u00fcrthinger|Mikel Luj\u00e1n|Hanspeter M\u00f6ssenb\u00f6ck|Matthias Grimmer|Roland Schatz|Chris Seaton|Thomas W\u00fcrthinger|Mikel Luj\u00e1n|Hanspeter M\u00f6ssenb\u00f6ck|", "references": "", "organization": "Oracle Labs, Austria|Oracle Labs, Austria|Oracle Labs, United Kingdom|Oracle Labs, Switzerland|University of Manchester, United Kingdom|Johannes Kepler University|Oracle Labs, Austria|Oracle Labs, Austria|Oracle Labs, United Kingdom|Oracle Labs, Switzerland|University of Manchester, United Kingdom|Johannes Kepler University|", "title": ["Cross-Language Interoperability in a Multi-Language Runtime"]},
{"abstract": "In this article, we consider the termination problem of probabilistic programs with real-valued variables. The questions concerned are: qualitative ones that ask (i) whether the program terminates with probability 1 (almost-sure termination) and (ii) whether the expected termination time is finite (finite termination); and quantitative ones that ask (i) to approximate the expected termination time (expectation problem) and (ii) to compute a bound \n such that the probability not to terminate after \n steps decreases exponentially (concentration problem). To solve these questions, we utilize the notion of ranking supermartingales, which is a powerful approach for proving termination of probabilistic programs. In detail, we focus on algorithmic synthesis of linear ranking-supermartingales over affine probabilistic programs (A\n) with both angelic and demonic non-determinism. An important subclass of A\n is LRA\n which is defined as the class of all A\n over which a linear ranking-supermartingale exists.\nOur main contributions are as follows. Firstly, we show that the membership problem of LRA\n (i) can be decided in polynomial time for A\n with at most demonic non-determinism, and (ii) is NP-hard and in PSPACE for A\n with angelic non-determinism. Moreover, the NP-hardness result holds already for A\n without probability and demonic non-determinism. Secondly, we show that the concentration problem over LRA\n can be solved in the same complexity as for the membership problem of LRA\n. Finally, we show that the expectation problem over LRA\n can be solved in 2EXPTIME and is PSPACE-hard even for A\n without probability and non-determinism (i.e., deterministic programs). Our experimental results demonstrate the effectiveness of our approach to answer the qualitative and quantitative questions over A\n with at most demonic non-determinism.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Krishnendu Chatterjee|Hongfei Fu|Petr Novotn\u00fd|Rouzbeh Hasheminezhad|Krishnendu Chatterjee|Hongfei Fu|Petr Novotn\u00fd|Rouzbeh Hasheminezhad|", "references": "", "organization": "IST Austria, Klosterneuburg, Austria|Shanghai Jiao Tong University, Shanghai, P.R. China|IST Austria, Klosterneuburg, Austria|Sharif University of Technology, Iran|IST Austria, Klosterneuburg, Austria|Shanghai Jiao Tong University, Shanghai, P.R. China|IST Austria, Klosterneuburg, Austria|Sharif University of Technology, Iran|", "title": ["Algorithmic Analysis of Qualitative and Quantitative Termination Problems for Affine Probabilistic Programs"]},
{"abstract": "Foreign function interfaces (FFIs) allow components in different languages to communicate directly with each other. While FFIs are useful, they often require writing tricky low-level code and include little or no static safety checking, thus providing a rich source of hard-to-find programming errors. In this article, we study the problem of enforcing type safety across the OCaml-to-C FFI and the Java Native Interface (JNI). We present O-Saffire and J-Saffire, a pair of multilingual type inference systems that ensure C code that uses these FFIs accesses high-level data safely. Our inference systems use \n to model C's low-level view of OCaml and Java values, and singleton types to track integers, strings, memory offsets, and type tags through C. J-Saffire, our Java system, uses a polymorphic flow-insensitive, unification-based analysis. Polymorphism is important because it allows us to precisely model user-defined wrapper functions and the more than 200 JNI functions. O-Saffire, our OCaml system, uses a monomorphic flow-sensitive analysis because, while polymorphism is much less important for the OCaml FFI flow-sensitivity is critical to track conditional branches, which are used when pattern matching OCaml data in C. O-Saffire also tracks garbage collection information to ensure that local C pointers to the OCaml heap are registered properly, which is not necessary for the JNI. We have applied O-Saffire and J-Saffire to a set of benchmarks and found many bugs and questionable coding practices. These results suggest that static checking of FFIs can be a valuable tool in writing correct multilingual software.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Michael Furr|Jeffrey S. Foster|Michael Furr|Jeffrey S. Foster|", "references": "", "organization": "University of Maryland, College Park, MD|University of Maryland, College Park, MD|University of Maryland, College Park, MD|University of Maryland, College Park, MD|", "title": ["Checking type safety of foreign function calls"]},
{"abstract": "Atomicity is a fundamental correctness property in multithreaded programs. A method is atomic if, for every execution, there is an equivalent serial execution in which the actions of the method are not interleaved with actions of other threads. Atomic methods are amenable to sequential reasoning, which significantly facilitates subsequent analysis and verification.\nThis article presents a type system for specifying and verifying the atomicity of methods in multithreaded Java programs using a synthesis of Lipton's theory of reduction and type systems for race detection. The type system supports guarded, write-guarded, and unguarded fields, as well as thread-local data, parameterized classes and methods, and protected locks. We also present an algorithm for verifying atomicity via type inference.\nWe have applied our type checker and type inference tools to a number of commonly used Java library classes and programs. These tools were able to verify the vast majority of methods in these benchmarks as atomic, indicating that atomicity is a widespread methodology for multithreaded programming. In addition, reported atomicity violations revealed some subtle errors in the synchronization disciplines of these programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Cormac Flanagan|Stephen N. Freund|Marina Lifshin|Shaz Qadeer|Cormac Flanagan|Stephen N. Freund|Marina Lifshin|Shaz Qadeer|", "references": "", "organization": "University of California at Santa Cruz, Santa Cruz, CA|Williams College, Williamstown, MA|Williams College, Williamstown, MA|Microsoft Research, Redmond, WA|University of California at Santa Cruz, Santa Cruz, CA|Williams College, Williamstown, MA|Williams College, Williamstown, MA|Microsoft Research, Redmond, WA|", "title": ["Types for atomicity: Static checking and inference for Java"]},
{"abstract": "JavaScript is the source of many security problems, including cross-site scripting attacks and malicious advertising code. Central to these problems is the fact that code from untrusted sources runs with full privileges. \n help prevent violations of data confidentiality and integrity.\nThis article explores \n, a mechanism for providing information flow security in a dynamic manner that avoids the stuck executions of some prior approaches, such as the no-sensitive-upgrade technique. Faceted values simultaneously simulate multiple executions for different security levels to guarantee termination-insensitive noninterference. We also explore the interaction of faceted values with exceptions, declassification, and clearance.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Thomas H. Austin|Tommy Schmitz|Cormac Flanagan|Thomas H. Austin|Tommy Schmitz|Cormac Flanagan|", "references": "Aslan Askarov, Sebastian Hunt, Andrei Sabelfeld, and David Sands. 2008. Termination-insensitive noninterference leaks more than just a bit. In Proceedings of the European Symposium on Research in Computer Security (ESORICS\u201908). Springer-Verlag, 333--348.  |Aslan Askarov and Andrew Myers. 2010. A semantic framework for declassification and endorsement. In Proceedings of the European Symposium on Programming. 64--84.  |Aslan Askarov and Andrei Sabelfeld. 2009a. Catch me if you can: Permissive yet secure error handling. In Proceedings of the ACM SIGPLAN 4th Workshop on Programming Languages and Analysis for Security (PLAS\u201909). ACM, New York, NY, 45--57.  |Aslan Askarov and Andrei Sabelfeld. 2009b. Tight enforcement of information-release policies for dynamic languages. In Proceedings of the IEEE Computer Security Foundations Symposium. IEEE Computer Society, Washington, DC, 43--59.  |Thomas H. Austin. 2011. ZaphodFacetes github page. Retreived from https://github.com/taustin/ZaphodFacets.|Thomas H. Austin and Cormac Flanagan. 2009. Efficient purely-dynamic information flow analysis. In Proceedings of the Workshop on Programming Languages and Analysis for Security.  |Thomas H. Austin and Cormac Flanagan. 2010. Permissive dynamic information flow analysis. In Proceedings of the 5th ACM SIGPLAN Workshop on Programming Languages and Analysis for Security. ACM, 1--12.  |Thomas H. Austin and Cormac Flanagan. 2012. Multiple facets for dynamic information flow, See Field and Hicks {2012}, 165--178.  |Thomas H. Austin, Jean Yang, Cormac Flanagan, and Armando Solar-Lezama. 2013. Faceted execution of policy-agnostic programs. In Proceedings of the Workshop on Programming Languages and Analysis for Security.  |Anindya Banerjee and David A. Naumann. 2002. Secure information flow and pointer confinement in a Java-like language. In Proceedings of the IEEE Computer Security Foundations Workshop. 253--267. |Abhishek Bichhawat, Vineet Rajani, Deepak Garg, and Christian Hammer. 2014. Generalizing permissive-upgrade in dynamic information flow analysis. In Proceedings of the Workshop on Programming Languages and Analysis for Security.  |Arnar Birgisson, Alejandro Russo, and Andrei Sabelfeld. 2011. Capabilities for information flow. In Proceedings of the ACM SIGPLAN Fourth Workshop on Programming Languages and Analysis for Security (PLAS\u201911). ACM.  |Aaron Bohannon, Benjamin C. Pierce, Vilhelm Sj\u00f6berg, Stephanie Weirich, and Steve Zdancewic. 2009. Reactive noninterference. In Proceedings of the ACM Conference on Computer and Communications Security. 79--90.  |R. Capizzi, A. Longo, V. N. Venkatakrishnan, and A. P. Sistla. 2008. Preventing information leaks through shadow executions. In Proceedings of the Annual Computer Security Applications Conference (ACSAC\u201908). 322--331.  |Stephen Chong and Andrew C. Myers. 2004. Security policies for downgrading. In Proceedings of the 11th ACM Conference on Computer and Communications Security (CCS\u201904). ACM, New York, NY, 198--209.  |Ravi Chugh, Jeffrey A. Meister, Ranjit Jhala, and Sorin Lerner. 2009. Staged information flow for JavaScript. In Proceedings of the Conference on Programming Language Design and Implementation.  |Willem De Groef, Dominique Devriese, Nick Nikiforakis, and Frank Piessens. 2012. FlowFox: A web browser with flexible and precise information flow control. In Proceedings of the ACM Conference on Computer and Communications Security, Ting Yu, George Danezis, and Virgil D. Gligor (Eds.). ACM, 748--759.  |Dorothy E. Denning. 1976. A lattice model of secure information flow. Commun. ACM 19, 5 (1976), 236--243.  |Dominique Devriese and Frank Piessens. 2010. Noninterference through secure multi-execution. Proceedings of the IEEE Symposium on Security and Privacy. 109--124.  |Mohan Dhawan and Vinod Ganapathy. 2009. Analyzing information flow in JavaScript-based browser extensions. In Proceedings of the Annual Computer Security Applications Conference.  |Brendan Eich. 2004. Narcissus--JS implemented in JS. (2004). Retrieved from https://github.com/mozilla/narcissus/.|J. S. Fenton. 1974. Memoryless subsystems. Comput. J. 17, 2 (1974), 143--147. |John Field and Michael Hicks (Eds.). 2012. Proceedings of the 39th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201912). ACM. |Andreas Gal, David Flanagan, and Donovon Preston. 2011. dom.js github page. Retrieved October 2011 from https://github.com/andreasgal/dom.js.|Andreas Gampe and Jeffery von Ronne. 2011. Information flow control with errors. In Proceedings of the International Workshop on Foundations of Object-Oriented Languages (FOOL\u201911).|Gurvan Le Guernic, Anindya Banerjee, Thomas P. Jensen, and David A. Schmidt. 2006. Automata-based confidentiality monitoring. In Proceedings of the Asian Computing Science Conference on Secure Software. |Christian Hammer and Gregor Snelting. 2009. Flow-sensitive, context-sensitive, and object-sensitive information flow control based on program dependence graphs. Int. J. Inf. Sec. 8, 6 (2009), 399--422.  |Daniel Hedin, Luciano Bello, and Andrei Sabelfeld. 2015. Value-sensitive hybrid information flow control for a JavaScript-like language. In Proceedings of the IEEE 28th Computer Security Foundations Symposium (CSF 2015). IEEE, 351--365.  |Daniel Hedin and Andrei Sabelfeld. 2012. Information-flow security for a core of JavaScript. In Proceedings of the Computer Security Foundations Symposium.  |Nevin Heintze and Jon G. Riecke. 1998. The SLam calculus: Programming with secrecy and integrity. In Proceedings of the Symposium on Principles of Programming Languages.  |Catalin Hritcu, Michael Greenberg, Ben Karel, Benjamin C. Pierce, and Greg Morrisett. 2013. All your IFCException are belong to us. In Proceedings of the IEEE Symposium on Security and Privacy. 3--17.  |Sebastian Hunt and David Sands. 2006. On flow-sensitive security types. In Proceedings of the Principles of Programming Languages (POPL\u201906). 79--90.  |Dongseok Jang, Ranjit Jhala, Sorin Lerner, and Hovav Shacham. 2010. An empirical study of privacy-violating information flows in JavaScript web applications. In Proceedings of the ACM Conference on Computer and Communications Security. 270--283.  |Jif 2010. Jif homepage. Retrieved October 2010 from http://www.cs.cornell.edu/jif/.|Seth Just, Alan Cleary, Brandon Shirley, and Christian Hammer. 2011. Information flow analysis for javascript. In Proceedings of the Programming Language and Systems Technologies for Internet Clients. ACM, New York, NY, 9--18.  |Vineeth Kashyap, Ben Wiedermann, and Ben Hardekopf. 2011. Timing- and termination-sensitive secure information flow: Exploring a new approach. In Proceedings of IEEE Security and Privacy.  |Christoph Kerschbaumer, Eric Hennigan, Per Larsen, Stefan Brunthaler, and Michael Franz. 2013b. Information Flow Tracking meets Just-In-Time Compilation. (2013). (submitted)|Christoph Kerschbaumer, Eric Hennigan, Per Larsen, Stefan Brunthaler, and Michael Franz. 2013a. Towards precise and efficient information flow control in web browsers. In Proceedings of Trust and Trustworthy Computing. 187--195. |Dave King, Boniface Hicks, Michael Hicks, and Trent Jaeger. 2008. Implicit flows: Can\u2019t live with\u2019em, can\u2019t live without\u2019em. In Proceedings of the International Conference on Information Systems Security. 56--70.  |James C. King. 1976. Symbolic execution and program testing. Commun. ACM 19, 7 (1976), 385--394.  |Clemens Kolbitsch, Benjamin Livshits, Benjamin Zorn, and Christian Seifert. 2011. Rozzle: De-Cloaking Internet Malware. Technical Report MSR-TR-2011-94. Microsoft Research Technical Report.|Scott Moore, Aslan Askarov, and Stephen Chong. 2012. Precise enforcement of progress-sensitive security. In Proceedings of the ACM Conference on Computer and Communications Security (CCS\u201912). ACM, 881--893.  |Mozilla Labs Zaphod 2010. Mozilla Labs: Zaphod add-on for the Firefox browser. Retrieved October 2010 from http://mozillalabs.com/zaphod.|Andrew C. Myers. 1999. JFlow: Practical mostly-static information flow control. In Proceedings of the Symposium on Principles of Programming Languages.  |Andrew C. Myers, Andrei Sabelfeld, and Steve Zdancewic. 2004. Enforcing robust declassification. In Proceedings of the IEEE Computer Security Foundations Workshop. 172--186.  |Fran\u00e7ois Pottier and Vincent Simonet. 2003. Information flow inference for ML. Trans. Program. Lang. Syst. 25, 1 (2003), 117--158.  |Willard Rafnsson and Andrei Sabelfeld. 2011. Limiting information leakage in event-based communication. In Proceedings of the ACM SIGPLAN 4th Workshop on Programming Languages and Analysis for Security (PLAS\u201911). ACM.  |Willard Rafnsson and Andrei Sabelfeld. 2013. Secure multi-execution: Fine-grained, declassification-aware, and transparent. In Proceedings of the IEEE Computer Security Foundations Symposium. IEEE Computer Society.  |V. Rajani, A. Bichhawat, D. Garg, and C. Hammer. 2015. Information flow control for event handling and the DOM in web browsers. In Proceedings of the 2015 IEEE 28th Computer Security Foundations Symposium (CSF\u201915). 366--379.  |Martin Rinard, Cristian Cadar, Daniel Dumitran, Daniel M. Roy, Tudor Leu, and William S. Beebee. 2004. Enhancing server availability and security through failure-oblivious computing. In Proceedings of the Symposium on Operating Systems Design and Implementation (OSDI\u201904). 303--316. |Alejandro Russo and Andrei Sabelfeld. 2009. Securing timeout instructions in web applications. In Proceedings of the IEEE Computer Security Foundations Symposium.  |Alejandro Russo and Andrei Sabelfeld. 2010. Dynamic vs. static flow-sensitive security analysis. In Proceedings of the IEEE Computer Security Foundations Symposium. IEEE Computer Society.  |Alejandro Russo, Andrei Sabelfeld, and Andrey Chudnov. 2009. Tracking information flow in dynamic tree structures. In Proceedings of the European Symposium on Research in Computer Security (ESORICS\u201909). 86--103.  |Andrei Sabelfeld and Andrew C. Myers. 2003. Language-based information-flow security. J. Select. Areas Commun. 21, 1 (2003), 5--19.  |Paritosh Shroff, Scott F. Smith, and Mark Thober. 2007. Dynamic dependency monitoring to secure information flow. In Proceedings of the Computer Security Foundations Symposium.  |Deian Stefan, Alejandro Russo, John C. Mitchell, and David Mazi\u00e8res. 2011. Flexible dynamic information flow control in Haskell. In Proceedings of the 4th ACM Symposium on Haskell (Haskell\u201911). ACM, New York, NY, 95--106.  |M. Vanhoef, W. De Groef, D. Devriese, F. Piessens, and T. Rezk. 2014. Stateful declassification policies for event-driven programs. In Proceedings of the 2014 IEEE 27th Computer Security Foundations Symposium (CSF\u201914). 293--307.  |Jeffrey Vaughan and Stephen Chong. 2011. Inference of expressive declassification policies. In Proceedings of IEEE Security and Privacy.  |Philipp Vogt, Florian Nentwich, Nenad Jovanovic, Engin Kirda, Christopher Kr\u00fcgel, and Giovanni Vigna. 2007. Cross-site scripting prevention with dynamic data tainting and static analysis.|Dennis Volpano, Cynthia Irvine, and Geoffrey Smith. 1996. A sound type system for secure flow analysis. J. Comput. Secur. 4, 2--3 (1996), 167--187. |Webkit.org. 2011. SunSpider JavaScript Benchmark. Retrieved October 2011 from http://www.webkit.org/perf/sunspider/sunspider.html.|Jean Yang, Kuat Yessenov, and Armando Solar-Lezama. 2012. A language for automatically enforcing privacy policies, See Field and Hicks {2012}, 85--96.  |Alexander Yip, Xi Wang, Nickolai Zeldovich, and M. Frans Kaashoek. 2009. Improving application security with data flow assertions. In Proceedings of the Symposium on Operating Systems Principles (SOSP\u201909), Jeanna Neefe Matthews and Thomas E. Anderson (Eds.). ACM, 291--304.  |Dante Zanarini, Mauro Jaskelioff, and Alejandro Russo. 2013. Precise enforcement of confidentiality for reactive systems. In Proceedings of the Computer Security Foundations Symposium.  |Steve Zdancewic. 2003. A type system for robust declassification. In Proceedings of the 19th Mathematical Foundations of Programming Semantics Conference.  |Stephan Arthur Zdancewic. 2002. Programming Languages for Information Security. Ph.D. Dissertation. Cornell University.|", "organization": "San Jos\u00e9 State University, San Jose, CA|University of California, Santa Cruz, CA|University of California, Santa Cruz, CA|San Jos\u00e9 State University, San Jose, CA|University of California, Santa Cruz, CA|University of California, Santa Cruz, CA|", "title": ["Multiple Facets for Dynamic Information Flow with Exceptions"]},
{"abstract": "We provide a parametric framework for verifying safety properties of concurrent heap-manipulating programs. The framework combines thread-scheduling information with information about the shape of the heap. This leads to verification algorithms that are more precise than existing techniques. The framework also provides a precise shape-analysis algorithm for concurrent programs. In contrast to most existing verification techniques, we do not put a bound on the number of allocated objects. The framework produces interesting results even when analyzing programs with an unbounded number of threads. The framework is applied to successfully verify the following properties of a concurrent program:\n\u2014Concurrent manipulation of linked-list based ADT preserves the ADT datatype invariant.\n\u2014The program does not perform inconsistent updates due to interference.\n\u2014The program does not reach a deadlock.\n\u2014The program does not produce runtime errors due to illegal thread interactions.\nWe also found bugs in erroneous programs violating such properties. A prototype of our framework has been implemented and applied to small, but interesting, example programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Eran Yahav|Mooly Sagiv|Eran Yahav|Mooly Sagiv|", "references": "", "organization": "IBM T. J. Watson Research Center, Hawthorne, NY|Tel-Aviv University, Tel-Aviv, Israel|IBM T. J. Watson Research Center, Hawthorne, NY|Tel-Aviv University, Tel-Aviv, Israel|", "title": ["Verifying safety properties of concurrent heap-manipulating programs"]},
{"abstract": "In this article we present Jedd, a language extension to Java that supports a convenient way of programming with Binary Decision Diagrams (BDDs). The Jedd language abstracts BDDs as database-style relations and operations on relations, and provides static type rules to ensure that relational operations are used correctly.\nThe article provides a description of the Jedd language and reports on the design and implementation of the Jedd translator and associated runtime system. Of particular interest is the approach to assigning attributes from the high-level relations to physical domains in the underlying BDDs, which is done by expressing the constraints as a SAT problem and using a modern SAT solver to compute the solution. Further, a runtime system is defined that handles memory management issues and supports a browsable profiling tool for tuning the key BDD operations.\nThe motivation for designing Jedd was to support the development of interrelated whole program analyses based on BDDs. We have successfully used Jedd to build Paddle, a framework of context-sensitive program analyses, including points-to analysis and call graph construction, as well as several client analyses.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Ond\u0159ej Lhot\u00e1k|Laurie Hendren|Ond\u0159ej Lhot\u00e1k|Laurie Hendren|", "references": "", "organization": "University of Waterloo, Waterloo, ON, Canada|McGill University, Montreal, QC, Canada|University of Waterloo, Waterloo, ON, Canada|McGill University, Montreal, QC, Canada|", "title": ["Relations as an abstraction for BDD-based program analysis"]},
{"abstract": "Java Virtual Machines (JVMs) traditionally perform bytecode verification by way of an iterative dataflow analysis. Bytecode verification is necessary to ensure type safety because temporary variables in the JVM are not statically typed. We present an alternative verification mechanism that transforms JVM bytecode into Static Single Assignment Form (SSA) and thereby propagates definitions directly to uses. Type checking at control flow merge points can then be performed in a single pass.\nOur prototype implementation of the new algorithm is faster than the standard JVM bytecode verifier. It has the additional benefit of generating SSA as a side effect, which may be immediately useful for a subsequent dynamic compilation stage.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Andreas Gal|Christian W. Probst|Michael Franz|Andreas Gal|Christian W. Probst|Michael Franz|", "references": "", "organization": "University of California, Irvine|Technical University of Denmark, Kongens Lyngby|University of California, Irvine|University of California, Irvine|Technical University of Denmark, Kongens Lyngby|University of California, Irvine|", "title": ["Java bytecode verification via static single assignment form"]},
{"abstract": "The goal of \n (FOP) is to modularize software systems in terms of features. A \n refines the content of a base program. Both base programs and features may contain various kinds of software artifacts, for example, source code in different languages, models, build scripts, and documentation. We and others have noticed that when composing features, different kinds of software artifacts can be refined in a uniform way, regardless of what they represent. We present gDeep, a core calculus for feature composition, which captures the language independence of FOP; it can be used to compose features containing many different kinds of artifact in a type-safe way. The calculus allows us to gain insight into the principles of FOP and to define general algorithms for feature composition and validation. We provide the formal syntax, operational semantics, and type system of gDeep and outline how languages like Java, Haskell, Bali, and XML can be plugged in.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sven Apel|Delesley Hutchins|Sven Apel|Delesley Hutchins|", "references": "", "organization": "University of Passau, Passau, Germany|MZA Associates Corporation, Albuquerque, NM|University of Passau, Passau, Germany|MZA Associates Corporation, Albuquerque, NM|", "title": ["A calculus for uniform feature composition"]},
{"abstract": "Malware detection is a crucial aspect of software security. Current malware detectors work by checking for \n, which attempt to capture the syntactic characteristics of the machine-level byte sequence of the malware. This reliance on a syntactic approach makes current detectors vulnerable to code obfuscations, increasingly used by malware writers, that alter the syntactic properties of the malware byte sequence without significantly affecting their execution behavior.\nThis paper takes the position that the key to malware identification lies in their semantics. It proposes a semantics-based framework for reasoning about malware detectors and proving properties such as soundness and completeness of these detectors. Our approach uses a trace semantics to characterize the behavior of malware as well as that of the program being checked for infection, and uses abstract interpretation to \u201chide\u201d irrelevant aspects of these behaviors. As a concrete application of our approach, we show that (1) standard signature matching detection schemes are generally sound but not complete, (2) the semantics-aware malware detector proposed by Christodorescu et al. is complete with respect to a number of common obfuscations used by malware writers and (3) the malware detection scheme proposed by Kinder et al. and based on standard model-checking techniques is sound in general and complete on some, but not all, obfuscations handled by the semantics-aware malware detector.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mila Dalla Preda|Mihai Christodorescu|Somesh Jha|Saumya Debray|Mila Dalla Preda|Mihai Christodorescu|Somesh Jha|Saumya Debray|", "references": "", "organization": "University of Verona|University of Wisconsin, Madison|University of Wisconsin, Madison|University of Arizona, Tucson|University of Verona|University of Wisconsin, Madison|University of Wisconsin, Madison|University of Arizona, Tucson|", "title": ["A semantics-based approach to malware detection"]},
{"abstract": "Prior to their deployment on an embedded system, operating systems are commonly tailored to reduce code size and improve runtime performance. Program specialization is a promising match for this process: it is predictable and modules, and it allows the reuse of previously implemented specializations. A specialization engine for embedded systems must overcome three main obstacles: (i) Reusing existing compilers for embedded systems, (ii) supporting specialization on a resource-limited system and (iii) coping with dynamic applications by supporting specialization on demand.\nIn this article, we describe a runtime specialization infrastructure that addresses these problems. Our solution proposes: (i) Specialization in two phases of which the former generates specialized C templates and the latter uses a dedicated compiler to generate efficient native code. (ii) A virtualization mechanism that facilitates specialization of code at a remote location. (iii) An API and supporting OS extensions that allow applications to produce, manage and dispose of specialized code.\nWe evaluate our work through two case studies: (i) The TCP/IP implementation of Linux and (ii) The TUX embedded web server. We report appreciable improvements in code size and performance. We also quantify the overhead of specialization and argue that a specialization server can scale to support a sizable workload.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sapan Bhatia|Charles Consel|Calton Pu|Sapan Bhatia|Charles Consel|Calton Pu|", "references": "", "organization": "Princeton University|LaBRI/INRIA|Georgia Institute of Technology|Princeton University|LaBRI/INRIA|Georgia Institute of Technology|", "title": ["Remote specialization for efficient embedded operating systems"]},
{"abstract": "We present a programming language, model, and logic appropriate for implementing and reasoning about a memory management system. We state semantically what is meant by correctness of a copying garbage collector, and employ a variant of the novel separation logics to formally specify partial correctness of Cheney's copying garbage collector in our program logic. Finally, we prove that our implementation of Cheney's algorithm meets its specification using the logic we have given and auxiliary variables.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Noah Torp-Smith|Lars Birkedal|John C. Reynolds|Noah Torp-Smith|Lars Birkedal|John C. Reynolds|", "references": "", "organization": "IT University of Copenhagen|IT University of Copenhagen|Carnegie Mellon University|IT University of Copenhagen|IT University of Copenhagen|Carnegie Mellon University|", "title": ["Local reasoning about a copying garbage collector"]},
{"abstract": "This article presents a static system for checking determinism (technically, partial confluence) of communicating concurrent processes. Our approach automatically detects partial confluence in programs communicating via a mix of different kinds of communication methods: rendezvous channels, buffered channels, broadcast channels, and reference cells. Our system reduces the partial confluence checking problem in polynomial time (in the size of the program) to the problem of solving a system of rational linear inequalities, and is thus efficient.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tachio Terauchi|Alex Aiken|Tachio Terauchi|Alex Aiken|", "references": "", "organization": "Tohoku University|Stanford University|Tohoku University|Stanford University|", "title": ["A capability calculus for concurrency and determinism"]},
{"abstract": "In this article, we propose a \n framework for designing static analysers based on \n. For this purpose, we identify a fragment of second-order logic with restricted quantification that is expressive enough to model numerous static analysis problems (e.g., safety proving, bug finding, termination and non-termination proving, refactoring). As our focus is on programs that use bit-vectors, we build a decision procedure for this fragment over finite domains in the form of a program synthesiser. We\u00a0provide instantiations of our framework for solving a diverse range of program verification tasks such as termination, non-termination, safety and bug finding, superoptimisation, and refactoring. Our experimental results show that our program synthesiser compares positively with specialised tools in each area as well as with general-purpose synthesisers.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Cristina David|Pascal Kesseli|Daniel Kroening|Matt Lewis|Cristina David|Pascal Kesseli|Daniel Kroening|Matt Lewis|", "references": "", "organization": "University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|University of Oxford, UK|", "title": ["Program Synthesis for Program Analysis"]},
{"abstract": "Nominal logic is an extension of first-order logic which provides a simple foundation for formalizing and reasoning about abstract syntax modulo consistent renaming of bound names (that is, \u03b1-equivalence). This article investigates logic programming based on nominal logic. We describe some typical nominal logic programs, and develop the model-theoretic, proof-theoretic, and operational semantics of such programs. Besides being of interest for ensuring the correct behavior of implementations, these results provide a rigorous foundation for techniques for analysis and reasoning about nominal logic programs, as we illustrate via examples.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "James Cheney|Christian Urban|James Cheney|Christian Urban|", "references": "", "organization": "University of Edinburgh, Edinburgh, Scotland|Technische Universit\u00e4t, M\u00fcnchen|University of Edinburgh, Edinburgh, Scotland|Technische Universit\u00e4t, M\u00fcnchen|", "title": ["Nominal logic programming"]},
{"abstract": "This article investigates register allocation for software pipelined multidimensional loops where the execution of successive iterations from an \n-dimensional loop is overlapped. For single loop software pipelining, the lifetimes of a loop variable in successive iterations of the loop form a repetitive pattern. An effective register allocation method is to represent the pattern as a vector of lifetimes (or a vector lifetime using Rau's terminology [Rau 1992]) and map it to rotating registers. Unfortunately, the software pipelined schedule of a multidimensional loop is considerably more complex and so are the vector lifetimes in it.\nIn this article, we develop a way to normalize and represent the vector lifetimes, which captures their complexity, while exposing their regularity that enables a simple solution. The problem is formulated as bin-packing of the multidimensional vector lifetimes on the surface of a space-time cylinder. A metric, called distance, is calculated either conservatively or aggressively to guide the bin-packing process, so that there is no overlapping between any two vector lifetimes, and the register requirement is minimized. This approach subsumes the classical register allocation for software pipelined single loops as a special case. The method has been implemented in the ORC compiler and produced code for the IA-64 architecture. Experimental results show the effectiveness. Several strategies for register allocation are compared and analyzed.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Hongbo Rong|Alban Douillet|Guang R. Gao|Hongbo Rong|Alban Douillet|Guang R. Gao|", "references": "", "organization": "Microsoft Corporation, Redmond, WA|Hewlett-Packard Co., Palo Alto, CA|University of Delaware, Newark, DE|Microsoft Corporation, Redmond, WA|Hewlett-Packard Co., Palo Alto, CA|University of Delaware, Newark, DE|", "title": ["Register allocation for software pipelined multidimensional loops"]},
{"abstract": "Domain specific languages (DSLs) are mini-languages that are increasingly seen as being a valuable tool for software developers and non-developers alike. DSLs must currently be created in an ad-hoc fashion, often leading to high development costs and implementations of variable quality. In this article, I show how expressive DSLs can be hygienically embedded in the Converge programming language using its compile-time meta-programming facility, the concept of DSL blocks, and specialised error reporting techniques. By making use of pre-existing facilities, and following a simple methodology, DSL implementation costs can be significantly reduced whilst leading to higher quality DSL implementations.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Laurence Tratt|Laurence Tratt|", "references": "", "organization": "Bournemouth University, Dorset, United Kingdom|Bournemouth University, Dorset, United Kingdom|", "title": ["Domain specific language implementation via compile-time meta-programming"]},
{"abstract": "Nondeterminacy is a fundamental notion in computing. We show that it can be described by a general theory that accounts for it in the form in which it occurs in many programming contexts, among them specifications, competing agents, data refinement, abstract interpretation, imperative programming, process algebras, and recursion theory. Underpinning these applications is a theory of nondeterministic functions; we construct such a theory. The theory consists of an algebra with which practitioners can reason about nondeterministic functions, and a denotational model to establish the soundness of the theory. The model is based on the idea of free completely distributive lattices over partially ordered sets. We deduce the important properties of nondeterministic functions.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Joseph M. Morris|Malcolm Tyrrell|Joseph M. Morris|Malcolm Tyrrell|", "references": "", "organization": "Dublin City University, Ireland and Lero - the Irish Software Engineering Research Centre, Dublin, Ireland |Dublin City University, Ireland and Lero - the Irish Software Engineering Research Centre, Dublin, Ireland |Dublin City University, Ireland and Lero - the Irish Software Engineering Research Centre, Dublin, Ireland |Dublin City University, Ireland and Lero - the Irish Software Engineering Research Centre, Dublin, Ireland |", "title": ["Dually nondeterministic functions"]},
{"abstract": "Object layout schemes used in C++ and other languages rely on (sometimes numerous) compiler generated fields. We describe a language-independent object layout scheme, which is space optimal, that is, objects are contiguous, and contain \n other than a single type identifier. As in C++ and other multiple inheritance languages such as CECIL and DYLAN, the new scheme sometimes requires extra levels of indirection to access some of the fields. Using a data set of 28 hierarchies, totaling almost 50,000 types, we show that this scheme improves field access efficiency over standard implementations, and competes favorably with (the non-space-optimal) highly optimized C++ specific implementations. The benchmark includes an analytical model for computing the frequency of indirections in a sequence of field access operations. Our layout scheme relies on whole-program analysis, which requires about 10 microseconds per type on a contemporary architecture (Pentium III, 900Mhz, 256MB machine), even in very large hierarchies. We also present a layout scheme for separate compilation using the user-annotation of \n that is used in C++.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Joseph (Yossi) Gil|William Pugh|Grant E. Weddell|Yoav Zibin|Joseph (Yossi) Gil|William Pugh|Grant E. Weddell|Yoav Zibin|", "references": "", "organization": "Technion\u2014Israel Institute of Technology|Dept. of Computer Science, University of Maryland, College Park|University of Waterloo|Technion\u2014Israel Institute of Technology|Technion\u2014Israel Institute of Technology|Dept. of Computer Science, University of Maryland, College Park|University of Waterloo|Technion\u2014Israel Institute of Technology|", "title": ["Two-dimensional bidirectional object layout"]},
{"abstract": "WS-SecurityPolicy is a declarative language for configuring web services security mechanisms. We describe a formal semantics for WS-SecurityPolicy and propose a more abstract language for specifying secure links between web services and their clients. We present the architecture and implementation of tools that (1) compile policy files from link specifications, and (2) verify by invoking a theorem prover whether a set of policy files run by any number of senders and receivers correctly implements the goals of a link specification, in spite of active attackers. Policy-driven web services implementations are prone to the usual subtle vulnerabilities associated with cryptographic protocols; our tools help prevent such vulnerabilities. We can verify policies when first compiled from link specifications, and also re-verify policies against their original goals after any modifications during deployment. Moreover, we present general security theorems for all configurations that rely on compiled policies.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|Karthikeyan Bhargavan|C\u00e9dric Fournet|Andrew D. Gordon|", "references": "", "organization": "Microsoft Research, Cambridge, United Kingdom|Microsoft Research, Cambridge, United Kingdom|Microsoft Research, Cambridge, United Kingdom|Microsoft Research, Cambridge, United Kingdom|Microsoft Research, Cambridge, United Kingdom|Microsoft Research, Cambridge, United Kingdom|", "title": ["Verifying policy-based web services security"]},
{"abstract": "This article defines AspectML, a typed functional, aspect-oriented programming language. The main contribution of AspectML is the seamless integration of polymorphism, run-time type analysis and aspect-oriented programming language features. In particular, AspectML allows programmers to define type-safe polymorphic advice using pointcuts constructed from a collection of polymorphic join points. AspectML also comes equipped with a type inference algorithm that conservatively extends Hindley--Milner type inference. To support first-class polymorphic point-cut designators, a crucial feature for developing aspect-oriented profiling or logging libraries, the algorithm blends the conventional Hindley--Milner type inference algorithm with a simple form of local type inference.\nWe give our language operational meaning via a type-directed translation into an expressive type-safe intermediate language. Many complexities of the source language are eliminated in this translation, leading to a modular specification of its semantics. One of the novelties of the intermediate language is the definition of polymorphic labels for marking control-flow points. When a set of labels is assembled as a pointcut, the type of each label is an instance of the type of the pointcut.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Daniel S. Dantas|David Walker|Geoffrey Washburn|Stephanie Weirich|Daniel S. Dantas|David Walker|Geoffrey Washburn|Stephanie Weirich|", "references": "", "organization": "Princeton University, Princeton, NJ|Princeton University, Princeton, NJ|University of Pennsylvania, Philadelphia, PA|University of Pennsylvania, Philadelphia, PA|Princeton University, Princeton, NJ|Princeton University, Princeton, NJ|University of Pennsylvania, Philadelphia, PA|University of Pennsylvania, Philadelphia, PA|", "title": ["AspectML: A polymorphic aspect-oriented functional programming language"]},
{"abstract": "This article considers an algorithmic problem related to the termination analysis of programs. More specifically, we are given bounds on differences in sizes of data values before and after every transition in the program's control-flow graph. Our goal is to infer program termination via the following reasoning (\u201cthe size-change principle\u201d): if in any infinite (hypothetic) execution of the program, some size must descend unboundedly, the program must always terminate, since infinite descent of a natural number is impossible.\nThe problem of inferring termination from such abstract information is not the halting problem for programs and may well be decidable. If this is the case, the decision algorithm forms a \u201cback end\u201d of a termination verifier, and it is interesting to find out the computational complexity of the problem.\nA restriction of the problem described above, which only uses monotonicity information (but not difference bounds), is already known to be decidable. We prove that the unrestricted problem is undecidable, which gives a theoretical argument for studying restricted cases. We consider a case where the termination proof is allowed to make use of at most one bound per target variable in each transition. For this special case, which we claim is practically significant, we give (for the first time) an algorithm and show that the problem is in PSPACE, in fact that it is PSPACE-complete. The algorithm is based on combinatorial arguments and results from the theory of integer programming not previously used for similar problems.\nThe algorithm has interesting connections to other work in termination, in particular to methods for generating linear ranking functions or invariants.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Amir M. Ben-Amram|Amir M. Ben-Amram|", "references": "", "organization": "The Academic College Tel-Aviv Yaffo, Tel Aviv, Israel|The Academic College Tel-Aviv Yaffo, Tel Aviv, Israel|", "title": ["Size-change termination with difference constraints"]},
{"abstract": "We present a new approach to the old problem of adding global mutable state to purely functional languages. Our idea is to extend the language with \u201cwitnesses,\u201d which is based on an arguably more pragmatic motivation than past approaches. We give a semantic condition for correctness and prove it is sufficient. We also give a somewhat surprising static checking algorithm that makes use of a network flow property equivalent to the semantic condition via reduction to a satisfaction problem for a system of linear inequalities.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tachio Terauchi|Alex Aiken|Tachio Terauchi|Alex Aiken|", "references": "", "organization": "Tohoku University, Sendai, Japan|Stanford University, Stanford, CA|Tohoku University, Sendai, Japan|Stanford University, Stanford, CA|", "title": ["Witnessing side effects"]},
{"abstract": "We introduce the notion of a \n-flow-sensitive analysis based on the number of read and write operations that are guaranteed to be analyzed in a sequential manner. We study the complexity of partially-flow-sensitive alias analysis and show that precise alias analysis with a very limited flow-sensitivity is as hard as precise flow-sensitive alias analysis, both when dynamic memory allocation is allowed, as well as in the absence of dynamic memory allocation.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "N. Rinetzky|G. Ramalingam|M. Sagiv|E. Yahav|N. Rinetzky|G. Ramalingam|M. Sagiv|E. Yahav|", "references": "", "organization": "Tel Aviv University, Tel Aviv, Israel|Microsoft Research India, Bangalore, India|Tel Aviv University, Tel Aviv, Israel|IBM T. J. Watson Research Center, Yorktown Heights, NY|Tel Aviv University, Tel Aviv, Israel|Microsoft Research India, Bangalore, India|Tel Aviv University, Tel Aviv, Israel|IBM T. J. Watson Research Center, Yorktown Heights, NY|", "title": ["On the complexity of partially-flow-sensitive alias analysis"]},
{"abstract": "Compile-time optimizations generally improve program performance. Nevertheless, degradations caused by individual compiler optimization techniques are to be expected. Feedback-directed \n systems generate optimized code versions under a series of optimization combinations, evaluate their performance, and search for the best version. One challenge to such systems is to tune program performance quickly in an exponential search space. Another challenge is to achieve high program performance, considering that optimizations interact. Aiming at these two goals, this article presents an automated performance tuning system, \n, which searches for the best compiler optimization combinations for the important code sections in a program. The major contributions made in this work are as follows: (1) An algorithm called \n is developed to explore the optimization space quickly and effectively; (2) Three fast and accurate rating methods are designed to evaluate the performance of an optimized code section based on a partial execution of the program; (3) An algorithm is developed to identify important code sections as candidates for performance tuning by trading off tuning speed and tuned program performance; and (4) A set of compiler tools are implemented to automate optimization orchestration. Orchestrating optimization options in SUN Forte compilers at the whole-program level, our CE algorithm improves performance by 10.8% over the SPEC CPU2000 FP baseline setting, compared to 5.6% improved by manual tuning. Orchestrating GCC O3 optimizations, CE improves performance by 12% over O3, the highest optimization level. Applying the rating methods, PEAK reduces tuning time from 2.19 hours to 5.85 minutes on average, while achieving equal or better program performance.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Zhelong Pan|Rudolf Eigenmann|Zhelong Pan|Rudolf Eigenmann|", "references": "", "organization": "Purdue University, West Lafayette, IN|Purdue University, West Lafayette, IN|Purdue University, West Lafayette, IN|Purdue University, West Lafayette, IN|", "title": ["PEAK\u2014a fast and effective performance tuning system via compiler optimization orchestration"]},
{"abstract": "Subtype tests are an important issue in the implementation of object-oriented programming languages. Many techniques have been proposed, but none of them perfectly fulfills the five requirements that we have identified: constant-time, linear-space, multiple inheritance, dynamic loading and inlining. In this article, we propose a subtyping test implementation that involves a combination of usual hashtables and Cohen's display, which is a well-known technique for single inheritance hierarchies. This novel approach is based on \n, that is, an optimized and truly constant-time variant of hashing that applies to \n hashtables. We show that the resulting technique closely meets all five requirements. Furthermore, in the framework of Java-like languages\u2014characterized by single inheritance of classes and multiple subtyping of interfaces\u2014perfect hashing also applies to method invocation when the receiver is typed by an interface. The proposed technique is compared to some alternatives, including the proposal by Palacz and Vitek [2003]. Time-efficiency is assessed at the cycle level in the framework of Driesen's pseudo-code and the linear-space criterion is validated by statistical simulation on benchmarks consisting of large-scale class hierarchies.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Roland Ducournau|Roland Ducournau|", "references": "", "organization": "LIRMM--CNRS and Universit\u00e9 Montpellier II, France|LIRMM--CNRS and Universit\u00e9 Montpellier II, France|", "title": ["Perfect hashing as an almost perfect subtype test"]},
{"abstract": "This article considers some known abstract domains for affine-relation analysis (ARA), along with several variants, and studies how they relate to each other. The various domains represent sets of points that satisfy affine relations over variables that hold machine integers and are based on an extension of linear algebra to modules over a ring (in particular, arithmetic performed modulo 2\n, for some machine-integer width \n).\nWe show that the abstract domains of M\u00fcller-Olm/Seidl (MOS) and King/S\u00f8ndergaard (KS) are, in general, incomparable. However, we give sound interconversion methods. In other words, we give an algorithm to convert a KS element \n to an overapproximating MOS element \n\u2014that is, \u03b3 (\n) \u2286 \u03b3 (\n\u2014as well as an algorithm to convert an MOS element \n to an overapproximating KS element \n\u2014that is, \u03b3 (\n) \u2286 \u03b3 (\n).\nThe article provides insight on the range of options that one has for performing ARA in a program analyzer:\n\u2014We describe how to perform a greedy, operator-by-operator abstraction method to obtain KS abstract transformers.\n\u2014We also describe a more global approach to obtaining KS abstract transformers that considers the semantics of an entire instruction, basic block, or other loop-free program fragment.\nThe latter method can yield best abstract transformers, and hence can be more precise than the former method. However, the latter method is more expensive.\nWe also explain how to use the KS domain for interprocedural program analysis using a bit-precise concrete semantics, but without bit blasting.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Matt Elder|Junghee Lim|Tushar Sharma|Tycho Andersen|Thomas Reps|Matt Elder|Junghee Lim|Tushar Sharma|Tycho Andersen|Thomas Reps|", "references": "", "organization": "University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin and GrammaTech, Inc., Madison, WI|University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin, Madison, USA|University of Wisconsin and GrammaTech, Inc., Madison, WI|", "title": ["Abstract Domains of Affine Relations"]},
{"abstract": "Abstract mathematical representations such as integer polyhedra have been shown to be useful to precisely analyze computational kernels and to express complex loop transformations. Such transformations rely on abstract syntax tree (AST) generators to convert the mathematical representation back to an imperative program. Such generic AST generators avoid the need to resort to transformation-specific code generators, which may be very costly or technically difficult to develop as transformations become more complex. Existing AST generators have proven their effectiveness, but they hit limitations in more complex scenarios. Specifically, (1) they do not support or may fail to generate control flow for complex transformations using piecewise schedules or mappings involving modulo arithmetic; (2) they offer limited support for the specialization of the generated code exposing compact, straightline, vectorizable kernels with high arithmetic intensity necessary to exploit the peak performance of modern hardware; (3) they offer no support for memory layout transformations; and (4) they provide insufficient control over the AST generation strategy, preventing their application to complex domain-specific optimizations.\nWe present a new AST generation approach that extends classical polyhedral scanning to the full generality of Presburger arithmetic, including existentially quantified variables and piecewise schedules, and introduce new optimizations for the detection of components and shifted strides. Not limiting ourselves to control flow generation, we expose functionality to generate AST expressions from arbitrary piecewise quasi-affine expressions, which enables the use of our AST generator for data-layout transformations. We complement this with support for specialization by polyhedral unrolling, user-directed versioning, and specialization of AST expressions according to the location at which they are generated, and we complete this work with fine-grained user control over the AST generation strategies used. Using this generalized idea of AST generation, we present how to implement complex domain-specific transformations without the need to write specialized code generators, but instead relying on a generic AST generator parametrized to a specific problem domain.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Tobias Grosser|Sven Verdoolaege|Albert Cohen|Tobias Grosser|Sven Verdoolaege|Albert Cohen|", "references": "", "organization": "INRIA and \u00c9COLE NORMALE SUP\u00c9RIEURE, Paris, France|INRIA, \u00c9COLE NORMALE SUP\u00c9RIEURE and KU Leuven, Paris, France|INRIA and \u00c9COLE NORMALE SUP\u00c9RIEURE, Paris, France|INRIA and \u00c9COLE NORMALE SUP\u00c9RIEURE, Paris, France|INRIA, \u00c9COLE NORMALE SUP\u00c9RIEURE and KU Leuven, Paris, France|INRIA and \u00c9COLE NORMALE SUP\u00c9RIEURE, Paris, France|", "title": ["Polyhedral AST Generation Is More Than Scanning Polyhedra"]},
{"abstract": "Although register allocation is critical for performance, the implementation of register allocation algorithms is difficult, due to the complexity of the algorithms and target machine architectures. It is particularly difficult to detect register allocation errors if the output code runs to completion, as bugs in the register allocator can cause the compiler to produce incorrect output code. The output code may even execute properly on some test data, but errors can remain. In this article, we propose novel data flow analyses to statically check that the value flow of the output code from the register allocator is the same as the value flow of its input code. The approach is accurate, fast, and can identify and report error locations and types. It is independent of the register allocator and uses only the input and output code of the register allocator. It can be used with different register allocators, including those that perform coalescing and rematerialization. The article describes our approach, called SARAC, and a tool that statically checks a register allocation and reports the errors and their types that it finds. The tool has an average compile-time overhead of only 8% and a modest average memory overhead of 85KB. Our techniques can be used by compiler developers during regression testing and as a command-line-enabled debugging pass for mysterious compiler behavior.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Yuqiang Huang|Bruce R. Childers|Mary Lou Soffa|Yuqiang Huang|Bruce R. Childers|Mary Lou Soffa|", "references": "", "organization": "University of Pittsburgh, Pittsburgh, PA|University of Pittsburgh, Pittsburgh, PA|University of Virginia, Charlottesville, VA|University of Pittsburgh, Pittsburgh, PA|University of Pittsburgh, Pittsburgh, PA|University of Virginia, Charlottesville, VA|", "title": ["Detecting bugs in register allocation"]},
{"abstract": "Type systems and model checking are two prevalent approaches to program verification. A prominent difference between them is that type systems are typically defined in a syntactic and modular style whereas model checking is usually performed in a semantic and whole-program style. This difference between the two approaches makes them complementary to each other: type systems are good at explaining why a program was accepted while model checkers are good at explaining why a program was rejected.\nWe present a type system that is equivalent to a model checker for verifying temporal safety properties of imperative programs. The model checker is natural and may be instantiated with any finite-state abstraction scheme such as predicate abstraction. The type system, which is also parametric, type checks exactly those programs that are accepted by the model checker. It uses a variant of function types to capture flow sensitivity and intersection and union types to capture context sensitivity. Our result sheds light on the relationship between type systems and model checking, provides a methodology for studying their relative expressiveness, is a step towards sharing results between the two approaches, and motivates synergistic program analyses involving interplay between them.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mayur Naik|Jens Palsberg|Mayur Naik|Jens Palsberg|", "references": "", "organization": "Intel Research, Berkeley, CA|UCLA, Los Angeles, CA|Intel Research, Berkeley, CA|UCLA, Los Angeles, CA|", "title": ["A type system equivalent to a model checker"]},
{"abstract": "The recognition of program constructs that are frequently used by software developers is a powerful mechanism for optimizing and parallelizing compilers to improve the performance of the object code. The development of techniques for automatic recognition of computational kernels such as inductions, reductions and array recurrences has been an intensive research area in the scope of compiler technology during the 90's. This article presents a new compiler framework that, unlike previous techniques that focus on specific and isolated kernels, recognizes a comprehensive collection of computational kernels that appear frequently in full-scale real applications. The XARK compiler operates on top of the Gated Single Assignment (GSA) form of a high-level intermediate representation (IR) of the source code. Recognition is carried out through a demand-driven analysis of this high-level IR at two different levels. First, the dependences between the statements that compose the strongly connected components (SCCs) of the data-dependence graph of the GSA form are analyzed. As a result of this intra-SCC analysis, the computational kernels corresponding to the execution of the statements of the SCCs are recognized. Second, the dependences between statements of different SCCs are examined in order to recognize more complex kernels that result from combining simpler kernels in the same code. Overall, the XARK compiler builds a hierarchical representation of the source code as kernels and dependence relationships between those kernels. This article describes in detail the collection of computational kernels recognized by the XARK compiler. Besides, the internals of the recognition algorithms are presented. The design of the algorithms enables to extend the recognition capabilities of XARK to cope with new kernels, and provides an advanced symbolic analysis framework to run other compiler techniques on demand. Finally, extensive experiments showing the effectiveness of XARK for a collection of benchmarks from different application domains are presented. In particular, the SparsKit-II library for the manipulation of sparse matrices, the Perfect benchmarks, the SPEC CPU2000 collection and the PLTMG package for solving elliptic partial differential equations are analyzed in detail.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Manuel Arenaz|Juan Touri\u00f1o|Ramon Doallo|Manuel Arenaz|Juan Touri\u00f1o|Ramon Doallo|", "references": "", "organization": "University of A Coru\u00f1a, Spain|University of A Coru\u00f1a, Spain|University of A Coru\u00f1a, Spain|University of A Coru\u00f1a, Spain|University of A Coru\u00f1a, Spain|University of A Coru\u00f1a, Spain|", "title": ["XARK: An extensible framework for automatic recognition of computational kernels"]},
{"abstract": "We propose an approach for the modular specification and verification of total correctness properties of object-oriented programs. The core of our approach is a \n that prescribes a way to assign a \n to each method such that each callee\u2019s level is below the caller\u2019s, even in the presence of dynamic binding. The specification style yields specifications that properly hide implementation details. The main idea is to use \n as levels, and to associate with each object levels that abstractly reflect the way the object is built from other objects. A method\u2019s level is then defined in terms of the method\u2019s own name and the levels associated with the objects passed as arguments.\nWe first present the specification style in the context of programs that do not modify object fields. We then combine it with separation logic and abstract predicate families to obtain an approach for programs with heap mutation. In a third step, we address concurrency, by incorporating an existing approach for verifying deadlock freedom of channels and locks. Our main contribution here is to achieve information hiding by using the proposed termination levels for lock ordering as well. Also, we introduce \n to enable elegant verification of termination of programs where threads cause work in other threads, such as in thread pools or fine-grained concurrent algorithms involving compare-and-swap loops.\nWe explain how our approach can be used also to verify the liveness of nonterminating programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Bart Jacobs|Dragan Bosnacki|Ruurd Kuiper|Bart Jacobs|Dragan Bosnacki|Ruurd Kuiper|", "references": "", "organization": "KU Leuven, Leuven, Belgium|Eindhoven University of Technology, The Netherlands|Eindhoven University of Technology, The Netherlands|KU Leuven, Leuven, Belgium|Eindhoven University of Technology, The Netherlands|Eindhoven University of Technology, The Netherlands|", "title": ["Modular Termination Verification of Single-Threaded and Multithreaded Programs"]},
{"abstract": "We study the problem of automatically analyzing the worst-case resource usage of procedures with several arguments. Existing automatic analyses based on amortization or sized types bound the resource usage or result size of such a procedure by a sum of unary functions of the sizes of the arguments.\nIn this article we generalize this to arbitrary multivariate polynomial functions thus allowing bounds of the form \n which had to be grossly overestimated by \n + \n before. Our framework even encompasses bounds like \u2211\n where the \n are the sizes of the entries of a list of length \n.\nThis allows us for the first time to derive useful resource bounds for operations on matrices that are represented as lists of lists and to considerably improve bounds on other superlinear operations on lists such as longest common subsequence and removal of duplicates from lists of lists. Furthermore, resource bounds are now closed under composition which improves accuracy of the analysis of composed programs when some or all of the components exhibit superlinear resource or size behavior.\nThe analysis is based on a novel multivariate amortized resource analysis. We present it in form of a type system for a simple first-order functional language with lists and trees, prove soundness, and describe automatic type inference based on linear programming.\nWe have experimentally validated the automatic analysis on a wide range of examples from functional programming with lists and trees. The obtained bounds were compared with actual resource consumption. All bounds were asymptotically tight, and the constants were close or even identical to the optimal ones.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jan Hoffmann|Klaus Aehlig|Martin Hofmann|Jan Hoffmann|Klaus Aehlig|Martin Hofmann|", "references": "", "organization": "Yale University, New Haven, CT|Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen, Germany|Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen, Germany|Yale University, New Haven, CT|Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen, Germany|Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen, Germany|", "title": ["Multivariate amortized resource analysis"]},
{"abstract": "Dynamic memory allocation is ubiquitous in today's runtime environments. Allocation and deallocation of objects during program execution may cause fragmentation and foil the program's ability to allocate objects. Robson [1971] has shown that a worst-case scenario can create a space overhead within a factor of log \n of the space that is actually required by the program, where \n is the size of the largest possible object. Compaction can eliminate fragmentation, but is too costly to be run frequently. Many runtime systems employ partial compaction, in which only a small fraction of the allocated objects are moved. Partial compaction reduces some of the existing fragmentation at an acceptable cost. In this article we study the effectiveness of partial compaction and provide the first rigorous lower and upper bounds on its effectiveness in reducing fragmentation at a low cost.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Anna Bendersky|Erez Petrank|Anna Bendersky|Erez Petrank|", "references": "", "organization": "Technion, Haifa, Israel|Technion, Haifa, Israel|Technion, Haifa, Israel|Technion, Haifa, Israel|", "title": ["Space overhead bounds for dynamic memory management with partial compaction"]},
{"abstract": "A dependence cluster is a set of program statements, all of which are mutually inter-dependent. This article reports a large scale empirical study of dependence clusters in C program source code. The study reveals that large dependence clusters are surprisingly commonplace. Most of the 45 programs studied have clusters of dependence that consume more than 10% of the whole program. Some even have clusters consuming 80% or more. The widespread existence of clusters has implications for source code analyses such as program comprehension, software maintenance, software testing, reverse engineering, reuse, and parallelization.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Mark Harman|David Binkley|Keith Gallagher|Nicolas Gold|Jens Krinke|Mark Harman|David Binkley|Keith Gallagher|Nicolas Gold|Jens Krinke|", "references": "", "organization": "King's College London, London, UK|Loyola College, Baltimore, MD|Durham University, Durham, UK|King's College London, London, UK|King's College London, London, UK|King's College London, London, UK|Loyola College, Baltimore, MD|Durham University, Durham, UK|King's College London, London, UK|King's College London, London, UK|", "title": ["Dependence clusters in source code"]},
{"abstract": "Modern architectures rely on memory fences to prevent undesired weakenings of memory consistency. As the fences\u2019 semantics may be subtle, the automation of their placement is highly desirable. But precise methods for restoring consistency do not scale to deployed systems\u2019 code. We choose to trade some precision for genuine scalability: our technique is suitable for large code bases. We implement it in our new musketeer tool and report experiments on more than 700 executables from packages found in Debian GNU/Linux 7.1, including memcached with about 10,000 LoC.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jade Alglave|Daniel Kroening|Vincent Nimal|Daniel Poetzl|Jade Alglave|Daniel Kroening|Vincent Nimal|Daniel Poetzl|", "references": "", "organization": "Microsoft Research, University College London, London, UK|University of Oxford, Parks Road, Oxford, UK|Microsoft Research, Cambridge, UK|University of Oxford, Parks Road, Oxford, UK|Microsoft Research, University College London, London, UK|University of Oxford, Parks Road, Oxford, UK|Microsoft Research, Cambridge, UK|University of Oxford, Parks Road, Oxford, UK|", "title": ["Don\u2019t Sit on the Fence: A Static Analysis Approach to Automatic Fence Insertion"]},
{"abstract": " is a runtime scheduler for task-parallel codes that effectively coarsens parallelism on load conditions in order to significantly reduce its overheads compared to existing approaches, thus enabling the efficient execution of more fine-grained tasks. Unlike other adaptive dynamic schedulers, lazy scheduling does not maintain any additional state to infer system load and does not make irrevocable serialization decisions. These two features allow it to scale well and to provide excellent load balancing in practice but at a much lower overhead cost compared to work stealing, the golden standard of dynamic schedulers. We evaluate three variants of lazy scheduling on a set of benchmarks on three different platforms and find it to substantially outperform popular work stealing implementations on fine-grained codes. Furthermore, we show that the vast performance gap between manually coarsened and fully parallel code is greatly reduced by lazy scheduling, and that, with minimal static coarsening, lazy scheduling delivers performance very close to that of fully tuned code.\nThe tedious manual coarsening required by the best existing work stealing schedulers and its damaging effect on performance portability have kept novice and general-purpose programmers from parallelizing their codes. Lazy scheduling offers the foundation for a declarative parallel programming methodology that should attract those programmers by minimizing the need for manual coarsening and by greatly enhancing the performance portability of parallel code.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Alexandros Tzannes|George C. Caragea|Uzi Vishkin|Rajeev Barua|Alexandros Tzannes|George C. Caragea|Uzi Vishkin|Rajeev Barua|", "references": "", "organization": "University of Illinois, Urbana-Champaign, Urbana, IL|University of Maryland, College Park, MD|University of Maryland, College Park, MD|University of Maryland, College Park, MD|University of Illinois, Urbana-Champaign, Urbana, IL|University of Maryland, College Park, MD|University of Maryland, College Park, MD|University of Maryland, College Park, MD|", "title": ["Lazy Scheduling: A Runtime Adaptive Scheduler for Declarative Parallelism"]},
{"abstract": "Task parallelism has increasingly become a trend with programming models such as OpenMP 3.0, Cilk, Java Concurrency, X10, Chapel and Habanero-Java (HJ) to address the requirements of multicore programmers. While task parallelism increases productivity by allowing the programmer to express multiple levels of parallelism, it can also lead to performance degradation due to increased overheads. In this article, we introduce a transformation framework for optimizing task-parallel programs with a focus on task creation and task termination operations. These operations can appear explicitly in constructs such as async, finish in X10 and HJ, task, taskwait in OpenMP 3.0, and spawn, sync in Cilk, or implicitly in composite code statements such as foreach and ateach loops in X10, forall and foreach loops in HJ, and parallel loop in OpenMP.\nOur framework includes a definition of data dependence in task-parallel programs, a happens-before analysis algorithm, and a range of program transformations for optimizing task parallelism. Broadly, our transformations cover three different but interrelated optimizations: (1) \n, (2) \n, and (3) \n. Finish-elimination removes redundant task termination operations, forall-coarsening replaces expensive task creation and termination operations with more efficient synchronization operations, and loop-chunking extracts useful parallelism from ideal parallelism. All three optimizations are specified in an iterative transformation framework that applies a sequence of relevant transformations until a fixed point is reached. Further, we discuss the impact of exception semantics on the specified transformations, and extend them to handle task-parallel programs with precise exception semantics. Experimental results were obtained for a collection of task-parallel benchmarks on three multicore platforms: a dual-socket 128-thread (16-core) Niagara T2 system, a quad-socket 16-core Intel Xeon SMP, and a quad-socket 32-core Power7 SMP. We have observed that the proposed optimizations interact with each other in a synergistic way, and result in an overall geometric average performance improvement between 6.28\u00d7 and 10.30\u00d7, measured across all three platforms for the benchmarks studied.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "V. Krishna Nandivada|Jun Shirako|Jisheng Zhao|Vivek Sarkar|V. Krishna Nandivada|Jun Shirako|Jisheng Zhao|Vivek Sarkar|", "references": "", "organization": "IIT Madras|Rice University|Rice University|Rice University|IIT Madras|Rice University|Rice University|Rice University|", "title": ["A Transformation Framework for Optimizing Task-Parallel Programs"]},
{"abstract": "Several authors have found evidence of large dependence clusters in the source code of a diverse range of systems, domains, and programming languages. This raises the question of how we might efficiently locate the fragments of code that give rise to large dependence clusters. We introduce an algorithm for the identification of \n vertices, which hold together large dependence clusters, and prove correctness properties for the algorithm\u2019s primary innovations. We also report the results of an empirical study concerning the reduction in analysis time that our algorithm yields over its predecessor using a collection of 38 programs containing almost half a million lines of code. Our empirical findings indicate improvements of almost two orders of magnitude, making it possible to process larger programs for which it would have previously been impractical.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "David Binkley|Nicolas Gold|Mark Harman|Syed Islam|Jens Krinke|Zheng Li|David Binkley|Nicolas Gold|Mark Harman|Syed Islam|Jens Krinke|Zheng Li|", "references": "", "organization": "Loyola University Maryland|University College London|University College London|University College London|University College London|Beijing University of Chemical Technology|Loyola University Maryland|University College London|University College London|University College London|University College London|Beijing University of Chemical Technology|", "title": ["Efficient Identification of Linchpin Vertices in Dependence Clusters"]},
{"abstract": "Despite the extensiveness of recent investigations on static typing for XML, parametric polymorphism has rarely been treated. This well-established typing discipline can also be useful in XML processing in particular for programs involving \u201cparametric schemas,\u201d that is, schemas parameterized over other schemas (e.g., SOAP). The difficulty in treating polymorphism for XML lies in how to extend the \u201csemantic\u201d approach used in the mainstream (monomorphic) XML type systems. A naive extension would be \u201csemantic\u201d quantification over all substitutions for type variables. However, this approach reduces to an NEXPTIME-complete problem for which no practical algorithm is known and induces a subtyping relation that may not always match the programmer's intuition. In this article, we propose a different method that smoothly extends the semantic approach yet is algorithmically easier. The key idea here is to devise a novel and simple \n technique, where we interpret a polymorphic type as a set of values with annotations of which subparts are parameterized. We exploit this interpretation in every ingredient of our polymorphic type system such as subtyping, inference of type arguments, etc. As a result, we achieve a sensible system that directly represents a usual expected behavior of polymorphic type systems\u2014\u201cvalues of abstract types are never reconstructed\u201d\u2014in a reminiscence of Reynold's parametricity theory. Also, we obtain a set of practical algorithms for typechecking by local modifications to existing ones for a monomorphic system.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Haruo Hosoya|Alain Frisch|Giuseppe Castagna|Haruo Hosoya|Alain Frisch|Giuseppe Castagna|", "references": "", "organization": "The University of Tokyo, Tokyo, Japan|LexiFi - France|PPS (CNRS) - Universit\u00e9 Denis Diderot, Paris, France|The University of Tokyo, Tokyo, Japan|LexiFi - France|PPS (CNRS) - Universit\u00e9 Denis Diderot, Paris, France|", "title": ["Parametric polymorphism for XML"]},
{"abstract": "We present an analysis which takes as its input a sequential program, augmented with annotations indicating potential parallelization opportunities, and a sequential proof, written in separation logic, and produces a correctly synchronized parallelized program and proof of that program. Unlike previous work, ours is not a simple independence analysis that admits parallelization only when threads do not interfere; rather, we insert synchronization to preserve dependencies in the sequential program that might be violated by a na\u00efve translation. Separation logic allows us to parallelize fine-grained patterns of resource usage, moving beyond straightforward points-to analysis. The sequential proof need only represent shape properties, meaning we can handle complex algorithms without verifying every aspect of their behavior.\nOur analysis works by using the sequential proof to discover dependencies between different parts of the program. It leverages these discovered dependencies to guide the insertion of synchronization primitives into the parallelized program, and to ensure that the resulting parallelized program satisfies the same specification as the original sequential program, and exhibits the same sequential behavior. Our analysis is built using frame inference and abduction, two techniques supported by an increasing number of separation logic tools.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Matko Botin\u010dan|Mike Dodds|Suresh Jagannathan|Matko Botin\u010dan|Mike Dodds|Suresh Jagannathan|", "references": "", "organization": "University of Cambridge|University of Cambridge|Purdue University|University of Cambridge|University of Cambridge|Purdue University|", "title": ["Proof-Directed Parallelization Synthesis by Separation Logic"]},
{"abstract": "We propose a general formal model of isolated hierarchical parallel computations, and identify several fragments to match the concurrency constructs present in real-world programming languages such as Cilk and X10. By associating fundamental formal models (vector addition systems with recursive transitions) to each fragment, we provide a common platform for exposing the relative difficulties of algorithmic reasoning. For each case we measure the complexity of deciding state reachability for finite-data recursive programs, and propose algorithms for the decidable cases. The complexities which include PTIME, NP, EXPSPACE, and 2EXPTIME contrast with undecidable state reachability for recursive multithreaded programs.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Ahmed Bouajjani|Michael Emmi|Ahmed Bouajjani|Michael Emmi|", "references": "", "organization": "LIAFA, Universit\u00e9 Paris Diderot|LIAFA, Universit\u00e9 Paris Diderot|LIAFA, Universit\u00e9 Paris Diderot|LIAFA, Universit\u00e9 Paris Diderot|", "title": ["Analysis of Recursively Parallel Programs"]},
{"abstract": "First-class classes enable programmers to abstract over patterns in the class hierarchy and to experiment with new forms of object-oriented programming such as mixins and traits. This increase in expressive power calls for tools to control the complexity of the software architecture. A contract system is one possible tool that has seen much use in object-oriented programming languages, but existing contract systems cannot cope with first-class classes. On the one hand, the typical contract language deals only with plain values such as numbers, while classes are higher-order values. On the other hand, contract specifications are usually contained within class definitions, while classes as values call for a separate contract language.\nThis article presents the design and implementation of a contract system for first-class classes as well as a two-pronged evaluation. The first one states and proves a \u201cblame correctness\u201d theorem for a model of our language. The theorem shows that when the contract system assigns blame to a component for a contract violation, the component is indeed responsible for providing the nonconforming value. The second part, consisting of benchmarks and case studies, demonstrates the need for the rich contract language and validates that our implementation approach is performant with respect to time.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "T. Stephen Strickland|Christos Dimoulas|Asumu Takikawa|Matthias Felleisen|T. Stephen Strickland|Christos Dimoulas|Asumu Takikawa|Matthias Felleisen|", "references": "", "organization": "Northeastern University|Northeastern University|Northeastern University|Northeastern University|Northeastern University|Northeastern University|Northeastern University|Northeastern University|", "title": ["Contracts for First-Class Classes"]},
{"abstract": "Dedicated to the memory of John C. Reynolds (1935--2013).\nWe present Relational Hoare Type Theory (RHTT), a novel language and verification system capable of expressing and verifying rich information flow and access control policies via dependent types. We show that a number of security policies which have been formalized separately in the literature can all be expressed in RHTT using only standard type-theoretic constructions such as monads, higher-order functions, abstract types, abstract predicates, and modules. Example security policies include conditional declassification, information erasure, and state-dependent information flow and access control. RHTT can reason about such policies in the presence of dynamic memory allocation, deallocation, pointer aliasing and arithmetic.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Aleksandar Nanevski|Anindya Banerjee|Deepak Garg|Aleksandar Nanevski|Anindya Banerjee|Deepak Garg|", "references": "", "organization": "IMDEA Software Institute|IMDEA Software Institute|Max Planck Institute for Software Systems|IMDEA Software Institute|IMDEA Software Institute|Max Planck Institute for Software Systems|", "title": ["Dependent Type Theory for Verification of Information Flow and Access Control Policies"]},
{"abstract": "A medical prescription is a set of health care instructions that govern the plan of care for an individual patient, which may include orders for drug therapy, diet, clinical assessment, and laboratory testing. Clinicians have long used algorithmic thinking to describe and implement prescriptions but without the benefit of a formal programming language. Instead, medical algorithms are expressed using a natural language patois, flowcharts, or as structured data in an electronic medical record system. The lack of a prescription programming language inhibits expressiveness; results in prescriptions that are difficult to understand, hard to debug, and awkward to reuse; and increases the risk of fatal medical error.\nThis article reports on the design and evaluation of Patient-Oriented Prescription Programming Language (POP-PL), a domain-specific programming language designed for expressing prescriptions. The language is based around the idea that programs and humans have complementary strengths that, when combined properly, can make for safer, more accurate performance of prescriptions. Use of POP-PL facilitates automation of certain low-level vigilance tasks, freeing up human cognition for abstract thinking, compassion, and human communication.\nWe implemented this language and evaluated its design attempting to write prescriptions in the new language and evaluated its usability by assessing whether clinicians can understand and modify prescriptions written in the language. We found that some medical prescriptions can be expressed in a formal domain-specific programming language, and we determined that medical professionals can understand and correctly modify programs written in POP-PL. We also discuss opportunities for refining and further developing POP-PL.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Spencer P. Florence|Burke Fetscher|Matthew Flatt|William H. Temps|Vincent St-Amour|Tina Kiguradze|Dennis P. West|Charlotte Niznik|Paul R. Yarnold|Robert Bruce Findler|Steven M. Belknap|Spencer P. Florence|Burke Fetscher|Matthew Flatt|William H. Temps|Vincent St-Amour|Tina Kiguradze|Dennis P. West|Charlotte Niznik|Paul R. Yarnold|Robert Bruce Findler|Steven M. Belknap|", "references": "Apple Computer, Inc. 1988. Hypercard Script Language Guide: The Hypertalk Language. Addison-Wesley. |S. M. Belknap, H. Moore, S. A. Lanzotti, P. R. Yarnold, M. Getz, D. L. Deitrick, A. Peterson, J. Akeson, T. Maurer, R. C. Soltysik, G. A. Storm, and I. Brooks. 2008. Application of software design principles and debugging methods to an analgesia prescription reduces risk of severe injury from medical use of opioids. Nature Clin. Pharmacol. Therapeut. 84, 3 (2008), 385--392.|Steven M. Belknap. 1991. The Chicago Kinetic Simulator. Math. J. 1, 4 (1991), 68--86.|A. F. Blackwell, C. Britton, A. Cox, T. R. G. Green, C. Curr, G. Kadoda, M. S. Kutar, C. L. Nehaniv, M. Petre, C. Roast, C. Roes, A. Wong, and R. M. Young. 2001. Cognitive Dimensions of Notations: Design Tools for Cognitive Technology. In Proceedings of Cognitive Technology: Instruments of Mind. |Alan F. Blackwell and Thomas R. G. Green. 2000. A cognitive dimensions questionnaire optimised for users. In Proceedings of the 12th Workshop of the Psychology of Programming Interest Group.|Frederic Boussinot and Robert De Simone. 1991. The Esterel language. In Proceedings of the Institute of Electrical and Electronics Engineers.|T. Brus, M. C. J. D. van Eekelen, M. van Leer, and M. J. Plasmeijer. 1987. CLEAN\u2014A language for functional graph rewriting. In Proceedings Conference on Functional Programming Languages and Computer Architecture (FPCA\u201987), pp. 364--384. |Chrisian J. Callsen and Gul Agha. 1994. Open heterogeneous computing in ActorSpace. J. Parallel Distrib. Comput. 21 (1994), 289--300.  |Bin Chen, George S. Avrunin, Lori A. Clarke, and Leon J. Osterweil. 2006. Automatic fault tree derivation from Little-JIL process definitions. In Proceedings of the Conference on Software Process Change (SPW\u201906).  |Carlo Combi, Mauro Gambini, Sara Migliorini, and Roberto Posenato. 2012. Modeling temporal, data-centric medical processes. In Proceedings of the SIGHIT International Health Informatics Symposium. 141--150.  |Committee on Identifying and Preventing Medication Errors. 2007. Preventing Medication Errors: Quality Chasm Series. National Academies Press.|Maria Cvach. 2012. Monitor alarm fatigue: An integrative review. Biomed. Instrum. Technol. 46, 4 (2012), 268--277.|Division of Endocrinology, Department of Medicine and Multidisciplinary ICU Committee. 2004. Guideline for Intravenous Insulin Infusion in the Adult ICU Patient. Retrieved from http://www.hospitalmedicine.org/CMDownload.aspx?ContentKey&equals;046c625a-839f-4731-beb8-5149c4c8f9788ContentItemKey&equals;262ad349-0970-45ce-89d7-37de88728c7c.|R. Filik, K. Purdy, A. Gale, and D. Gerret. 2006. Labeling of medicines and patient safety: Evaluating methods of reducing drug name confusion. Hum. Factors 48, 1 (2006), 39--47.|Matthew Flatt and PLT. 2010. Reference: Racket. PLT, TR-1. Retrieved from http://racket-lang.org/tr1/.|George W. Furnas. 2000. Future Design Mindful of the MoRAS. Hum.-Comput. Interact. 15, 2--3 (2000), 205--261.  |David M. Gaba, Mary Maxwell, and Abe DeAnda. 1987. Anesthetic mishaps: Breaking the chain of accident evolution. Anesthesiology 66, 5 (1987), 670--676.|Tony Garnock-Jones, Sam Tobin-Hochstadt, and Matthias Felleisen. 2014. The network as a language construct. In Proceedings of the European Symposium on Programming (ESOP\u201914).  |David Gerrett, Alastair G. Gale, Iain T. Darker, Ruth Filik, and Kevin J. Purdy. 2009. Tall Man Lettering: Final report of the use of tall man lettering to minimise selection errors of medicine names in computer prescribing and dispensing systems. Retrieved from http://www.connectingforhealth.nhs.uk/systemsandservices/eprescribing/refdocs/tallman.pdf.|Adele Goldberg and David Robson. 1983. Smalltalk-80: The Language and Its Implementation. Addison-Wesley Longman Publishing Co., Inc. |T. R. G. Green and M. Petre. 1996. Usability analysis of visual programming environments: A \u2018cognitive dimensions\u2019 framework. J. Vis. Lang. Comput. 7 (1996), 131--174.|T. R. G. Green and M. Petre. 1992. When Visual Programs are Harder to Read than Textual Programs. In Proceedings of the 6th European Conference on Cognitive Ergonomics, Human-Computer Interaction: Tasks and Organisation.|Thomas R. G. Green. 1989. Cognitive Dimensions of Notations. People and Computers V. 433--460. |Yehuda Handelsman, Jeffrey I. Mechanick, Lawrence Blonde, George Grunberger, Zachary T. Bloomgarden, George A. Bray, Samuel Dagogo-Jack, Jaime A. Davidson, Daniel Einhorn, On Ganda, Alan J. Garber, Irl B. Hirsch, Edward S. Horton, Faramarz Ismail-Beigi, Paul S. Jellinger, Kenneth L. Jones, Lios Jovanovi\u010d, Harold Lebovitz, Philip Levy, Etie S. Moghissi, Eric A. Orzeck, Aaron I. Vinik, and Kathleen L. Wyne. 2011. American Association of Clinical Endocrinologists medical guidelines for clinical practice for developing a diabetes mellitus comprehensive care plan. Endocr. Pract. 17, 5 (2011), 826--831.|Kathleen A. Harder, John R. Bloomfield, Sue E. Sendelbach, Michele F. Shepherd, Pam S. Rush, Jamie S. Sinclair, Mark Kirschbaum, and Durand E. Burns. 2005. Improving the Safety of Heparin Administration by Implementing a Human Factors Process Analysis. Agency for Healthcare Research and Quality.|Patrice M. Healey and Edwin J. Jacobson. 1994. Common Medical Diagnoses: An Algorithmic Approach. Saunders.|Carl Hewitt, Peter Bishop, and Richard Steiger. 1973. A universal modular ACTOR formalism for artificial intelligence. In Proceedings of the International Joint Conference on Artificial intelligence (IJCAI\u201973). 235--245. |Richard Hillestad, James Bigelow, Anthony Bower, Federico Girosi, Robin Meili, Richard Scoville, and Roger Taylor. 2005. Can electronic medical record systems transform health care? Potential health benefits, savings, and costs. Health Affairs 24, 5 (2005), 1103--1117.|John T. James. 2013. A new, evidence-based estimate of patient harms associated with hospital care. J. Patient Safety 9, 3 (2013), 122--8.|Jan Martin Jansen, Rinus Plasmeijer, Pieter Koopman, and Peter Achten. 2010. Embedding a web-based workflow management system in a functional language. In Proceedings of the Language Descriptions, Tools and Applications Conference (LDTA\u201910), 2010.  |Spencer S. Jones, Robert S. Rudin, Tanja Perry, and Paul G. Shekelle. 2014. Health information technology: An updated systematic review with a focus on meaningful use. Ann. Intern. Med. 60, 1 (2014), 48--54.|Denis Kilmov and Yuval Shahar. 2013. iALARM: An intelligent alert language for activation, response, and monitoring of medical alerts. In Proceedings of the Revised Selected Papers of the AIME 2013 Joint Workshop on Process Support and Knowledge Representation in Health Care.  |David A. Kindig. 1971. Some implications of patient-oriented health care. In Proceedings of the Health Conference of the New York Academy of Medicine.|Andrew J. Ko, Robin Abraham, Laura Beckwith, Alan Blackwell, Margaret Burnett, Martin Erwig, Chris Scaffidi, Brad Myers, Mary Beth Rosson, Gregg Rothermel, and Susan Wiedenbeck. 2011. The state of the art in enduser software engineering. ACM Comput. Surv. 43, 3 (2011), Article No. 21.  |Ross Koppel, Metlay Cohen, Brian Abaluck, Russell Localio, Stephen E. Kimmel, and Brian L. Strom. 2005. Role of computerized physician order entry systems in facilitating medication errors. J. Am. Med. Assoc. 293, 10 (2005), 1197--1203.|Christopher P. Landrigan, Gareth J. Parry, Catherine B. Bones, Andrew D. Hackbarth, Donald A. Goldmann, and Paul J. Sharek. 2010. Temporal trends in rates of Ppatient harm resulting from medical care. New Engl. J. Med. 363 (2010), 2124--2134.|Lucian L. Leape. 1994. Error in medicine. J. Am. Med. Assoc. 272, 23 (1994), 1851--1857.|Lucian L. Leape, Ann G. Lawthers, Troyen A. Brennan, and William G. Johnson. 1993. Preventing medical injury. Qual. Rev. Bull. 19, 5 (1993), 144--149.|Tita Alissa Listyowardojo, Raoul E. Nap, and Addie Johnson. 2011. Variations in hospital worker perceptions of safety culture. Int. J. Qual. Health Care 24, 1 (2011), 9--15.|Greg Little, Lydia B. Chilton, Max Goldman, and Robert C. Miller. 2010. TurKit: Human Computation Algorithms on Mechanical Turk. In Proceedings of the 23rd Annual ACM Symposium on User Interface Software and Technology.  |Laurence E. Mather and Christopher J. Glynn. 1982. The minimum effective analgetic blood concentration of pethidine in patients with intractable pain. Br. J. Clin. Pharmacol. 14, 3 (1982), 385--390.|Wilson C. Mertens, Stefan C. Christov, George S. Avrunin, Lori A. Clarke, Leon J. Osterweil, Lucinda J. Cassells, and Jenna L. Marquard. 2012. Using process elicitation and validation to understand and improve chemotherapy ordering and delivery. Joint Commis. J. Qual. Patient Safety 38, 11 (2012), 497--505.|Gianpaolo Molino, Paolo Terenziani, Stefania Montani, Alessio Bottrighi, and Mauro Torchio. 2006. GLARE: A Domain-Independent System for Acquiring, Representing and Executing Clinical Guidelines. In Proceedings of the American Medical Informatics Association Annual Proceedings (AMIA\u201906).|Stuart B. Mushlin and Harry L. Greene II. 2010. Decision Making in Medicine (3rd ed.). Mosby.|Bonnie A. Nardi. 1993. A Small Matter of Programming: Perspectives on End User Computing. MIT Press, Cambridge, MA. |John F. Pane, Brad A. Myers, and Leah B. Miller. 2002. Using HCI Techniques to Design a More Usable Programming System. In Proceedings Symposia on Human Centric Computing Languages and Environments. |John F. Pane, Chotirat Ann Ratanamahatana, and Brad A. Myers. 2001. Studying the language and structure in nonprogrammers\u2019 solutions to programming problems. Int. J. Hum.-Comput. Stud. 54, 2 (2001), 237--264.  |Mor Peleg, Aziz A. Boxwala, Omolola Ogunyemi, Qin Zeng, Samson Tu, Ronilda Lacson, Elmer Bernstam, Nachman Ash, Peter Mork, Lucila Ohno-Machado, Edward H. Shortliff, and Robert A. Greenes. 2000. GLIF3: The evolution of a guideline representation format. In Proceedings American Medical Informatics Association (AMIA\u201900). 645--649.|Donald D. Prince, Francis M. Bush, Stephen Long, and Stephen W. Harkins. 1994. A comparison of pain measurement characteristics of mechanical visual analogue and simple numerical rating scales. Pain 56, 2 (1994), 217--226.|Donald D. Prince, Patricia A. McGarth, Amir Rafii, and Barbara Buckingham. 1983. The validation of visual analogue scales as ratio scale measurments for chronic and experimental pain. Pain 17, 1 (1983), 45--56.|Gruia-Catalin Roman. 1985. A taxonomy of current issues in requirements engineering. Computer 4.  |Massimo Ruffolo, Rosario Curia, and Lorenzo Gallucci. 2005. Process Management in Health Care: A System for Preventing Risks and Medical Errors. In Proceedings of the Business Process Management. 334--343.  |Arvind Satyanarayan, Kanit Wongsuphasawat, and Jeffrey Heer. 2014. Declarative Interaction Design for Data Visualization. In Proceedings of the 27th Annual ACM Symposium on User Interface Software and Technology.  |E. M. Schimmel. 1964. The hazards of hospitalization. Ann. Intern. Med. 60, 1 (1964), 100--110.|Yuval Sharar, Silvia Miksch, and Peter Johnson. 1998. The Asgaard project: a task-specific framework for the application and critiquing of time-oriented clinical guidelines. Artif. Intell. Med. 14, 1--2 (1998), 29--51.|M. E. Sime, T. R. G. Green, and D. J. Guest. 1972. Psychological evaluation of two conditional constructs used in computer languages. Int. J. Hum.-Comput. Stud. 5, 1 (1973), 105--113.  |Sara J. Singer, David M. Gaba, Alyson Falwell, Shoutzu Lin, Jennifer Hayes, and Laurence Baker. 2009. Patient safety climate in 92 US hospitals: Differences by work area and discipline. Medical Care 47, 1 (2009), 23--31.|Hardeep Singh, Shrinidi Mani, Donna Espadas, Nancy Petersen, Veronica Franklin, and Laura A. Petersen. 2009. Prescription errors and outcomes related to inconsistent information transmitted through computerized order entry: A prospective study. Arch. Intern. Med. 169, 10 (2009), 982--989.|Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim Slattery. 2011. An empirical comparison of the accuracy rates of novices using the Quorum, Perl, and Randomo programming languages. In Proceedings of the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming Languages and Tools.  |Ian G. Stiell, R. Douglas McKnight, Gary H. Greenberg, Ian McDowell, Rama C. Nair, George A. Wells, Cristine Johns, and James R. Worthington. 1994. Implementation of the ottawa ankle rules. J. Am. Med. Assoc. 271, 11 (1994), 827--832.|The SPRINT Research Group. 2015. A randomized trial of intensive versus standard blood-pressure control. New Engl. J. Med. 373, 22 (2015), 2103--2116.|Samson W. Tu and Mark A. Musen. 1999. A flexible approach to guideline modeling. In Proceedings of the American Medical Informatics Association Conference (AMIA\u201999). 420--424.|W. M. P. van der Aalst, M. Pesic, and H. Schonenberg. 2009. Declarative workflows: Balancing between flexibility and support. Comput. Sci.-Res. Dev. 23, 2 (2009), 99--113.|Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, and Mathias Weske. 2003. Busisness Process Management: A Survey. In Proceedings of the 2003 International Conference on Business Process Management. |Washington Adventist Hospital. 2009. Weight-Based beparin orders. Retrieved from https://extranet.adventisthealthcare.com/LinkClick.aspx?fileticket&equals;rroECsjCLnY%3D8tabid&equals;6498mid&equals;1813.|K. N. Whitley. 1997. Visual Programming Languages and the Empirical Evidence For and Against. J. Vis. Lang. Comput. 8, 1 (1997), 109--142.|Paul R. Yarnold and Robert C. Soltysik. 2004. Optimal Data Analysis: A Guidebook With Software for Windows. APA Books. |Paul R. Yarnold and Robert C. Soltysik. 2016. Maximizing Predictive Accuracy. ODA Books.|", "organization": "Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University, Department of Electrical Engineering and Computer Science|University of Utah, School of Computing|Northwestern University Feinberg School of Medicine, Department of Dermatology|Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University Feinberg School of Medicine, Department of Dermatology|Northwestern University Feinberg School of Medicine, Department of Dermatology 8 Northwestern University Feinberg School of Medicine, Department of Pediatrics |Northwestern University Feinberg School of Medicine, Department of Obstetrics and Gynecology |Optimal Data Analysis LLC|Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University Feinberg School of Medicine, Department of Dermatology 8 Northwestern University Feinberg School of Medicine, Department of Medicine |Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University, Department of Electrical Engineering and Computer Science|University of Utah, School of Computing|Northwestern University Feinberg School of Medicine, Department of Dermatology|Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University Feinberg School of Medicine, Department of Dermatology|Northwestern University Feinberg School of Medicine, Department of Dermatology 8 Northwestern University Feinberg School of Medicine, Department of Pediatrics |Northwestern University Feinberg School of Medicine, Department of Obstetrics and Gynecology |Optimal Data Analysis LLC|Northwestern University, Department of Electrical Engineering and Computer Science|Northwestern University Feinberg School of Medicine, Department of Dermatology 8 Northwestern University Feinberg School of Medicine, Department of Medicine |", "title": ["POP-PL: A Patient-Oriented Prescription Programming Language"]},
{"abstract": "This work presents a machine-checked formalisation of the Java memory model and connects it to an operational semantics for Java and Java bytecode. For the whole model, I prove the data race freedom guarantee and type safety. The model extends previous formalisations by dynamic memory allocation, thread spawns and joins, infinite executions, the wait-notify mechanism, and thread interruption, all of which interact in subtle ways with the memory model. The formalisation resulted in numerous clarifications of and fixes to the existing JMM specification.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Andreas Lochbihler|Andreas Lochbihler|", "references": "", "organization": "Karlsruhe Institute of Technology, Switzerland|Karlsruhe Institute of Technology, Switzerland|", "title": ["Making the java memory model safe"]},
{"abstract": "Growing interest in graphics processing units has brought renewed attention to the Single Instruction Multiple Data (SIMD) execution model. SIMD machines give application developers tremendous computational power; however, programming them is still challenging. In particular, developers must deal with memory and control-flow divergences. These phenomena stem from a condition that we call data divergence, which occurs whenever two processing elements (PEs) see the same variable name holding different values. This article introduces divergence analysis, a static analysis that discovers data divergences. This analysis, currently deployed in an industrial quality compiler, is useful in several ways: it improves the translation of SIMD code to non-SIMD CPUs, it helps developers to manually improve their SIMD applications, and it also guides the automatic optimization of SIMD programs. We demonstrate this last point by introducing the notion of a divergence-aware register spiller. This spiller uses information from our analysis to either rematerialize or share common data between PEs. As a testimony of its effectiveness, we have tested it on a suite of 395 CUDA kernels from well-known benchmarks. The divergence-aware spiller produces GPU code that is 26.21% faster than the code produced by the register allocator used in the baseline compiler.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Diogo Sampaio|Rafael Martins de Souza|Sylvain Collange|Fernando Magno Quint\u00e3o Pereira|Diogo Sampaio|Rafael Martins de Souza|Sylvain Collange|Fernando Magno Quint\u00e3o Pereira|", "references": "", "organization": "Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|INRIA, Rennes Cedex, France|Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|INRIA, Rennes Cedex, France|Universidade Federal de Minas Gerais, Belo Horizonte, Brazil|", "title": ["Divergence analysis"]},
{"abstract": "Differential privacy is a notion of confidentiality that allows useful computations on sensible data while protecting the privacy of individuals. Proving differential privacy is a difficult and error-prone task that calls for principled approaches and tool support. Approaches based on linear types and static analysis have recently emerged; however, an increasing number of programs achieve privacy using techniques that fall out of their scope. Examples include programs that aim for weaker, approximate differential privacy guarantees and programs that achieve differential privacy without using any standard mechanisms. Providing support for reasoning about the privacy of such programs has been an open problem.\nWe report on CertiPriv, a machine-checked framework for reasoning about differential privacy built on top of the Coq proof assistant. The central component of CertiPriv is a quantitative extension of probabilistic relational Hoare logic that enables one to derive differential privacy guarantees for programs from first principles. We demonstrate the applicability of CertiPriv on a number of examples whose formal analysis is out of the reach of previous techniques. In particular, we provide the first machine-checked proofs of correctness of the Laplacian, Gaussian, and exponential mechanisms and of the privacy of randomized and streaming algorithms from the literature.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gilles Barthe|Boris K\u00f6pf|Federico Olmedo|Santiago Zanella-B\u00e9guelin|Gilles Barthe|Boris K\u00f6pf|Federico Olmedo|Santiago Zanella-B\u00e9guelin|", "references": "", "organization": "IMDEA Software Institute|IMDEA Software Institute|IMDEA Software Institute|Microsoft Research|IMDEA Software Institute|IMDEA Software Institute|IMDEA Software Institute|Microsoft Research|", "title": ["Probabilistic Relational Reasoning for Differential Privacy"]},
{"abstract": "Writing concurrent applications is extremely challenging, not only in terms of producing bug-free and maintainable software, but also for enabling developer productivity. In this article we present the \u00c6minium concurrent-by-default programming language. Using \u00c6minium programmers express data dependencies rather than control flow between instructions. Dependencies are expressed using permissions, which are used by the type system to automatically parallelize the application. The \u00c6minium approach provides a modular and composable mechanism for writing concurrent applications, preventing data races in a provable way. This allows programmers to shift their attention from low-level, error-prone reasoning about thread interleaving and synchronization to focus on the core functionality of their applications. We study the semantics of \u00c6minium through \n\u00c6minium, a sound core calculus that leverages permission flow to enable concurrent-by-default execution. After discussing our prototype implementation we present several case studies of our system. Our case studies show up to 6.5X speedup on an eight-core machine when leveraging data group permissions to manage access to shared state, and more than 70% higher throughput in a Web server application.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sven Stork|Karl Naden|Joshua Sunshine|Manuel Mohr|Alcides Fonseca|Paulo Marques|Jonathan Aldrich|Sven Stork|Karl Naden|Joshua Sunshine|Manuel Mohr|Alcides Fonseca|Paulo Marques|Jonathan Aldrich|", "references": "", "organization": "Carnegie Mellon University|Carnegie Mellon University|Carnegie Mellon University|Karlsruhe Institute of Technology|University of Coimbra|University of Coimbra|Carnegie Mellon University|Carnegie Mellon University|Carnegie Mellon University|Carnegie Mellon University|Karlsruhe Institute of Technology|University of Coimbra|University of Coimbra|Carnegie Mellon University|", "title": ["\u00c6minium: A Permission-Based Concurrent-by-Default Programming Language Approach"]},
{"abstract": "This paper defines a new variant of program slicing, called \n, and presents an algorithm for the specialization-slicing problem that creates an optimal output slice. An algorithm for specialization slicing is \n: for a given procedure \u0440, the algorithm may create multiple specialized copies of \u0440. In creating specialized procedures, the algorithm must decide for which patterns of formal parameters a given procedure should be specialized and which program elements should be included in each specialized procedure.\nWe formalize the specialization-slicing problem as a partitioning problem on the elements of the possibly \n unrolled program. To manipulate possibly infinite sets of program elements, the algorithm makes use of automata-theoretic techniques originally developed in the model-checking community. The algorithm returns a \n that is optimal (with respect to a criterion defined in the article). In particular, (i) each element replicated by the specialization-slicing algorithm provides information about specialized patterns of program behavior that are intrinsic to the program, and (ii) the answer is of minimal size (i.e., among all possible answers with property (i), there is no smaller one).\nThe specialization-slicing algorithm provides a new way to create executable slices. Moreover, by combining specialization slicing with forward slicing, we obtain a method for removing unwanted features from a program. While it was previously known how to solve the feature-removal problem for single-procedure programs, it was not known how to solve it for programs with procedure calls.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Min Aung|Susan Horwitz|Rich Joiner|Thomas Reps|Min Aung|Susan Horwitz|Rich Joiner|Thomas Reps|", "references": "", "organization": "University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI and Gramma Tech, Inc., Ithaca, NY|University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI|University of Wisconsin, Madison, WI and Gramma Tech, Inc., Ithaca, NY|", "title": ["Specialization Slicing"]},
{"abstract": "CompCert is a formally verified compiler that generates compact and efficient code for a large subset of the C language. However, CompCert foregoes using SSA, an intermediate representation employed by many compilers that enables writing simpler, faster optimizers. In fact, it has remained an open problem to verify formally an SSA-based compiler. We report on a formally verified, SSA-based middle-end for CompCert. In addition to providing a formally verified SSA-based middle-end, we address two problems raised by Leroy in [2009]: giving an intuitive formal semantics to SSA, and leveraging its global properties to reason locally about program optimizations.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Gilles Barthe|Delphine Demange|David Pichardie|Gilles Barthe|Delphine Demange|David Pichardie|", "references": "", "organization": "IMDEA Software Institute|IRISA -- University of Rennes 1/Inria|IRISA -- ENS Rennes/Inria|IMDEA Software Institute|IRISA -- University of Rennes 1/Inria|IRISA -- ENS Rennes/Inria|", "title": ["Formal Verification of an SSA-Based Middle-End for CompCert"]},
{"abstract": "This article describes the design and implementation of a system, called T\n (for Transformer Specification Language), that provides a systematic solution to the problem of creating retargetable tools for analyzing machine code. T\n is a tool generator---that is, a metatool---that automatically creates different abstract interpreters for machine-code instruction sets.\nThe most challenging technical issue that we faced in designing T\n was how to automate the generation of the set of \n for a given abstract interpretation of a given instruction set. From a description of the \n of an instruction set, together with the datatypes and operations that define an abstract domain, T\n automatically creates the set of abstract transformers for the instructions of the instruction set. T\n advances the state-of-the-art in program analysis because it provides two dimensions of parameterizability: (i) a given analysis component can be retargeted to different instruction sets; (ii) multiple analysis components can be created automatically from a single specification of the concrete operational semantics of the language to be analyzed.\nT\n is an \n. The article describes the principles behind T\n, and discusses how one uses T\n to develop different abstract interpreters.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Junghee Lim|Thomas Reps|Junghee Lim|Thomas Reps|", "references": "", "organization": "University of Wisconsin|University of Wisconsin and GrammaTech, Inc.|University of Wisconsin|University of Wisconsin and GrammaTech, Inc.|", "title": ["TSL: A System for Generating Abstract Interpreters and its Application to Machine-Code Analysis"]},
{"abstract": "We consider the verified compilation of high-level managed languages like Java or C# whose intermediate representations provide support for shared-memory synchronization and automatic memory management. Our development is framed in the context of the Total Store Order relaxed memory model. Ensuring complier correctness is challenging because high-level actions are translated into sequences of nonatomic actions with compiler-injected snippets of racy code; the behavior of this code depends not only on the actions of other threads but also on out-of-order executions performed by the processor. A na\u00efve proof of correctness would require reasoning over all possible thread interleavings. In this article, we propose a refinement-based proof methodology that precisely relates concurrent code expressed at different abstraction levels, cognizant throughout of the relaxed memory semantics of the underlying processor. Our technique allows the compiler writer to reason compositionally about the atomicity of low-level concurrent code used to implement managed services. We illustrate our approach with examples taken from the verification of a concurrent garbage collector.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Suresh Jagannathan|Vincent Laporte|Gustavo Petri|David Pichardie|Jan Vitek|Suresh Jagannathan|Vincent Laporte|Gustavo Petri|David Pichardie|Jan Vitek|", "references": "", "organization": "Purdue University, IN. USA|Universit\u00e9 Rennes 1 /IRISA, Rennes Cedex, France|Purdue University, IN. USA|ENS Rennes /IRISA /INRIA, Rennes Cedex, France|Purdue University, IN. USA|Purdue University, IN. USA|Universit\u00e9 Rennes 1 /IRISA, Rennes Cedex, France|Purdue University, IN. USA|ENS Rennes /IRISA /INRIA, Rennes Cedex, France|Purdue University, IN. USA|", "title": ["Atomicity Refinement for Verified Compilation"]},
{"abstract": "Verifying program transformations usually requires proving that the resulting program (the target) refines or is equivalent to the original one (the source). However, the refinement relation between individual sequential threads cannot be preserved in general with the presence of parallel compositions, due to instruction reordering and the different granularities of atomic operations at the source and the target. On the other hand, the refinement relation defined based on fully abstract semantics of concurrent programs assumes arbitrary parallel environments, which is too strong and cannot be satisfied by many well-known transformations.\nIn this article, we propose a \nely-\nuarantee-based \nulation (RGSim) to verify concurrent program transformations. The relation is parametrized with constraints of the environments that the source and the target programs may compose with. It considers the interference between threads and their environments, thus is less permissive than relations over sequential programs. It is compositional with respect to parallel compositions as long as the constraints are satisfied. Also, RGSim does not require semantics preservation under all environments, and can incorporate the assumptions about environments made by specific program transformations in the form of rely/guarantee conditions. We use RGSim to reason about optimizations and prove atomicity of concurrent objects. We also propose a general garbage collector verification framework based on RGSim, and verify the Boehm et al. concurrent mark-sweep GC.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Hongjin Liang|Xinyu Feng|Ming Fu|Hongjin Liang|Xinyu Feng|Ming Fu|", "references": "", "organization": "University of Science and Technology of China|University of Science and Technology of China|University of Science and Technology of China|University of Science and Technology of China|University of Science and Technology of China|University of Science and Technology of China|", "title": ["Rely-Guarantee-Based Simulation for Compositional Verification of Concurrent Program Transformations"]},
{"abstract": "We propose an axiomatic generic framework for modelling weak memory. We show how to instantiate this framework for Sequential Consistency (SC), Total Store Order (TSO), C++ restricted to release-acquire atomics, and Power. For Power, we compare our model to a preceding operational model in which we found a flaw. To do so, we define an operational model that we show equivalent to our axiomatic model.\nWe also propose a model for ARM. Our testing on this architecture revealed a behaviour later acknowledged as a bug by ARM, and more recently, 31 additional anomalies.\nWe offer a new simulation tool, called herd, which allows the user to specify the model of his choice in a concise way. Given a specification of a model, the tool becomes a simulator for that model. The tool relies on an axiomatic description; this choice allows us to outperform all previous simulation tools. Additionally, we confirm that verification time is vastly improved, in the case of bounded model checking.\nFinally, we put our models in perspective, in the light of empirical data obtained by analysing the C and C++ code of a Debian Linux distribution. We present our new analysis tool, called mole, which explores a piece of code to find the weak memory idioms that it uses.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Jade Alglave|Luc Maranget|Michael Tautschnig|Jade Alglave|Luc Maranget|Michael Tautschnig|", "references": "", "organization": "University College London, Gower Street, London, United Kingdom|INRIA, France|Queen Mary University of London, London, United Kingdom|University College London, Gower Street, London, United Kingdom|INRIA, France|Queen Mary University of London, London, United Kingdom|", "title": ["Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak Memory"]},
{"abstract": "Integrated Development Environments (IDEs) increase programmer productivity, providing rapid, interactive feedback based on the syntax and semantics of a language. Unlike conventional parsing algorithms, scannerless generalized-LR parsing supports the full set of context-free grammars, which is closed under composition, and hence can parse languages composed from separate grammar modules. To apply this algorithm in an interactive environment, this article introduces a novel error recovery mechanism. Our approach is language independent, and relies on automatic derivation of recovery rules from grammars. By taking layout information into consideration it can efficiently suggest natural recovery suggestions.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Maartje de Jonge|Lennart C. L. Kats|Eelco Visser|Emma S\u00f6derberg|Maartje de Jonge|Lennart C. L. Kats|Eelco Visser|Emma S\u00f6derberg|", "references": "", "organization": "Technical University Delft|Technical University Delft|Technical University Delft|Lund University|Technical University Delft|Technical University Delft|Technical University Delft|Lund University|", "title": ["Natural and Flexible Error Recovery for Generated Modular Language Environments"]},
{"abstract": "Through the use of conditional compilation and related tools, many software projects can be used to generate a huge number of related programs. The problem of typing such variational software is difficult. The brute-force strategy of generating all variants and typing each one individually is: (1) usually infeasible for efficiency reasons and (2) produces results that do not map well to the underlying variational program. Recent research has focused mainly on efficiency and addressed only the problem of type checking. In this work we tackle the more general problem of variational type inference and introduce variational types to represent the result of typing a variational program. We introduce the variational lambda calculus (VLC) as a formal foundation for research on typing variational programs. We define a type system for VLC in which VLC expressions are mapped to correspondingly variational types. We show that the type system is correct by proving that the typing of expressions is preserved over the process of variation elimination, which eventually results in a plain lambda calculus expression and its corresponding type. We identify a set of equivalence rules for variational types and prove that the type unification problem modulo these equivalence rules is unitary and decidable; we also present a sound and complete unification algorithm. Based on the unification algorithm, the variational type inference algorithm is an extension of algorithm \n. We show that it is sound and complete and computes principal types. We also consider the extension of VLC with sum types, a necessary feature for supporting variational data types, and demonstrate that the previous theoretical results also hold under this extension. Finally, we characterize the complexity of variational type inference and demonstrate the efficiency gains over the brute-force strategy.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Sheng Chen|Martin Erwig|Eric Walkingshaw|Sheng Chen|Martin Erwig|Eric Walkingshaw|", "references": "", "organization": "Oregon State University|Oregon State University|Oregon State University|Oregon State University|Oregon State University|Oregon State University|", "title": ["Extending Type Inference to Variational Programs"]},
{"abstract": "Reachability from a program variable \n to a program variable \n states that from \n, it is possible to follow a path of memory locations that leads to the object bound to \n. We present a new abstract domain for the static analysis of possible reachability between program variables or, equivalently, definite unreachability between them. This information is important for improving the precision of other static analyses, such as side-effects, field initialization, cyclicity and path-length analysis, as well as more complex analyses built upon them, such as nullness and termination analysis. We define and prove correct our reachability analysis for Java bytecode, defined as a constraint-based analysis, where the constraint is a graph whose nodes are the program points and whose arcs propagate reachability information in accordance to the abstract semantics of each bytecode instruction. For each program point \n, our reachability analysis produces an overapproximation of the ordered pairs of variables \u3008\n, \n\u3009 such that \n \n \n at \n. Seen the other way around, if a pair \u3008\n, \n\u3009 is not present in the overapproximation at \n, then \n \n \n at \n. We have implemented the analysis inside the Julia static analyzer. Our experiments of analysis of nontrivial Java and Android programs show the improvement of precision due to the presence of reachability information. Moreover, reachability analysis actually reduces the overall cost of nullness and termination analysis.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "\u0110urica Nikoli\u0107|Fausto Spoto|\u0110urica Nikoli\u0107|Fausto Spoto|", "references": "", "organization": "University of Verona and Microsoft Research - University of Trento Centre for Computational and Systems Biology |University of Verona|University of Verona and Microsoft Research - University of Trento Centre for Computational and Systems Biology |University of Verona|", "title": ["Reachability analysis of program variables"]},
{"abstract": "This article presents a family of static analyses to determine pointer targets, control flow, and dataflow in combination. The integrated solution to these mutually dependent problems approaches the result from the optimistic side. It is a general strategy for static program analysis and does not need any upfront approximation for one of the problems to overcome the mutual dependencies. A degenerated case yields Andersen\u2019s famous pointer analysis; otherwise, the analyses are flow-sensitive and can support direct and indirect strong updates, within the same cubic asymptotic complexity as known for Andersen, albeit with larger constants.\nSurprisingly, the ideas behind the integrated analysis are intuitive. The strategy we describe naturally evolves from considering the mutual dependencies between the three problems, or from generalizing Andersen\u2019s analysis to flow sensitivity. Such a flow-sensitive Andersen analysis not only computes pointer targets with higher precision than the original analysis, but it also creates an interprocedural SSA form at the same time.\nOur extensive experimental evaluation shows that the integrated solution is practical as it can be applied to reasonably large real-world programs within a few seconds or minutes. This uses some optimizations which together achieve a speedup of more than 100 for several programs. We compare several members of the family of analyses, from flow- and field-insensitive to flow- and field-sensitive with strong updates, both with and without optimizations. This gives some insights into the effects of these dimensions of precision on the results. It also sheds new light on the benefits of flow sensitivity versus the costs associated with it.\n", "magazine": "ACM Transactions on Programming Languages and Systems", "author": "Stefan Staiger-St\u00f6hr|Stefan Staiger-St\u00f6hr|", "references": "", "organization": "University of Stuttgart|University of Stuttgart|", "title": ["Practical Integrated Analysis of Pointers, Dataflow and Control Flow"]}
]